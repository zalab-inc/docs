Directory structure:
└── react-hook-form-react-hook-form
    ├── cypress
    │   ├── plugins
    │   │   └── index.ts
    │   ├── e2e
    │   │   ├── controller.cy.ts
    │   │   ├── conditionalField.cy.ts
    │   │   ├── useFieldArray.cy.ts
    │   │   ├── setValueWithSchema.cy.ts
    │   │   ├── setFocus.cy.ts
    │   │   ├── formStateWithSchema.cy.ts
    │   │   ├── useFieldArrayNested.cy.ts
    │   │   ├── validateFieldCriteria.cy.ts
    │   │   ├── delayError.cy.ts
    │   │   ├── basicSchemaValidation.cy.ts
    │   │   ├── watchUseFieldArrayNested.cy.ts
    │   │   ├── formStateWithNestedFields.cy.ts
    │   │   ├── autoUnregister.cy.ts
    │   │   ├── reValidateMode.cy.ts
    │   │   ├── reset.cy.ts
    │   │   ├── customSchemaValidation.cy.ts
    │   │   ├── basic.cy.ts
    │   │   ├── setValue.cy.ts
    │   │   ├── isValid.cy.ts
    │   │   ├── setError.cy.ts
    │   │   ├── watch.cy.ts
    │   │   ├── useWatchUseFieldArrayNested.cy.ts
    │   │   ├── manualRegisterForm.cy.ts
    │   │   ├── defaultValues.cy.ts
    │   │   ├── useFieldArrayAsync.cy.ts
    │   │   ├── setValueWithTrigger.cy.ts
    │   │   ├── useFieldArrayUnregister.cy.ts
    │   │   ├── triggerValidation.cy.ts
    │   │   ├── useWatch.cy.ts
    │   │   ├── setValueAsyncStrictMode.cy.ts
    │   │   ├── watchDefaultValues.cy.ts
    │   │   ├── setValueCustomRegister.cy.ts
    │   │   ├── formState.cy.ts
    │   │   ├── watchUseFieldArray.cy.ts
    │   │   ├── useFormState.cy.ts
    │   │   └── defaultValuesAsync.cy.ts
    │   ├── support
    │   │   ├── e2e.js
    │   │   └── commands.js
    │   └── tsconfig.json
    ├── docs
    │   ├── README.es-ES.md
    │   ├── README.ko-KR.md
    │   ├── README.fr-FR.md
    │   ├── README.ru-RU.md
    │   ├── README.ar-AR.md
    │   ├── README.pt-BR.md
    │   ├── README.de-DE.md
    │   ├── README.zh-CN.md
    │   ├── README.tr-TR.md
    │   ├── README.V7.zh-CN.md
    │   ├── README.V6.md
    │   ├── README.V7.ja-JP.md
    │   ├── README.ja-JP.md
    │   ├── Template.md
    │   ├── README.it-IT.md
    │   ├── Sponsors.yaml
    │   └── README.zh-TW.md
    ├── .prettierrc
    ├── .prettierignore
    ├── .npmrc
    ├── scripts
    │   ├── jest
    │   │   ├── jest.config.js
    │   │   └── setup.ts
    │   ├── README
    │   │   ├── Insert.js
    │   │   ├── Previews
    │   │   │   ├── Helper.js
    │   │   │   ├── mod.ts
    │   │   │   ├── Company.js
    │   │   │   └── Individual.js
    │   │   ├── Updater.js
    │   │   ├── Imports.json
    │   │   ├── Link.js
    │   │   ├── Data.js
    │   │   ├── Generators.js
    │   │   ├── Files.js
    │   │   └── README.md
    │   ├── apiExtractor.js
    │   └── rollup
    │       ├── all-exports.json
    │       ├── createRollupConfig.js
    │       ├── rollup.esm.config.js
    │       ├── assert-cjs-exports.cjs
    │       ├── rollup.config.js
    │       └── assert-esm-exports.mjs
    ├── .github
    │   ├── workflows
    │   │   ├── lock-issue.yml
    │   │   ├── README.yml
    │   │   ├── build-test.yml
    │   │   ├── compressed-size.yml
    │   │   ├── api-extrator.yml
    │   │   ├── automation.yml
    │   │   └── codeql-analysis.yml
    │   ├── FUNDING.yml
    │   ├── stale.yml
    │   ├── PULL_REQUEST_TEMPLATE
    │   │   └── pull_request_template.md
    │   ├── actions
    │   │   └── install-dependencies
    │   │       └── action.yml
    │   └── ISSUE_TEMPLATE
    │       ├── config.yml
    │       ├── bug_report.yml
    │       └── feature_request.md
    ├── cypress.config.ts
    ├── api-extractor.json
    ├── .codesandbox
    │   └── ci.json
    ├── package.json
    ├── CODE_OF_CONDUCT.md
    ├── .husky
    │   ├── .gitignore
    │   └── pre-commit
    ├── examples
    │   ├── V7
    │   │   ├── asyncSubmitValidation.tsx
    │   │   ├── customMaskedInputWithController.tsx
    │   │   ├── dirtyTouchedSubmitted.tsx
    │   │   ├── asyncFieldValidation.tsx
    │   │   ├── getValuesCompareFields.tsx
    │   │   ├── normalizeField.tsx
    │   │   ├── nativeMultipleInput.tsx
    │   │   ├── resetForm.tsx
    │   │   ├── typescript
    │   │   │   ├── Resolver.tsx
    │   │   │   ├── NestedValue.tsx
    │   │   │   ├── UseFormMethods.tsx
    │   │   │   ├── SubmitHandler.tsx
    │   │   │   └── Control.tsx
    │   │   ├── defaultValues.tsx
    │   │   ├── validationOnFieldChange.tsx
    │   │   ├── remoteTriggerFormSubmit.tsx
    │   │   ├── customInput.tsx
    │   │   ├── conditionalFields.tsx
    │   │   ├── customValidation.tsx
    │   │   ├── disableNativeValidation.tsx
    │   │   ├── registerWithErrorMessages.tsx
    │   │   ├── initalFormState.tsx
    │   │   ├── formProvider.tsx
    │   │   ├── nestedFields.tsx
    │   │   ├── triggerFieldValidation.tsx
    │   │   ├── validationSchema.tsx
    │   │   ├── basicValidation.tsx
    │   │   ├── parseFormatInputValues.tsx
    │   │   ├── asyncSetFormValues.tsx
    │   │   ├── FieldArray.tsx
    │   │   ├── validationOnFieldBlur.tsx
    │   │   ├── basic.tsx
    │   │   ├── fieldArrayMinLength.tsx
    │   │   └── setValue.tsx
    │   ├── V6
    │   │   ├── asyncSubmitValidation.tsx
    │   │   ├── customMaskedInputWithController.tsx
    │   │   ├── dirtyTouchedSubmitted.tsx
    │   │   ├── custom-masked-input.tsx
    │   │   ├── asyncFieldValidation.tsx
    │   │   ├── getValuesCompareFields.tsx
    │   │   ├── normalizeField.tsx
    │   │   ├── nativeMultipleInput.tsx
    │   │   ├── resetForm.tsx
    │   │   ├── typescript
    │   │   │   ├── Resolver.tsx
    │   │   │   ├── NestedValue.tsx
    │   │   │   ├── UseFormMethods.tsx
    │   │   │   ├── SubmitHandler.tsx
    │   │   │   └── Control.tsx
    │   │   ├── defaultValues.tsx
    │   │   ├── validationOnFieldChange.tsx
    │   │   ├── remoteTriggerFormSubmit.tsx
    │   │   ├── customInput.tsx
    │   │   ├── conditionalFields.tsx
    │   │   ├── customValidation.tsx
    │   │   ├── disableNativeValidation.tsx
    │   │   ├── registerWithErrorMessages.tsx
    │   │   ├── initalFormState.tsx
    │   │   ├── formProvider.tsx
    │   │   ├── nestedFields.tsx
    │   │   ├── triggerFieldValidation.tsx
    │   │   ├── validationSchema.tsx
    │   │   ├── forwardRefToPassRefProp.tsx
    │   │   ├── basicValidation.tsx
    │   │   ├── parseFormatInputValues.tsx
    │   │   ├── asyncSetFormValues.tsx
    │   │   ├── FieldArray.tsx
    │   │   ├── validationOnFieldBlur.tsx
    │   │   ├── README.md
    │   │   ├── basic.tsx
    │   │   ├── persistInputOnUnmount.tsx
    │   │   ├── fieldArrayMinLength.tsx
    │   │   └── setValue.tsx
    │   └── README.md
    ├── SECURITY.md
    ├── eslint.config.mjs
    ├── reports
    │   ├── api-extractor.md.api.md
    │   └── api-extractor.md
    ├── tsconfig.json
    ├── README.md
    ├── app
    │   ├── .env
    │   ├── .npmrc
    │   ├── index.html
    │   ├── vite.config.ts
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── README.md
    │   ├── pnpm-lock.yaml
    │   └── src
    │       ├── formStateWithSchema.tsx
    │       ├── crossFrameForm.tsx
    │       ├── useFormState.tsx
    │       ├── main.tsx
    │       ├── setFocus.tsx
    │       ├── useFieldArrayNested.tsx
    │       ├── basicSchemaValidation.tsx
    │       ├── useWatch.tsx
    │       ├── validateFieldCriteria.tsx
    │       ├── form.tsx
    │       ├── test.tsx
    │       ├── welcome
    │       │   ├── styles.ts
    │       │   └── index.tsx
    │       ├── autoUnregister.tsx
    │       ├── controller.tsx
    │       ├── defaultValues.tsx
    │       ├── resetKeepDirty.tsx
    │       ├── manualRegisterForm.tsx
    │       ├── disabledFields.tsx
    │       ├── useFieldArray.tsx
    │       ├── useWatchUseFieldArrayNested.tsx
    │       ├── watchUseFieldArrayNested.tsx
    │       ├── setError.tsx
    │       ├── formStateWithNestedFields.tsx
    │       ├── conditionalField.tsx
    │       ├── watch.tsx
    │       ├── useFieldArrayUnregister.tsx
    │       ├── isValid.tsx
    │       ├── style.css
    │       ├── watchDefaultValues.tsx
    │       ├── reset.tsx
    │       ├── triggerValidation.tsx
    │       ├── defaultValuesAsync.tsx
    │       ├── setValueStrictMode.tsx
    │       ├── formState.tsx
    │       ├── reValidateMode.tsx
    │       ├── delayError.tsx
    │       ├── setValueWithSchema.tsx
    │       ├── setValueCustomRegister.tsx
    │       ├── setValueWithTrigger.tsx
    │       ├── basic.tsx
    │       ├── app.tsx
    │       ├── setValue.tsx
    │       ├── watchUseFieldArray.tsx
    │       └── customSchemaValidation.tsx
    └── src
        ├── useFormState.ts
        ├── logic
        │   ├── getFieldValueAs.ts
        │   ├── getFieldValue.ts
        │   ├── getDirtyFields.ts
        │   ├── validateField.ts
        │   ├── iterateFieldsByAction.ts
        │   ├── getEventValue.ts
        │   ├── getCheckboxValue.ts
        │   ├── getFocusFieldName.ts
        │   ├── getNodeParentName.ts
        │   ├── getRadioValue.ts
        │   ├── shouldRenderFormState.ts
        │   ├── schemaErrorLookup.ts
        │   ├── createFormControl.ts
        │   ├── isNameInFieldArray.ts
        │   ├── getValueAndMessage.ts
        │   ├── hasPromiseValidation.ts
        │   ├── getValidateError.ts
        │   ├── appendErrors.ts
        │   ├── skipValidation.ts
        │   ├── updateFieldArrayRootError.ts
        │   ├── getProxyFormState.ts
        │   ├── isWatched.ts
        │   ├── getResolverOptions.ts
        │   ├── generateId.ts
        │   ├── index.ts
        │   ├── unsetEmptyArray.ts
        │   ├── generateWatchOutput.ts
        │   ├── getRuleValue.ts
        │   ├── hasValidation.ts
        │   ├── getValidationModes.ts
        │   └── shouldSubscribeByName.ts
        ├── useFieldArray.ts
        ├── form.tsx
        ├── controller.tsx
        ├── useWatch.ts
        ├── index.react-server.ts
        ├── useSubscribe.ts
        ├── constants.ts
        ├── useFormContext.tsx
        ├── useForm.ts
        ├── index.ts
        ├── __typetest__
        │   ├── errors.test-d.ts
        │   ├── form.test-d.ts
        │   ├── path
        │   │   ├── common.test-d.ts
        │   │   └── eager.test-d.ts
        │   ├── package.json
        │   ├── util.test-d.ts
        │   └── __fixtures__
        │       ├── pathString.ts
        │       ├── tuple.ts
        │       ├── dummy.d.ts
        │       ├── index.ts
        │       ├── type.ts
        │       └── traversable.ts
        ├── useController.ts
        ├── __tests__
        │   ├── useForm
        │   │   ├── resetField.test.tsx
        │   │   ├── getValues.test.tsx
        │   │   ├── trigger.test.tsx
        │   │   ├── handleSubmit.test.tsx
        │   │   ├── getFieldState.test.tsx
        │   │   ├── unregister.test.tsx
        │   │   ├── register.test.tsx
        │   │   ├── clearErrors.test.tsx
        │   │   ├── formState.test.tsx
        │   │   ├── resolver.test.tsx
        │   │   ├── setError.test.tsx
        │   │   ├── __snapshots__
        │   │   │   └── watch.test.tsx.snap
        │   │   ├── watch.test.tsx
        │   │   ├── reset.test.tsx
        │   │   └── setValue.test.tsx
        │   ├── isPlainObject.test.ts
        │   ├── logic
        │   │   ├── validateField.test.tsx
        │   │   ├── getFieldValue.test.ts
        │   │   ├── appendErrors.test.ts
        │   │   ├── getFocusFieldName.test.ts
        │   │   ├── getRadioValue.test.ts
        │   │   ├── getValidateError.test.ts
        │   │   ├── getNodeParentName.test.ts
        │   │   ├── schemaErrorLookup.test.ts
        │   │   ├── skipValidation.test.ts
        │   │   ├── getRuleValue.test.ts
        │   │   ├── getDirtyFields.test.ts
        │   │   ├── generateId.test.ts
        │   │   ├── getCheckboxValue.test.ts
        │   │   ├── getResolverOptions.test.ts
        │   │   ├── iterateFieldsByAction.test.ts
        │   │   ├── shouldSubscribeByName.test.ts
        │   │   ├── getFieldValueAs.test.ts
        │   │   ├── hasPromiseValidation.test.ts
        │   │   ├── getValueAndMessage.test.ts
        │   │   ├── isNameInFieldArray.test.ts
        │   │   ├── isWatched.test.ts
        │   │   ├── getEventValue.test.ts
        │   │   └── createFormControl.test.ts
        │   ├── controller.test.tsx
        │   ├── useFieldArray.test.tsx
        │   ├── useWatch.test.tsx
        │   ├── controller.server.test.tsx
        │   ├── __snapshots__
        │   │   ├── useWatch.test.tsx.snap
        │   │   └── useFieldArray.test.tsx.snap
        │   ├── useController.test.tsx
        │   ├── type.test.tsx
        │   ├── useFieldArray
        │   │   ├── append.test.tsx
        │   │   ├── focus.test.tsx
        │   │   ├── move.test.tsx
        │   │   ├── remove.test.tsx
        │   │   ├── prepend.test.tsx
        │   │   ├── update.test.tsx
        │   │   ├── swap.test.tsx
        │   │   ├── insert.test.tsx
        │   │   └── replace.test.tsx
        │   ├── form.test.tsx
        │   ├── useForm.server.test.tsx
        │   ├── useFormState.test.tsx
        │   ├── useFormContext.server.test.tsx
        │   ├── utils
        │   │   ├── set.test.ts
        │   │   ├── prepend.test.ts
        │   │   ├── isObject.test.ts
        │   │   ├── isBoolean.test.ts
        │   │   ├── flatten.test.ts
        │   │   ├── remove.test.ts
        │   │   ├── isRadioInput.test.ts
        │   │   ├── isFileInput.test.ts
        │   │   ├── isMessage.test.ts
        │   │   ├── createSubject.test.ts
        │   │   ├── validationModeChecker.test.ts
        │   │   ├── insert.test.ts
        │   │   ├── isRadioOrCheckbox.test.ts
        │   │   ├── isMultipleSelect.test.ts
        │   │   ├── isFunction.test.ts
        │   │   ├── cloneObject.test.ts
        │   │   ├── fillEmptyArray.test.ts
        │   │   ├── isKey.test.ts
        │   │   ├── isCheckBoxInput.test.ts
        │   │   ├── __snapshots__
        │   │   │   └── flatten.test.ts.snap
        │   │   ├── isUndefined.test.ts
        │   │   ├── isHTMLElement.test.ts
        │   │   ├── isEmptyObject.test.ts
        │   │   ├── unset.test.ts
        │   │   ├── objectHasFunction.test.ts
        │   │   ├── swap.test.ts
        │   │   ├── isString.test.ts
        │   │   ├── get.test.ts
        │   │   ├── stringToPath.test.ts
        │   │   ├── noop.test.ts
        │   │   ├── isNullOrUndefined.test.ts
        │   │   ├── isPrimitive.test.ts
        │   │   ├── move.test.ts
        │   │   ├── deepMerge.test.ts
        │   │   ├── isRegex.test.ts
        │   │   ├── deepEqual.test.ts
        │   │   └── compact.test.ts
        │   ├── useForm.test.tsx
        │   └── useFormContext.test.tsx
        ├── utils
        │   ├── swap.ts
        │   ├── isUndefined.ts
        │   ├── sleep.ts
        │   ├── isRadioOrCheckbox.ts
        │   ├── isCheckBoxInput.ts
        │   ├── isWeb.ts
        │   ├── isString.ts
        │   ├── isPrimitive.ts
        │   ├── convertToArrayPayload.ts
        │   ├── fillEmptyArray.ts
        │   ├── isFunction.ts
        │   ├── move.ts
        │   ├── isMessage.ts
        │   ├── update.ts
        │   ├── set.ts
        │   ├── stringToPath.ts
        │   ├── flatten.ts
        │   ├── isNullOrUndefined.ts
        │   ├── deepMerge.ts
        │   ├── isDateObject.ts
        │   ├── isMultipleSelect.ts
        │   ├── isFileInput.ts
        │   ├── objectHasFunction.ts
        │   ├── compact.ts
        │   ├── isRegex.ts
        │   ├── remove.ts
        │   ├── isObject.ts
        │   ├── isBoolean.ts
        │   ├── index.ts
        │   ├── live.ts
        │   ├── append.ts
        │   ├── isKey.ts
        │   ├── insert.ts
        │   ├── isHTMLElement.ts
        │   ├── cloneObject.ts
        │   ├── noop.ts
        │   ├── createSubject.ts
        │   ├── isPlainObject.ts
        │   ├── isRadioInput.ts
        │   ├── prepend.ts
        │   ├── deepEqual.ts
        │   ├── unset.ts
        │   ├── get.ts
        │   └── isEmptyObject.ts
        └── types
            ├── path
            │   ├── common.ts
            │   ├── index.ts
            │   └── eager.ts
            ├── validator.ts
            ├── controller.ts
            ├── resolvers.ts
            ├── utils.ts
            ├── form.ts
            ├── fields.ts
            ├── index.ts
            ├── errors.ts
            ├── events.ts
            └── fieldArray.ts

================================================
File: /cypress/plugins/index.ts
================================================
// ***********************************************************
// This example plugins/index.js can be used to load plugins
//
// You can change the location of this file or turn off loading
// the plugins file with the 'pluginsFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/plugins-guide
// ***********************************************************

// This function is called when a project is opened or re-opened (e.g. due to
// the project's config changing)

module.exports = () => {
  // `on` is used to hook into various events Cypress emits
  // `config` is the resolved Cypress config
};


================================================
File: /cypress/e2e/controller.cy.ts
================================================
describe('controller basic form validation', () => {
  it('should validate the form and reset the form', () => {
    cy.visit('http://localhost:3000/controller/onSubmit');
    cy.get('#submit').click();

    cy.get('#TextField').contains('TextField Error');
    cy.get('#RadioGroup').contains('RadioGroup Error');
    cy.get('#Checkbox').contains('Checkbox Error');
    cy.get('#RadioGroup').contains('RadioGroup Error');
    cy.get('#Select').contains('Select Error');
    cy.get('#switch').contains('switch Error');

    cy.get('#input-checkbox input').click();
    cy.get('input[name="gender1"]').first().click();
    cy.get('#input-textField input').type('test');
    cy.get('#input-select > div > div').click();
    cy.get('.MuiPopover-root ul > li:first-child').click();
    cy.get('#input-switch input').click();
    cy.get('#input-ReactSelect > div').click();
    cy.get('#input-ReactSelect > div > div').eq(1).click();

    cy.get('.container > p').should('have.length', 0);
    cy.get('#renderCount').contains('8');
  });

  it('should validate the form with onBlur mode and reset the form', () => {
    cy.visit('http://localhost:3000/controller/onBlur');

    cy.get('p').should('have.length', 0);
    cy.get('#input-checkbox input').focus();
    cy.get('#input-checkbox input').blur();
    cy.get('#Checkbox').contains('Checkbox Error');

    cy.get('#input-textField input').focus();
    cy.get('#input-textField input').blur();
    cy.get('#TextField').contains('TextField Error');

    cy.get('#input-select > div > div').focus();
    cy.get('#input-select > div > div').blur();
    cy.get('#Select').contains('Select Error');

    cy.get('#input-switch input').focus();
    cy.get('#input-switch input').blur();
    cy.get('#switch').contains('switch Error');

    cy.get('#input-checkbox input').click();
    cy.get('#input-textField input').type('test');
    cy.get('#input-select > div > div').click();
    cy.get('.MuiPopover-root ul > li:first-child').click();
    cy.get('#input-switch input').click();
    cy.get('#input-switch input').blur();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('9');
  });

  it('should validate the form with onChange mode and reset the form', () => {
    cy.visit('http://localhost:3000/controller/onChange');

    cy.get('#input-checkbox input').click();
    cy.get('#input-checkbox input').click();
    cy.get('#Checkbox').contains('Checkbox Error');

    cy.get('#input-textField input').type('test');
    cy.get('#input-textField input').clear();
    cy.get('#TextField').contains('TextField Error');

    cy.get('#input-switch input').click();
    cy.get('#input-switch input').click();
    cy.get('#switch').contains('switch Error');

    cy.get('#input-checkbox input').click();
    cy.get('#input-textField input').type('test');
    cy.get('#input-switch input').click();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('7');
  });
});


================================================
File: /cypress/e2e/conditionalField.cy.ts
================================================
describe('ConditionalField', () => {
  it('should reflect correct form state and data collection', () => {
    cy.visit('http://localhost:3000/conditionalField');
    cy.get('#state').should(($state) => {
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      });
    });

    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').type('luo');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['selectNumber', 'firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );
    cy.get('button#submit').click();
    cy.get('#result').contains(
      '{"selectNumber":"1","firstName":"bill","lastName":"luo"}',
    );
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['selectNumber', 'firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        selectNumber: '1',
        firstName: 'bill',
        lastName: 'luo',
      }),
    );

    cy.get('select[name="selectNumber"]').select('2');
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['selectNumber', 'firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: false,
      }),
    );
    cy.get('input[name="min"]').type('10');
    cy.get('input[name="max"]').type('2');
    cy.get('input[name="max"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('button#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        selectNumber: '2',
        firstName: 'bill',
        lastName: 'luo',
        min: '10',
        max: '2',
      }),
    );

    cy.get('select[name="selectNumber"]').select('3');
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['selectNumber', 'firstName', 'lastName', 'min', 'max'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );

    cy.get('input[name="notRequired"]').type('test');
    cy.get('input[name="notRequired"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [
          'selectNumber',
          'firstName',
          'lastName',
          'min',
          'max',
          'notRequired',
        ],
        isSubmitted: true,
        submitCount: 2,
        touched: [
          'selectNumber',
          'firstName',
          'lastName',
          'min',
          'max',
          'notRequired',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );

    cy.get('button#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        selectNumber: '3',
        firstName: 'bill',
        lastName: 'luo',
        min: '10',
        max: '2',
        notRequired: 'test',
      }),
    );

    cy.get('#renderCount').contains('24');
  });
});


================================================
File: /cypress/e2e/useFieldArray.cy.ts
================================================
describe('useFieldArray', () => {
  it('should behaviour correctly without defaultValues', () => {
    cy.visit('http://localhost:3000/useFieldArray/normal');

    cy.get('#append').click();
    cy.get('ul > li').its('length').should('equal', 1);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '2' }],
      }),
    );

    cy.get('#prepend').click();
    cy.get('ul > li').its('length').should('equal', 2);

    cy.get('ul > li').eq(0).get('input').should('have.value', '5');

    cy.get('#append').click();
    cy.get('ul > li').its('length').should('equal', 3);

    cy.get('ul > li').eq(2).find('input').should('have.value', '6');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '5' }, { name: '2' }, { name: '6' }],
      }),
    );

    cy.get('#swap').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', '6');
    cy.get('ul > li').eq(2).find('input').should('have.value', '2');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '5' }, { name: '6' }, { name: '2' }],
      }),
    );

    cy.get('#move').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', '2');
    cy.get('ul > li').eq(1).find('input').should('have.value', '5');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '2' }, { name: '5' }, { name: '6' }],
      }),
    );

    cy.get('#insert').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', '13');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '2' }, { name: '13' }, { name: '5' }, { name: '6' }],
      }),
    );

    cy.get('#remove').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', '2');
    cy.get('ul > li').eq(1).find('input').should('have.value', '5');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '2' }, { name: '5' }, { name: '6' }],
      }),
    );

    cy.get('#delete1').click();

    cy.get('ul > li').its('length').should('equal', 2);

    cy.get('ul > li').eq(0).find('input').should('have.value', '2');
    cy.get('ul > li').eq(1).find('input').should('have.value', '6');

    cy.get('#delete1').click();

    cy.get('ul > li').its('length').should('equal', 1);

    cy.get('ul > li').eq(0).find('input').should('have.value', '2');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '2' }],
      }),
    );

    cy.get('#update').click();

    cy.get('ul > li').eq(0).find('input').should('have.value', 'changed');

    cy.get('#removeAll').click();
    cy.get('ul > li').should('have.length', 0);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [],
      }),
    );

    cy.get('#append').click();
    cy.get('#append').click();
    cy.get('#append').click();

    cy.get('#removeAsync').click();
    cy.get('#removeAsync').click();

    cy.get('input').should('have.length', 1);

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: '26' }],
      }),
    );

    cy.get('#renderCount').contains('33');
  });

  it('should behaviour correctly with defaultValue', () => {
    cy.visit('http://localhost:3000/useFieldArray/default');

    cy.get('ul > li').its('length').should('equal', 3);

    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');

    cy.get('ul > li').eq(1).find('input').should('have.value', 'test1');

    cy.get('ul > li').eq(2).find('input').should('have.value', 'test2');

    cy.get('#append').click();

    cy.get('ul > li').eq(3).find('input').should('have.value', '2');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#prepend').click();
    cy.get('ul > li').its('length').should('equal', 5);

    cy.get('ul > li').eq(0).get('input').should('have.value', '5');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '5' },
          { name: 'test' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#swap').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', 'test1');
    cy.get('ul > li').eq(2).find('input').should('have.value', 'test');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '5' },
          { name: 'test1' },
          { name: 'test' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#move').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '5');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '5' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#insert').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', '12');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '12' },
          { name: '5' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#remove').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '5');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '5' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#delete2').click();

    cy.get('ul > li').its('length').should('equal', 4);

    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '5');
    cy.get('ul > li').eq(2).find('input').should('have.value', 'test2');
    cy.get('ul > li').eq(3).find('input').should('have.value', '2');

    cy.get('#delete3').click();

    cy.get('ul > li').its('length').should('equal', 3);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: 'test' }, { name: '5' }, { name: 'test2' }],
      }),
    );

    cy.get('#removeAll').click();
    cy.get('ul > li').should('have.length', 0);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [],
      }),
    );

    cy.get('#append').click();

    cy.get('ul > li').eq(0).find('input').should('have.value', '24');

    cy.get('#prepend').click();

    cy.get('ul > li').eq(0).find('input').should('have.value', '25');

    cy.get('#renderCount').contains('26');
  });

  it('should behaviour correctly with defaultValue and without auto focus', () => {
    cy.visit('http://localhost:3000/useFieldArray/defaultAndWithoutFocus');

    cy.get('ul > li').its('length').should('equal', 3);

    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');

    cy.get('ul > li').eq(1).find('input').should('have.value', 'test1');

    cy.get('ul > li').eq(2).find('input').should('have.value', 'test2');

    cy.get('#append').click();

    cy.get('ul > li').eq(3).find('input').should('have.value', '2');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#prepend').click();
    cy.get('ul > li').its('length').should('equal', 5);

    cy.get('ul > li').eq(0).get('input').should('have.value', '4');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '4' },
          { name: 'test' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#swap').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', 'test1');
    cy.get('ul > li').eq(2).find('input').should('have.value', 'test');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '4' },
          { name: 'test1' },
          { name: 'test' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#move').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '4');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '4' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#insert').click();
    cy.get('ul > li').eq(1).find('input').should('have.value', '10');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '10' },
          { name: '4' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#remove').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '4');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: 'test' },
          { name: '4' },
          { name: 'test1' },
          { name: 'test2' },
          { name: '2' },
        ],
      }),
    );

    cy.get('#delete2').click();

    cy.get('ul > li').its('length').should('equal', 4);

    cy.get('ul > li').eq(0).find('input').should('have.value', 'test');
    cy.get('ul > li').eq(1).find('input').should('have.value', '4');
    cy.get('ul > li').eq(2).find('input').should('have.value', 'test2');
    cy.get('ul > li').eq(3).find('input').should('have.value', '2');

    cy.get('#delete3').click();

    cy.get('ul > li').its('length').should('equal', 3);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: 'test' }, { name: '4' }, { name: 'test2' }],
      }),
    );

    cy.get('#removeAll').click();
    cy.get('ul > li').should('have.length', 0);

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [],
      }),
    );

    cy.get('#append').click();

    cy.get('ul > li').eq(0).find('input').should('have.value', '21');

    cy.get('#prepend').click();

    cy.get('ul > li').eq(0).find('input').should('have.value', '22');

    cy.get('#renderCount').contains('23');
  });

  it('should replace fields with new values', () => {
    cy.visit('http://localhost:3000/useFieldArray/normal');
    cy.get('#replace').click();
    cy.get('ul > li').eq(0).find('input').should('have.value', '2. lorem');
    cy.get('ul > li').eq(1).find('input').should('have.value', '2. ipsum');
    cy.get('ul > li').eq(2).find('input').should('have.value', '2. dolor');
    cy.get('ul > li').eq(3).find('input').should('have.value', '2. sit amet');

    cy.get('#submit').click();
    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '2. lorem' },
          { name: '2. ipsum' },
          { name: '2. dolor' },
          { name: '2. sit amet' },
        ],
      }),
    );
  });

  it('should display the correct dirty value with default value', () => {
    cy.visit('http://localhost:3000/useFieldArray/default');
    cy.get('#dirty').contains('no');
    cy.get('#update').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: false }, { name: false }],
      }),
    );
    cy.get('#dirty').contains('yes');
    cy.get('#updateRevert').click();
    cy.get('#dirty').contains('no');
    cy.get('#append').click();
    cy.get('#field1').type('test');
    cy.get('#prepend').click();
    cy.get('#delete2').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: false }, { name: true }],
      }),
    );
    cy.get('#delete2').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: true }],
      }),
    );
    cy.get('#delete1').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: true }],
      }),
    );
    cy.get('#delete1').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: true }],
      }),
    );
    cy.get('#delete0').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: true }],
      }),
    );
    cy.get('#dirty').contains('yes');
    cy.get('#renderCount').contains('18');
  });

  it('should display the correct dirty value without default value', () => {
    cy.visit('http://localhost:3000/useFieldArray/normal');
    cy.get('#dirty').contains('no');
    cy.get('#append').click();
    cy.get('#dirty').contains('yes');
    cy.get('#field0').focus();
    cy.get('#field0').blur();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }],
      }),
    );
    cy.get('#dirty').contains('yes');
    cy.get('#field0').type('test');
    cy.get('#field0').blur();
    cy.get('#dirty').contains('yes');
    cy.get('#prepend').click();
    cy.get('#prepend').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }, { name: true }],
      }),
    );
    cy.get('#delete0').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }, { name: true }],
      }),
    );

    cy.get('#delete1').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true }],
      }),
    );

    cy.get('#delete0').click();
    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({ data: [] }),
    );

    cy.get('#dirty').contains('yes');
  });

  it('should display the correct dirty value with default value', () => {
    cy.visit('http://localhost:3000/useFieldArray/default');
    cy.get('#dirty').contains('no');
    cy.get('#field0').focus();
    cy.get('#field0').blur();
    cy.get('#dirty').contains('no');
    cy.get('#field0').type('test');
    cy.get('#dirty').contains('yes');
    cy.get('#field0').blur();
    cy.get('#dirty').contains('yes');
    cy.get('#field0').focus();
    cy.get('#field0').blur();
    cy.get('#dirty').contains('yes');
    cy.get('#field0').clear();
    cy.get('#field0').type('test');
    cy.get('#dirty').contains('no');
    cy.get('#delete1').click();
    cy.get('#dirty').contains('yes');
    cy.get('#append').click();
    cy.get('#field0').clear().type('test');
    cy.get('#field1').clear().type('test1');
    cy.get('#field2').clear().type('test2');
    cy.get('#dirty').contains('no');
  });

  it('should display the correct dirty value with async default value', () => {
    cy.visit('http://localhost:3000/useFieldArray/asyncReset');
    cy.get('#dirty').contains('no');
    cy.get('#field0').focus();
    cy.get('#field0').blur();
    cy.get('#dirty').contains('no');
    cy.get('#field0').type('test');
    cy.get('#dirty').contains('yes');
    cy.get('#field0').blur();
    cy.get('#dirty').contains('yes');
    cy.get('#field0').focus();
    cy.get('#field0').blur();
    cy.get('#dirty').contains('yes');
    cy.get('#field0').clear();
    cy.get('#field0').type('test');
    cy.get('#dirty').contains('no');
    cy.get('#delete1').click();
    cy.get('#dirty').contains('yes');
    cy.get('#append').click();
    cy.get('#field0').clear().type('test');
    cy.get('#field1').clear().type('test1');
    cy.get('#field2').clear().type('test2');
    cy.get('#dirty').contains('no');
  });

  it('should display correct error with the inputs', () => {
    cy.visit('http://localhost:3000/useFieldArray/default');
    cy.get('#prepend').click();
    cy.get('#field1').clear();
    cy.get('#field2').clear();
    cy.get('#field3').clear();
    cy.get('#append').click();
    cy.get('#submit').click();
    cy.get('#error1').contains('This is required');
    cy.get('#error2').contains('This is required');
    cy.get('#error3').contains('This is required');
    cy.get('#field1').type('test');
    cy.get('#error1').should('not.exist');
    cy.get('#error2').contains('This is required');
    cy.get('#error3').contains('This is required');
    cy.get('#move').click();
    cy.get('#error0').contains('This is required');
    cy.get('#error2').should('not.exist');
    cy.get('#prepend').click();
    cy.get('#error0').should('not.exist');
    cy.get('#error1').contains('This is required');
  });

  it('should return correct touched values', () => {
    cy.visit('http://localhost:3000/useFieldArray/default');
    cy.get('#field0').type('1');
    cy.get('#field1').type('1');
    cy.get('#field2').type('1');
    cy.get('#touched').contains('[{"name":true},{"name":true}]');
    cy.get('#append').click();
    cy.get('#prepend').click();
    cy.get('#touched').contains(
      '[null,{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
    cy.get('#insert').click();
    cy.get('#touched').contains(
      '[{"name":true},null,{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
    cy.get('#swap').click();
    cy.get('#touched').contains(
      '[{"name":true},{"name":true},{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
    cy.get('#move').click();
    cy.get('#touched').contains(
      '[{"name":true},{"name":true},{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
    cy.get('#insert').click();
    cy.get('#touched').contains(
      '[{"name":true},null,{"name":true},{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
    cy.get('#delete4').click();
    cy.get('#touched').contains(
      '[{"name":true},{"name":true},{"name":true},{"name":true},{"name":true},{"name":true}]',
    );
  });

  it('should return correct touched values without autoFocus', () => {
    cy.visit('http://localhost:3000/useFieldArray/defaultAndWithoutFocus');
    cy.get('#field0').type('1');
    cy.get('#field1').type('1');
    cy.get('#field2').type('1');
    cy.get('#touched').contains('[{"name":true},{"name":true}]');
    cy.get('#append').click();
    cy.get('#prepend').click();
    cy.get('#touched').contains(
      '[null,{"name":true},{"name":true},{"name":true},null]',
    );
    cy.get('#insert').click();
    cy.get('#touched').contains(
      '[null,null,{"name":true},{"name":true},{"name":true},null]',
    );
    cy.get('#swap').click();
    cy.get('#touched').contains(
      '[null,{"name":true},null,{"name":true},{"name":true},null]',
    );
    cy.get('#move').click();
    cy.get('#touched').contains(
      '[null,null,{"name":true},{"name":true},{"name":true},null]',
    );
    cy.get('#insert').click();
    cy.get('#touched').contains(
      '[null,null,null,{"name":true},{"name":true},{"name":true},null]',
    );
    cy.get('#delete4').click();
    cy.get('#touched').contains(
      '[null,null,null,{"name":true},{"name":true},null]',
    );
  });

  it('should return correct isValid formState', () => {
    cy.visit('http://localhost:3000/useFieldArray/formState');
    cy.get('#isValid').get('#isValid').contains('yes');
    cy.get('#append').click();
    cy.get('#append').click();
    cy.get('#append').click();

    cy.get('#isValid').get('#isValid').contains('yes');

    cy.get('#field0').clear();

    cy.get('#isValid').get('#isValid').contains('no');

    cy.get('#delete0').click();
    cy.get('#field1').type('1');

    cy.get('#isValid').get('#isValid').contains('yes');

    cy.get('#field0').clear();

    cy.get('#isValid').get('#isValid').contains('no');

    // introduced by react 19 with race condition with blur and useEffect action
    cy.get('#field0').blur();

    cy.get('#delete0').click();

    cy.get('#isValid').get('#isValid').contains('yes');

    cy.get('#append').click();
    cy.get('#field0').clear();

    cy.get('#isValid').get('#isValid').contains('no');

    cy.get('#delete0').click();

    cy.get('#isValid').get('#isValid').contains('yes');

    cy.get('#append').click();
    cy.get('#append').click();

    cy.get('#field1').clear();
    cy.get('#field2').clear();

    cy.get('#isValid').get('#isValid').contains('no');

    cy.get('#delete1').click();
    cy.get('#delete1').click();

    cy.get('#isValid').get('#isValid').contains('yes');
  });
});


================================================
File: /cypress/e2e/setValueWithSchema.cy.ts
================================================
describe('form setValue with schema', () => {
  it('should set input value, trigger validation and clear all errors', () => {
    cy.visit('http://localhost:3000/setValueWithSchema');

    cy.get('input[name="firstName"]').type('a');
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('p').should('have.length', 1);
    cy.get('input[name="firstName"]').type('asdasdasdasd');

    cy.get('input[name="lastName"]').type('a');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('p').should('have.length', 1);
    cy.get('input[name="lastName"]').type('asdasdasdasd');

    cy.get('input[name="age"]').type('a2323');

    cy.get('#submit').click();
    cy.get('p').should('have.length', 1);
    cy.get('input[name="requiredField"] + p').contains('RequiredField error');

    cy.get('#setValue').click();
    cy.get('input[name="requiredField"]').should('have.value', 'test123456789');
    cy.get('p').should('have.length', 0);

    cy.get('#renderCount').contains('34');
  });
});


================================================
File: /cypress/e2e/setFocus.cy.ts
================================================
describe('form setFocus', () => {
  it('should focus input', () => {
    cy.visit('http://localhost:3000/setFocus');
    cy.get('button:contains("Focus Input")').click();
    cy.get('input[name="focusInput"]').should('be.focused');
  });

  it('should select input content', () => {
    cy.visit('http://localhost:3000/setFocus');
    cy.get('button:contains("Select Input Content")').click();
    cy.get('input[name="selectInputContent"]')
      .type('New Value')
      .should('have.value', 'New Value');
  });

  it('should focus textarea', () => {
    cy.visit('http://localhost:3000/setFocus');
    cy.get('button:contains("Focus Textarea")').click();
    cy.get('textarea[name="focusTextarea"]').should('be.focused');
  });

  it('should select input content', () => {
    cy.visit('http://localhost:3000/setFocus');
    cy.get('button:contains("Select Textarea Content")').click();
    cy.get('textarea[name="selectTextareaContent"]')
      .type('New Value')
      .should('have.value', 'New Value');
  });
});


================================================
File: /cypress/e2e/formStateWithSchema.cy.ts
================================================
describe('form state with schema validation', () => {
  it('should return correct form state with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formStateWithSchema/onSubmit');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('select[name="select"]').select('1');
    cy.get('#renderCount').contains('14');
  });

  it('should return correct form state with onChange mode', () => {
    cy.visit('http://localhost:3000/formState/onChange');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('13');
  });

  it('should return correct form state with onBlur mode', () => {
    cy.visit('http://localhost:3000/formState/onBlur');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('15');
  });

  it('should reset dirty value when inputs reset back to default with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formState/onSubmit');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('select[name="select"]').select('test1');
    cy.get('select[name="select"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['select'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('select[name="select"]').select('');
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="checkbox"]').click();
    cy.get('input[name="checkbox"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['checkbox'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select', 'checkbox'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('input[name="checkbox"]').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select', 'checkbox'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="checkbox-checked"]').click();
    cy.get('input[name="checkbox-checked"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['checkbox-checked'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('input[name="checkbox-checked"]').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
        ],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="radio"]').click();
    cy.get('input[name="radio"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['radio'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
          'radio',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('select[name="select"]').select('');
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['radio'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
          'radio',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('20');
  });

  it('should reset dirty value when inputs reset back to default with onBlur mode', () => {
    cy.visit('http://localhost:3000/formState/onBlur');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('9');
  });

  it('should reset dirty value when inputs reset back to default with onChange mode', () => {
    cy.visit('http://localhost:3000/formState/onChange');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('#resetForm').click();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('13');
  });
});


================================================
File: /cypress/e2e/useFieldArrayNested.cy.ts
================================================
describe('useFieldArrayNested', () => {
  it('should work correctly with nested field array', () => {
    cy.visit('http://localhost:3000/useFieldArrayNested');

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('input[name="test.0.keyValue.0.name"]').should(
      'have.value',
      'insert',
    );
    cy.get('input[name="test.0.keyValue.1.name"]').should(
      'have.value',
      'prepend',
    );
    cy.get('input[name="test.0.keyValue.2.name"]').should('have.value', '1a');
    cy.get('input[name="test.0.keyValue.3.name"]').should('have.value', '1c');
    cy.get('input[name="test.0.keyValue.4.name"]').should(
      'have.value',
      'append',
    );

    cy.get(`#nest-remove-0`).click();
    cy.get('input[name="test.0.keyValue.2.name"]').should('have.value', '1c');
    cy.get('input[name="test.0.keyValue.3.name"]').should(
      'have.value',
      'append',
    );

    cy.get('#dirty-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: false,
            lastName: false,
            keyValue: [
              { name: true },
              { name: true },
              { name: true },
              { name: true },
            ],
          },
        ],
      }),
    );

    cy.get('#touched-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [{ keyValue: [{ name: true }, null, null, { name: true }] }],
      }),
    );

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: 'Bill',
            lastName: 'Luo',
            keyValue: [
              { name: 'insert' },
              { name: '1a' },
              { name: '1c' },
              { name: 'append' },
            ],
          },
        ],
      }),
    );

    cy.get('#prepend').click();

    cy.get('#dirty-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            keyValue: [{ name: true }, { name: true }],
            firstName: true,
            lastName: true,
          },
          {
            firstName: true,
            lastName: true,
            keyValue: [
              { name: true },
              { name: true },
              { name: true },
              { name: true },
            ],
          },
        ],
      }),
    );

    cy.get('#touched-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          null,
          { keyValue: [{ name: true }, null, null, { name: true }] },
        ],
      }),
    );

    cy.get('#append').click();
    cy.get('#swap').click();
    cy.get('#insert').click();

    cy.get('#touched-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          { firstName: true },
          null,
          { firstName: true },
          { keyValue: [{ name: true }, null, null, { name: true }] },
        ],
      }),
    );

    cy.get('#dirty-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: true,
            keyValue: [{ name: true }, { name: true }],
            lastName: true,
          },
          { firstName: true },
          { firstName: true, keyValue: [] },
          {
            firstName: true,
            lastName: true,
            keyValue: [
              { name: true },
              { name: true },
              { name: true },
              { name: true },
            ],
          },
        ],
      }),
    );

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          { firstName: 'prepend', keyValue: [] },
          { firstName: 'insert', keyValue: [] },
          { firstName: 'append', keyValue: [] },
          {
            firstName: 'Bill',
            keyValue: [
              { name: 'insert' },
              { name: '1a' },
              { name: '1c' },
              { name: 'append' },
            ],
            lastName: 'Luo',
          },
        ],
      }),
    );

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('input').its('length').should('eq', 11);

    cy.get('#nest-remove-3').click();
    cy.get('#nest-remove-3').click();

    cy.get('input[name="test.3.keyValue.0.name"]').should(
      'has.value',
      'insert',
    );
    cy.get('input[name="test.3.keyValue.1.name"]').should(
      'has.value',
      'append',
    );

    cy.get('#dirty-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: true,
            keyValue: [{ name: true }, { name: true }, { name: true }],
            lastName: true,
          },
          { firstName: true, keyValue: [] },
          { firstName: true, keyValue: [] },
          {
            firstName: true,
            lastName: true,
            keyValue: [{ name: true }, { name: true }],
          },
        ],
      }),
    );

    cy.get('#nest-update-0').click();

    cy.get('input[name="test.0.keyValue.0.name"]').should(
      'have.value',
      'update',
    );

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: 'prepend',
            keyValue: [
              { name: 'update' },
              { name: 'prepend' },
              { name: 'append' },
            ],
          },
          { firstName: 'insert', keyValue: [] },
          { firstName: 'append', keyValue: [] },
          {
            firstName: 'Bill',
            keyValue: [{ name: 'insert' }, { name: 'append' }],
            lastName: 'Luo',
          },
        ],
      }),
    );

    cy.get('#nest-remove-all-3').click();
    cy.get('#nest-remove-all-2').click();
    cy.get('#nest-remove-all-1').click();
    cy.get('#nest-remove-all-0').click();

    cy.get('#touched-nested-2').contains(
      '{"test":[{"firstName":true,"keyValue":[]},{"firstName":true},{"firstName":true},{"keyValue":[]}]}',
    );

    cy.get('#dirty-nested-2').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: true,
            keyValue: [{ name: true }, { name: true }],
            lastName: true,
          },
          { firstName: true, keyValue: [] },
          { firstName: true, keyValue: [] },
          { firstName: true, lastName: true, keyValue: [] },
        ],
      }),
    );

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          { firstName: 'prepend', keyValue: [] },
          { firstName: 'insert', keyValue: [] },
          { firstName: 'append', keyValue: [] },
          { firstName: 'Bill', keyValue: [], lastName: 'Luo' },
        ],
      }),
    );

    cy.get('#remove').click();
    cy.get('#remove').click();
    cy.get('#remove').click();

    cy.get('#dirty-nested-0').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        test: [
          {
            firstName: true,
            keyValue: [{ name: true }, { name: true }],
            lastName: true,
          },
        ],
      }),
    );

    cy.get('#submit').click();
    cy.get('#result').contains(
      '{"test":[{"firstName":"prepend","keyValue":[]}]}',
    );

    cy.get('#update').click();

    cy.get('input[name="test.0.firstName"]').should(
      'have.value',
      'updateFirstName',
    );
    cy.get('input[name="test.0.keyValue.0.name"]').should(
      'have.value',
      'updateFirstName1',
    );
    cy.get('input[name="test.0.keyValue.1.name"]').should(
      'have.value',
      'updateFirstName2',
    );

    cy.get('#removeAll').click();

    cy.get('#dirty-nested-0').should('not.exist');

    cy.get('#touched-nested-0').should('not.exist');

    cy.get('#submit').click();
    cy.get('#result').contains('{"test":[]}');

    cy.get('#count').contains('16');
  });
});


================================================
File: /cypress/e2e/validateFieldCriteria.cy.ts
================================================
describe('validate field criteria', () => {
  it('should validate the form, show all errors and clear all', () => {
    cy.visit('http://localhost:3000/validate-field-criteria');
    cy.get('button#submit').click();
    cy.get('input[name="firstName"] + p').contains('firstName required');
    cy.get('input[name="firstName"]').type('te');
    cy.get('input[name="firstName"] + p').contains('firstName minLength');
    cy.get('input[name="firstName"]').type('testtesttest');

    cy.get('input[name="min"] + p').contains('min required');
    cy.get('input[name="min"]').type('2');
    cy.get('input[name="min"] + p').contains('min min');
    cy.get('input[name="min"]').type('32');
    cy.get('input[name="min"] + p').contains('min max');
    cy.get('input[name="min"]').clear();
    cy.get('input[name="min"]').type('10');

    cy.get('input[name="minDate"] + p').contains('minDate required');
    cy.get('input[name="minDate"]').type('2019-07-01');
    cy.get('input[name="minDate"] + p').contains('minDate min');
    cy.get('input[name="minDate"]').type('2019-08-01');

    cy.get('input[name="maxDate"] + p').contains('maxDate required');
    cy.get('input[name="maxDate"]').type('2019-09-01');
    cy.get('input[name="maxDate"] + p').contains('maxDate max');
    cy.get('input[name="maxDate"]').type('2019-08-01');

    cy.get('input[name="minLength"] + p').contains('minLength required');
    cy.get('input[name="minLength"]').type('1');
    cy.get('input[name="minLength"] + p').contains('minLength minLength');
    cy.get('input[name="minLength"]').type('12');

    cy.get('select[name="selectNumber"] + p').contains('selectNumber required');
    cy.get('select[name="selectNumber"]').select('12');

    cy.get('input[name="pattern"] + p').contains('pattern required');
    cy.get('input[name="pattern"]').type('t');
    cy.get('input[name="pattern"] + p').contains('pattern pattern');
    cy.get('input[name="pattern"] + p + p').contains('pattern minLength');
    cy.get('input[name="pattern"]').clear();
    cy.get('input[name="pattern"]').type('12345');

    cy.get('select[name="multiple"] + p').contains('multiple required');
    cy.get('select[name="multiple"] + p + p').contains('multiple validate');
    cy.get('select[name="multiple"]').select('optionA');
    cy.get('select[name="multiple"]').select('optionB');

    cy.get('input[name="validate"] + p').contains('validate test');
    cy.get('input[name="validate"] + p + p').contains('validate test1');
    cy.get('input[name="validate"] + p + p + p').contains('validate test2');
    cy.get('input[name="validate"]').type('test');

    cy.get('p').should('have.length', 0);

    cy.get('#trigger').click();
    cy.get('p').should('have.length', 2);
    cy.get('b').should('have.length', 2);

    cy.get('#clear').click();
    cy.get('p').should('have.length', 0);
    cy.get('b').should('have.length', 0);

    cy.get('#renderCount').contains('27');
  });
});


================================================
File: /cypress/e2e/delayError.cy.ts
================================================
describe('delayError', () => {
  it('should delay from errors appear', () => {
    cy.visit('http://localhost:3000/delayError');

    const firstInput = () => cy.get('input[name="first"]');
    const firstInputError = () => cy.get('input[name="first"] + p');
    const lastInput = () => cy.get('input[name="last"]');
    const lastInputError = () => cy.get('input[name="last"] + p');

    firstInput().type('123');
    cy.wait(100);
    firstInputError().contains('First too long.');

    lastInput().type('123567');
    cy.wait(100);
    lastInputError().contains('Last too long.');

    lastInput().blur();
    cy.get('button').click();

    firstInput().type('123');
    lastInput().type('123567');

    firstInputError().contains('First too long.');
    lastInputError().contains('Last too long.');

    firstInput().clear().type('1');
    lastInput().clear().type('12');

    lastInput().blur();

    cy.get('p').should('have.length', 0);

    cy.get('button').click();

    firstInput().type('aa');
    lastInput().type('a');

    firstInputError().contains('First too long.');
    lastInputError().contains('Last too long.');

    firstInput().clear().type('1');
    lastInput().clear().type('12');

    lastInput().blur();

    cy.get('p').should('have.length', 0);
  });
});


================================================
File: /cypress/e2e/basicSchemaValidation.cy.ts
================================================
describe('basicSchemaValidation form validation', () => {
  it('should validate the form with onSubmit mode', () => {
    cy.visit('http://localhost:3000/basic-schema-validation/onSubmit');
    cy.get('button').click();

    cy.focused().should('have.attr', 'name', 'firstName');

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('input[name="minRequiredLength"] + p').contains(
      'minRequiredLength error',
    );
    cy.get('input[name="radio"] + p').contains('radio error');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').blur();
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('24');
  });

  it('should validate the form with onBlur mode', () => {
    cy.visit('http://localhost:3000/basic-schema-validation/onBlur');

    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').focus();
    cy.get('select[name="selectNumber"]').blur();
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');
    cy.get('input[name="minLength"]').blur();

    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').first().blur();
    cy.get('input[name="radio"] + p').contains('radio error');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('20');
  });

  it('should validate the form with onChange mode', () => {
    cy.visit('http://localhost:3000/basic-schema-validation/onChange');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"]').clear();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('select[name="selectNumber"]').select('');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');

    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('26');
  });
});


================================================
File: /cypress/e2e/watchUseFieldArrayNested.cy.ts
================================================
describe('watchUseFieldArrayNested', () => {
  it('should watch the correct nested field array', () => {
    cy.visit('http://localhost:3000/watchUseFieldArrayNested');

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [{ name: '1a' }, { name: '1c' }],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get('#nest-update-0').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'billUpdate' },
            { name: 'prepend' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get(`#nest-remove-0`).click();

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'billUpdate' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get('#prepend').click();
    cy.get('#append').click();
    cy.get('#swap').click();
    cy.get('#insert').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'prepend', keyValue: [] },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [
            { name: 'billUpdate' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
        },
      ]),
    );

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'append' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [
            { name: 'billUpdate' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
        },
      ]),
    );

    cy.get('#nest-remove-3').click();
    cy.get('#nest-remove-3').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'append' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [{ name: 'billUpdate' }, { name: 'append' }],
        },
      ]),
    );

    cy.get('#nest-remove-all-3').click();
    cy.get('#nest-remove-all-2').click();
    cy.get('#nest-remove-all-1').click();
    cy.get('#nest-remove-all-0').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'prepend', keyValue: [] },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        { firstName: 'Bill', lastName: 'Luo', keyValue: [] },
      ]),
    );

    cy.get('#update').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'BillUpdate', keyValue: [] },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        { firstName: 'Bill', lastName: 'Luo', keyValue: [] },
      ]),
    );

    cy.get('#remove').click();
    cy.get('#remove').click();
    cy.get('#remove').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'BillUpdate', keyValue: [] },
      ]),
    );

    cy.get('#count').contains('36');

    cy.get('#removeAll').click();

    cy.get('#result').should('have.value', '');
  });
});


================================================
File: /cypress/e2e/formStateWithNestedFields.cy.ts
================================================
describe('form state with nested fields', () => {
  it('should return correct form state with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onSubmit');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="left.test2"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test2"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('15');
  });

  it('should return correct form state with onChange mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onChange');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="left.test2"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test2"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('13');
  });

  it('should return correct form state with onBlur mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onBlur');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="left.test2"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test2"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('15');
  });

  it('should reset dirty value when inputs reset back to default with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onSubmit');
    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="left.test1"]').clear();
    cy.get('input[name="left.test2"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('#renderCount').contains('9');
  });

  it('should reset dirty value when inputs reset back to default with onBlur mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onBlur');
    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="left.test1"]').clear();
    cy.get('input[name="left.test2"]').clear();
    cy.get('input[name="left.test2"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,

        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('9');
  });

  it('should reset dirty value when inputs reset back to default with onChange mode', () => {
    cy.visit('http://localhost:3000/formStateWithNestedFields/onChange');
    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        dirty: ['left.test1', 'left.test2'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('#resetForm').click();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="left.test1"]').type('test');
    cy.get('input[name="left.test1"]').blur();
    cy.get('input[name="left.test2"]').type('test');
    cy.get('input[name="left.test2"]').blur();

    cy.get('input[name="left.test1"]').clear();
    cy.get('input[name="left.test2"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['left.test1', 'left.test2'],
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('#renderCount').contains('13');
  });
});


================================================
File: /cypress/e2e/autoUnregister.cy.ts
================================================
describe('autoUnregister', () => {
  it('should keep all inputs data when inputs get unmounted', () => {
    cy.visit('http://localhost:3000/autoUnregister');
    cy.get('input[name="test"]').type('test');
    cy.get('input[name="test1"]').type('test1');
    cy.get('input[name="test2"]').check();
    cy.get('input[name="test3"]').check();
    cy.get('select[name="test4"]').select('Bill');
    cy.get('#input-ReactSelect > div').click();
    cy.get('#input-ReactSelect > div > div').eq(1).click();

    cy.get('button').click();
    cy.get('button').click();

    cy.get('input[name="test"]').should('has.value', 'test');
    cy.get('input[name="test1"]').should('has.value', 'test1');
    cy.get('input[name="test2"]').should('be.checked');
    cy.get('input[name="test3"]').should('be.checked');
    cy.get('select[name="test4"]').should('has.value', 'bill');
    cy.get('#input-ReactSelect > div > div > div > div').contains('Strawberry');
  });
});


================================================
File: /cypress/e2e/reValidateMode.cy.ts
================================================
describe('re-validate mode', () => {
  it('should re-validate the form only onSubmit with mode onSubmit and reValidateMode onSubmit', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onSubmit/onSubmit');

    cy.get('button#submit').click();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="lastName"]').type('luo12');

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('button#submit').click();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('3');
  });

  it('should re-validate the form only onBlur with mode onSubmit and reValidateMode onBlur', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onSubmit/onBlur');
    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();

    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').blur();
    cy.get('p').should('have.length', 0);

    cy.get('button#submit').click();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('luo12');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').blur();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('4');
  });

  it('should re-validate the form only onSubmit with mode onBlur and reValidateMode onSubmit', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onBlur/onSubmit');

    cy.get('button#submit').click();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('luo12');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').blur();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('button#submit').click();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('3');
  });

  it('should re-validate the form only onSubmit with mode onChange and reValidateMode onSubmit', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onChange/onSubmit');

    cy.get('button#submit').click();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"]').type('luo12');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('button#submit').click();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('3');
  });

  it('should re-validate the form onBlur only with mode onBlur and reValidateMode onBlur', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onBlur/onBlur');

    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('luo12');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').blur();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('5');
  });

  it('should re-validate the form onChange with mode onBlur and reValidateMode onChange', () => {
    cy.visit('http://localhost:3000/re-validate-mode/onBlur/onChange');

    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();

    cy.get('button#submit').click();

    cy.get('input[name="firstName"]').type('luo123456');
    cy.get('input[name="lastName"]').type('luo12');

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('6');
  });
});


================================================
File: /cypress/e2e/reset.cy.ts
================================================
describe('form reset', () => {
  it('should be able to re-populate the form while reset', () => {
    cy.visit('http://localhost:3000/reset');

    cy.get('input[name="firstName"]').type('0 wrong');
    cy.get('input[name="array.1"]').type('1 wrong');
    cy.get('input[name="objectData.test"]').type('2 wrong');
    cy.get('input[name="lastName"]').type('lastName');
    cy.get('input[name="deepNest.level1.level2.data"]').type('whatever');

    cy.get('button').click();

    cy.get('input[name="firstName"]').should('have.value', 'bill');
    cy.get('input[name="lastName"]').should('have.value', 'luo');
    cy.get('input[name="array.1"]').should('have.value', 'test');
    cy.get('input[name="objectData.test"]').should('have.value', 'data');
    cy.get('input[name="deepNest.level1.level2.data"]').should(
      'have.value',
      'hey',
    );
  });

  it('should be able to re-populate the form while reset keeping dirty values', () => {
    cy.visit('http://localhost:3000/resetKeepDirty');
    cy.get('input[name="firstName"]').should('have.value', '');
    cy.get('input[name="users"]').should('have.value', 'users#0');
    cy.get('input[name="objectData.test"]').should('have.value', '');
    cy.get('input[name="lastName"]').should('have.value', '');
    cy.get('input[name="deepNest.level1.level2.data"]').should(
      'have.value',
      '',
    );

    cy.get('button').click({ multiple: true });

    cy.get('input[name="firstName"]').should('have.value', 'bill');
    cy.get('input[name="lastName"]').should('have.value', 'luo');
    cy.get('input[name="users"]').should('have.value', 'users#1');
    cy.get('input[name="objectData.test"]').should('have.value', 'data');
    cy.get('input[name="deepNest.level1.level2.data"]').should(
      'have.value',
      'hey',
    );
  });
});


================================================
File: /cypress/e2e/customSchemaValidation.cy.ts
================================================
describe('customSchemaValidation form validation', () => {
  it('should validate the form with onSubmit mode', () => {
    cy.visit('http://localhost:3000/customSchemaValidation/onSubmit');
    cy.get('button').click();

    cy.focused().should('have.attr', 'name', 'firstName');

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('input[name="minRequiredLength"] + p').contains(
      'minRequiredLength error',
    );
    cy.get('input[name="radio"] + p').contains('radio error');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('2');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('25');
  });

  it('should validate the form with onBlur mode', () => {
    cy.visit('http://localhost:3000/customSchemaValidation/onBlur');

    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').focus();
    cy.get('select[name="selectNumber"]').blur();
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('2');
    cy.get('input[name="minLength"]').blur();

    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').first().blur();
    cy.get('input[name="radio"] + p').contains('radio error');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('18');
  });

  it('should validate the form with onChange mode', () => {
    cy.visit('http://localhost:3000/customSchemaValidation/onChange');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').focus();
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"]').clear();
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('select[name="selectNumber"]').select('');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('2');

    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('22');
  });
});


================================================
File: /cypress/e2e/basic.cy.ts
================================================
describe('basic form validation', () => {
  it('should validate the form and reset the form', () => {
    cy.visit('http://localhost:3000/basic/onSubmit');
    cy.get('button#submit').click();

    cy.focused().should('have.attr', 'name', 'nestItem.nest1');

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="nestItem.nest1"] + p').contains('nest 1 error');
    cy.get('input[name="arrayItem.0.test1"] + p').contains(
      'array item 1 error',
    );
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="multiple"] + p').contains('multiple error');
    cy.get('input[name="minRequiredLength"] + p').contains(
      'minRequiredLength error',
    );
    cy.get('input[name="radio"] + p').contains('radio error');
    cy.get('input[name="checkbox"] + p').contains('checkbox error');
    cy.get('input[name="checkboxArray"] + p').contains('checkboxArray error');
    cy.get('input[name="validate"] + p').contains('validate error');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="firstName"]').type('a');
    cy.get('input[name="arrayItem.0.test1"]').type('ab');
    cy.get('input[name="nestItem.nest1"]').type('ab');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');
    cy.get('input[name="validate"]').type('test');

    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('select[name="multiple"]').select(['optionA']);
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();
    cy.get('input[name="checkboxArray"]').check('3');
    cy.get('select[name="multiple"]').select(['optionA', 'optionB']);

    cy.get('p').should('have.length', 0);

    cy.get('#submit').click();

    cy.get('pre').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        nestItem: { nest1: 'ab' },
        arrayItem: [{ test1: 'ab' }],
        firstName: 'billa',
        lastName: 'luo',
        min: '11',
        max: '19',
        minDate: '2019-08-01',
        maxDate: '2019-08-01',
        minLength: 'bbi',
        minRequiredLength: 'bi',
        selectNumber: '1',
        pattern: 'luo23',
        radio: '1',
        checkbox: true,
        checkboxArray: ['3'],
        multiple: ['optionA', 'optionB'],
        validate: 'test',
      }),
    );
    cy.get('#submit').click();

    cy.get('#resetForm').click();
    cy.get('input[name="firstName"]').should('not.have.value');
    cy.get('input[name="lastName"]').should('not.have.value');
    cy.get('select[name="selectNumber"]').should('have.value', '');
    cy.get('input[name="minRequiredLength"]').should('not.have.value');
    cy.get('input[name="radio"]').should('not.have.value');
    cy.get('input[name="max"]').should('not.have.value');
    cy.get('input[name="min"]').should('not.have.value');
    cy.get('input[name="minLength"]').should('not.have.value');
    cy.get('input[name="checkbox"]').should('not.have.value');
    cy.get('input[name="pattern"]').should('not.have.value');
    cy.get('input[name="minDate"]').should('not.have.value');
    cy.get('input[name="maxDate"]').should('not.have.value');
    cy.get('#renderCount').contains('34');

    cy.get('#on-invalid-called-times').contains('1');
  });

  it('should validate the form with onTouched mode', () => {
    cy.visit('http://localhost:3000/basic/onTouched');
    cy.get('input[name="nestItem.nest1"]').focus();
    cy.get('input[name="nestItem.nest1"]').type('test');
    cy.get('input[name="nestItem.nest1"]').clear();
    cy.get('p').should('have.length', 0);
    cy.get('input[name="nestItem.nest1"]').blur();
    cy.get('input[name="nestItem.nest1"] + p').contains('nest 1 error');

    cy.get('input[name="arrayItem.0.test1"]').focus();
    cy.get('input[name="arrayItem.0.test1"]').blur();
    cy.get('input[name="arrayItem.0.test1"] + p').contains(
      'array item 1 error',
    );

    cy.get('select[name="selectNumber"]').focus();
    cy.get('select[name="selectNumber"]').blur();
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');

    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').first().blur();
    cy.get('input[name="radio"] + p').contains('radio error');
    cy.get('input[name="radio"]').check('1');

    cy.get('input[name="checkbox"]').focus();
    cy.get('input[name="checkbox"]').blur();
    cy.get('input[name="checkbox"] + p').contains('checkbox error');
    cy.get('input[name="checkbox"]').check();
    cy.get('input[name="checkbox"]').blur();

    cy.get('input[name="nestItem.nest1"]').type('test');
    cy.get('input[name="arrayItem.0.test1"]').type('test');

    cy.get('p').should('have.length', 0);

    cy.get('#renderCount').contains('10');
  });

  it('should validate the form with onBlur mode and reset the form', () => {
    cy.visit('http://localhost:3000/basic/onBlur');

    cy.get('input[name="nestItem.nest1"]').focus();
    cy.get('input[name="nestItem.nest1"]').blur();
    cy.get('input[name="nestItem.nest1"] + p').contains('nest 1 error');
    cy.get('input[name="nestItem.nest1"]').type('a');

    cy.get('input[name="arrayItem.0.test1"]').focus();
    cy.get('input[name="arrayItem.0.test1"]').blur();
    cy.get('input[name="arrayItem.0.test1"] + p').contains(
      'array item 1 error',
    );
    cy.get('input[name="arrayItem.0.test1"]').type('a');

    cy.get('input[name="firstName"]').focus();
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="firstName"]').type('bill');

    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"]').blur();
    cy.get('input[name="lastName"] + p').contains('lastName error');

    cy.get('select[name="selectNumber"]').focus();
    cy.get('select[name="selectNumber"]').blur();
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('select[name="selectNumber"]').select('1');

    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');
    cy.get('input[name="minLength"]').blur();
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('select[name="multiple"]').select(['optionA']);
    cy.get('input[name="radio"]').first().focus();
    cy.get('input[name="radio"]').first().blur();
    cy.get('input[name="radio"] + p').contains('radio error');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').focus();
    cy.get('input[name="checkbox"]').blur();
    cy.get('input[name="checkbox"] + p').contains('checkbox error');
    cy.get('input[name="checkbox"]').check();
    cy.get('input[name="checkbox"]').blur();

    cy.get('p').should('have.length', 0);

    cy.get('#resetForm').click();
    cy.get('input[name="firstName"]').should('not.have.value');
    cy.get('input[name="lastName"]').should('not.have.value');
    cy.get('select[name="selectNumber"]').should('have.value', '');
    cy.get('input[name="minRequiredLength"]').should('not.have.value');
    cy.get('input[name="radio"]').should('not.have.value');
    cy.get('input[name="max"]').should('not.have.value');
    cy.get('input[name="min"]').should('not.have.value');
    cy.get('input[name="minLength"]').should('not.have.value');
    cy.get('input[name="checkbox"]').should('not.have.value');
    cy.get('input[name="pattern"]').should('not.have.value');
    cy.get('input[name="minDate"]').should('not.have.value');
    cy.get('input[name="maxDate"]').should('not.have.value');
    cy.get('#renderCount').contains('25');
  });

  it('should validate the form with onChange mode and reset the form', () => {
    cy.visit('http://localhost:3000/basic/onChange');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');

    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('select[name="multiple"]').select(['optionA']);
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);

    cy.get('#resetForm').click();
    cy.get('input[name="firstName"]').should('not.have.value');
    cy.get('input[name="lastName"]').should('not.have.value');
    cy.get('select[name="selectNumber"]').should('have.value', '');
    cy.get('input[name="minRequiredLength"]').should('not.have.value');
    cy.get('input[name="radio"]').should('not.have.value');
    cy.get('input[name="max"]').should('not.have.value');
    cy.get('input[name="min"]').should('not.have.value');
    cy.get('input[name="minLength"]').should('not.have.value');
    cy.get('input[name="checkbox"]').should('not.have.value');
    cy.get('input[name="pattern"]').should('not.have.value');
    cy.get('input[name="minDate"]').should('not.have.value');
    cy.get('input[name="maxDate"]').should('not.have.value');
    cy.get('#renderCount').contains('21');
  });
});


================================================
File: /cypress/e2e/setValue.cy.ts
================================================
describe('form setValue', () => {
  it('should set input value, trigger validation and clear all errors', () => {
    cy.visit('http://localhost:3000/setValue');

    cy.get('input[name="firstName"]').should('have.value', 'wrong');
    cy.get('input[name="age"]').should('have.value', '2');
    cy.get('input[name="array.0"]').should('have.value', 'array.0');
    cy.get('input[name="array.1"]').should('have.value', 'array.1');
    cy.get('input[name="array.2"]').should('have.value', 'array.2');
    cy.get('input[name="object.firstName').should('have.value', 'firstName');
    cy.get('input[name="object.lastName').should('have.value', 'lastName');
    cy.get('input[name="object.middleName').should('have.value', 'middleName');
    cy.get('input[name="radio"]').should('have.checked', true);
    cy.get('input[name="checkboxArray"][value="2"]').should(
      'have.checked',
      true,
    );
    cy.get('input[name="checkboxArray"][value="3"]').should(
      'have.checked',
      true,
    );
    cy.get('select[name="select"]').should('have.value', 'a');
    cy.get('select[name="multiple"]')
      .invoke('val')
      .should('deep.equal', ['a', 'b']);
    cy.get('#trigger').contains('Trigger error');
    cy.get('#lastName').should('not.exist');
    cy.get('#nestedValue').contains('required');

    cy.get('#submit').click();

    cy.get('#lastName').contains('Last name error');

    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="trigger"]').type('trigger');
    cy.get('input[name="nestedValue"]').type('test');

    cy.get('#submit').click();
    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('6');

    cy.get('#setMultipleValues').click();
    cy.get('input[name="array.0"]').should('have.value', 'array[0]1');
    cy.get('input[name="array.1"]').should('have.value', 'array[1]1');
    cy.get('input[name="array.2"]').should('have.value', 'array[2]1');
    cy.get('input[name="object.firstName').should('have.value', 'firstName1');
    cy.get('input[name="object.lastName').should('have.value', 'lastName1');
    cy.get('input[name="object.middleName').should('have.value', 'middleName1');
    cy.get('input[name="nestedValue"]').should('have.value', 'a,b');
    cy.get('#renderCount').contains('6');
  });
});


================================================
File: /cypress/e2e/isValid.cy.ts
================================================
describe('isValid', () => {
  it('should showing valid correctly with build in validation', () => {
    cy.visit('http://localhost:3000/isValid/build-in/defaultValue');
    cy.get('#isValid').contains('false');

    cy.get('input[name="firstName"]').type('test');
    cy.get('#isValid').contains('false');
    cy.get('input[name="lastName"]').type('test');
    cy.get('#isValid').contains('true');
    cy.get('#renderCount').contains('3');
    cy.get('#toggle').click();
    cy.get('#isValid').contains('false');
    cy.get('#toggle').click();
    cy.get('#isValid').contains('true');
  });

  it('should showing valid correctly with build in validation and default values supplied', () => {
    cy.visit('http://localhost:3000/isValid/build-in/defaultValues');
    cy.get('#isValid').contains('true');

    cy.get('input[name="firstName"]').clear();
    cy.get('#isValid').contains('false');
    cy.get('#renderCount').contains('3');
    cy.get('#toggle').click();
    cy.get('#isValid').contains('false');
  });

  it('should showing valid correctly with schema validation', () => {
    cy.visit('http://localhost:3000/isValid/schema/defaultValue');
    cy.get('#isValid').contains('false');

    cy.get('input[name="firstName"]').type('test');
    cy.get('#isValid').contains('false');
    cy.get('input[name="lastName"]').type('test');
    cy.get('#isValid').contains('true');
    cy.get('#renderCount').contains('2');
    cy.get('#toggle').click();
    cy.get('#isValid').contains('false');
    cy.get('#toggle').click();
    cy.get('input[name="firstName"]').type('test');
    cy.get('#isValid').contains('true');
    cy.get('#renderCount').contains('6');
  });

  it('should showing valid correctly with schema validation and default value supplied', () => {
    cy.visit('http://localhost:3000/isValid/schema/defaultValues');
    cy.get('#isValid').contains('true');

    cy.get('input[name="firstName"]').clear();
    cy.get('#isValid').contains('false');
    cy.get('#renderCount').contains('3');
    cy.get('input[name="firstName"]').type('test');
    cy.get('#isValid').contains('true');
    cy.get('#toggle').click();
    cy.get('#isValid').contains('false');
    cy.get('#toggle').click();
    cy.get('input[name="firstName"]').type('t');
    cy.get('#isValid').contains('true');
  });
});


================================================
File: /cypress/e2e/setError.cy.ts
================================================
describe('form setError', () => {
  it('should contain 3 errors when page land', () => {
    cy.visit('http://localhost:3000/setError');

    cy.get('#error0').contains('0 wrong');
    cy.get('#error1').contains('1 wrong');
    cy.get('#error2').contains('2 wrong');
    cy.get('#error3').contains('3 test');
    cy.get('#error4').contains('4 required');
    cy.get('#error5').contains('5 minLength');
    cy.get('#error').contains(
      'testMessageThis is required.Minlength is 10This is requiredThis is minLength',
    );
  });

  it('should clear individual error', () => {
    cy.visit('http://localhost:3000/setError');

    cy.get('#clear1').click();
    cy.get('#clear2').click();
    cy.get('#error0').contains('0 wrong');
  });

  it('should clear an array of errors', () => {
    cy.visit('http://localhost:3000/setError');

    cy.get('#clearArray').click();
    cy.get('#error0').contains('0 wrong');
  });

  it('should clear every errors', () => {
    cy.visit('http://localhost:3000/setError');

    cy.get('#clear').click();
    cy.get('#errorContainer').should('not.value');
  });
});


================================================
File: /cypress/e2e/watch.cy.ts
================================================
describe('watch form validation', () => {
  it('should watch all inputs', () => {
    cy.visit('http://localhost:3000/watch');

    cy.get('#watchAll').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({}),
    );

    cy.get('#HideTestSingle').should('not.exist');
    cy.get('input[name="testSingle"]').type('testSingle');
    cy.get('#HideTestSingle').contains('Hide Content TestSingle');
    cy.get('#watchAll').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        testSingle: 'testSingle',
        test: ['', ''],
        testObject: { firstName: '', lastName: '' },
        toggle: false,
      }),
    );

    cy.get('input[name="test.0"]').type('bill');
    cy.get('input[name="test.1"]').type('luo');
    cy.get('#testData').contains('["bill","luo"]');
    cy.get('#testArray').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal(['bill', 'luo']),
    );

    cy.get('#watchAll').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        testSingle: 'testSingle',
        test: ['bill', 'luo'],
        testObject: { firstName: '', lastName: '' },
        toggle: false,
      }),
    );

    cy.get('input[name="testObject.firstName"').type('bill');
    cy.get('input[name="testObject.lastName"').type('luo');
    cy.get('#testObject').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        firstName: 'bill',
        lastName: 'luo',
      }),
    );

    cy.get('#testArray').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal(['bill', 'luo']),
    );

    cy.get('#watchAll').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        testSingle: 'testSingle',
        test: ['bill', 'luo'],
        testObject: { firstName: 'bill', lastName: 'luo' },
        toggle: false,
      }),
    );

    cy.get('#hideContent').should('not.exist');
    cy.get('input[name="toggle"').check();
    cy.get('#hideContent').contains('Hide Content');

    cy.get('#watchAll').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        testSingle: 'testSingle',
        test: ['bill', 'luo'],
        testObject: { firstName: 'bill', lastName: 'luo' },
        toggle: true,
      }),
    );
  });
});


================================================
File: /cypress/e2e/useWatchUseFieldArrayNested.cy.ts
================================================
describe('useWatchUseFieldArrayNested', () => {
  it('should watch the correct nested field array', () => {
    cy.visit('http://localhost:3000/useWatchUseFieldArrayNested');

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [{ name: '1a' }, { name: '1c' }],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get(`#nest-remove-0`).click();

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'insert' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get('#prepend').click();
    cy.get('#append').click();
    cy.get('#swap').click();
    cy.get('#insert').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'prepend', keyValue: [] },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'insert' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get(`#nest-append-0`).click();
    cy.get(`#nest-prepend-0`).click();
    cy.get(`#nest-insert-0`).click();
    cy.get(`#nest-swap-0`).click();
    cy.get(`#nest-move-0`).click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'append' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [
            { name: 'insert' },
            { name: '1a' },
            { name: '1c' },
            { name: 'append' },
          ],
        },
      ]),
    );

    cy.get('#nest-update-3').click();

    cy.get('input[name="test.3.keyValue.2.name"]').should(
      'have.value',
      'update',
    );

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'append' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          keyValue: [
            { name: 'insert' },
            { name: '1a' },
            { name: 'update' },
            { name: 'append' },
          ],
          lastName: 'Luo',
        },
      ]),
    );

    cy.get('#nest-update-0').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'update' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [
            { name: 'insert' },
            { name: '1a' },
            { name: 'update' },
            { name: 'append' },
          ],
        },
      ]),
    );

    cy.get('#nest-remove-3').click();
    cy.get('#nest-remove-3').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        {
          firstName: 'prepend',
          keyValue: [
            { name: 'insert' },
            { name: 'prepend' },
            { name: 'update' },
          ],
        },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        {
          firstName: 'Bill',
          lastName: 'Luo',
          keyValue: [{ name: 'insert' }, { name: 'append' }],
        },
      ]),
    );

    cy.get('#nest-remove-all-3').click();
    cy.get('#nest-remove-all-2').click();
    cy.get('#nest-remove-all-1').click();
    cy.get('#nest-remove-all-0').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'prepend', keyValue: [] },
        { firstName: 'insert', keyValue: [] },
        { firstName: 'append', keyValue: [] },
        { firstName: 'Bill', lastName: 'Luo', keyValue: [] },
      ]),
    );

    cy.get('#remove').click();
    cy.get('#remove').click();
    cy.get('#remove').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { firstName: 'prepend', keyValue: [] },
      ]),
    );

    cy.get('#count').contains('8');
  });
});


================================================
File: /cypress/e2e/manualRegisterForm.cy.ts
================================================
describe('manual register form validation', () => {
  it('should validate the form', () => {
    cy.visit('http://localhost:3000/manual-register-form');
    cy.get('#submit').click();

    cy.get('input[name="firstName"] + p').contains('firstName error');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"] + p').contains('selectNumber error');
    cy.get('input[name="minRequiredLength"] + p').contains(
      'minRequiredLength error',
    );
    cy.get('input[name="radio"] + p').contains('radio error');

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('input[name="lastName"] + p').contains('lastName error');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');

    cy.get('input[name="pattern"] + p').contains('pattern error');
    cy.get('input[name="minLength"] + p').contains('minLength error');
    cy.get('input[name="min"] + p').contains('min error');
    cy.get('input[name="max"] + p').contains('max error');
    cy.get('input[name="minDate"] + p').contains('minDate error');
    cy.get('input[name="maxDate"] + p').contains('maxDate error');

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="radio"]').check('1');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');
    cy.get('input[name="checkbox"]').check();

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('45');
  });
});


================================================
File: /cypress/e2e/defaultValues.cy.ts
================================================
describe('defaultValues', () => {
  it('should populate defaultValue for inputs', () => {
    cy.visit('http://localhost:3000/default-values');

    cy.get('input[name="test"]').should('have.value', 'test');
    cy.get('input[name="test1.firstName"]').should('have.value', 'firstName');
    cy.get('input[name="test1.lastName.0"]').should('have.value', 'lastName0');
    cy.get('input[name="test1.lastName.1"]').should('have.value', 'lastName1');
    cy.get('input[name="checkbox"]').eq(0).should('have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('have.checked');

    cy.get('input[name="checkbox"]').eq(0).click();
    cy.get('#toggle').click();
    cy.get('#toggle').click();

    cy.get('input[name="checkbox"]').eq(0).should('not.have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('have.checked');
    cy.get('input[name="checkbox"]').eq(1).click();

    cy.get('#toggle').click();
    cy.get('#toggle').click();

    cy.get('input[name="checkbox"]').eq(0).should('not.have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('not.have.checked');
  });
});


================================================
File: /cypress/e2e/useFieldArrayAsync.cy.ts
================================================
describe('useFieldArray', () => {
  it('should behaviour correctly without defaultValues', () => {
    cy.visit('http://localhost:3000/useFieldArray/normal');

    cy.get('#appendAsync').click();

    cy.focused().should('have.attr', 'id', 'field0');

    cy.get('ul > li').eq(0).get('input').should('have.value', 'appendAsync');

    cy.focused().should('have.attr', 'id', 'field0');

    cy.get('#prependAsync').click();

    cy.get('ul > li').eq(0).get('input').should('have.value', 'prependAsync');

    cy.get('#insertAsync').click();

    cy.focused().should('have.attr', 'id', 'field1');

    cy.get('#field1').should('have.value', 'insertAsync');

    cy.get('#swapAsync').click();

    cy.get('#field0').should('have.value', 'insertAsync');
    cy.get('#field1').should('have.value', 'prependAsync');

    cy.get('#moveAsync').click();

    cy.get('#field1').should('have.value', 'insertAsync');
    cy.get('#field0').should('have.value', 'prependAsync');

    cy.get('#updateAsync').click();

    cy.get('#field0').should('have.value', 'updateAsync');

    cy.get('#replaceAsync').click();

    cy.get('#field0').should('have.value', '11. lorem');
    cy.get('#field1').should('have.value', '11. ipsum');
    cy.get('#field2').should('have.value', '11. dolor');
    cy.get('#field3').should('have.value', '11. sit amet');

    cy.get('#removeAsync').click();

    cy.get('#resetAsync').click();

    cy.get('ul > li').should('not.exist');
  });
});


================================================
File: /cypress/e2e/setValueWithTrigger.cy.ts
================================================
describe('form setValue with trigger', () => {
  it('should set input value and trigger validation', () => {
    cy.visit('http://localhost:3000/setValueWithTrigger');

    cy.get('input[name="firstName"]').type('a');
    cy.get('input[name="firstName"] + p').contains('minLength 10');
    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="firstName"] + p').contains('required');
    cy.get('input[name="firstName"]').type('clear1234567');

    cy.get('input[name="lastName"]').type('a');
    cy.get('input[name="lastName"] + p').contains('too short');
    cy.get('input[name="lastName"]').type('fsdfsdfsd');
    cy.get('input[name="lastName"] + p').contains('error message');
    cy.get('input[name="lastName"]').clear();
    cy.get('input[name="lastName"]').type('bill');

    cy.get('p').should('have.length', 0);
    cy.get('#renderCount').contains('30');
  });
});


================================================
File: /cypress/e2e/useFieldArrayUnregister.cy.ts
================================================
describe('useFieldArrayUnregister', () => {
  it('should behaviour correctly', () => {
    cy.visit('http://localhost:3000/UseFieldArrayUnregister');

    cy.get('#field0').clear().type('bill');

    cy.get('input[name="data.0.conditional"]').type('test');

    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [{ name: true, conditional: true }],
      }),
    );

    cy.get('input[name="data.0.conditional"]').blur();

    cy.get('#touched').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { name: true, conditional: true },
      ]),
    );

    cy.get('#prepend').click();

    cy.get('input[name="data.0.conditional"]').should('not.exist');
    cy.get('input[name="data.1.conditional"]').should('has.value', '');

    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: true, conditional: true },
          { name: true, conditional: true },
          { name: true },
          { name: true },
        ],
      }),
    );

    cy.get('#touched').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        null,
        { name: true, conditional: true },
      ]),
    );

    cy.get('input[name="data.0.name"]').blur();

    cy.get('#swap').click();

    cy.get('input[name="data.1.conditional"]').should('not.exist');
    cy.get('input[name="data.2.conditional"]').should('has.value', '');

    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: true },
          { name: false },
          { name: true, conditional: true },
          { name: true },
        ],
      }),
    );

    cy.get('#touched').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { name: true },
        null,
        { name: true, conditional: true },
      ]),
    );

    cy.get('#insert').click();

    cy.get('#insert').click();

    cy.get('input[name="data.4.name"]').type('test');

    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: true },
          { name: true, conditional: true },
          { name: true },
          { name: true },
          { name: true, conditional: true },
          { name: true },
        ],
      }),
    );

    cy.get('#touched').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { name: true },
        { name: true },
        { name: true },
        null,
        { name: true, conditional: true },
      ]),
    );

    cy.get('#move').click();

    cy.get('input[name="data.2.name"]').clear().type('bill');

    cy.get('input[name="data.2.conditional"]').should('has.value', '');

    cy.get('#dirtyFields').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: true },
          { name: true },
          { name: true, conditional: true },
          { name: true },
          { name: true },
          { name: true },
        ],
      }),
    );

    cy.get('#touched').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal([
        { name: true },
        { name: true },
        { name: true, conditional: true },
        { name: true },
        null,
      ]),
    );

    cy.get('#delete1').click();

    cy.get('input[name="data.1.conditional"]').should('has.value', '');

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '5' },
          { name: 'bill', conditional: '' },
          { name: '10' },
          { name: 'test1' },
          { name: 'test2' },
        ],
      }),
    );

    cy.get('input[name="data.3.name"]').type('test');

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '5' },
          { name: 'bill', conditional: '' },
          { name: '10' },
          { name: 'test1test' },
          { name: 'test2' },
        ],
      }),
    );

    cy.get('#delete3').click();

    cy.get('#submit').click();

    cy.get('#result').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        data: [
          { name: '5' },
          { name: 'bill', conditional: '' },
          { name: '10' },
          { name: 'test2' },
        ],
      }),
    );

    cy.get('#renderCount').contains('25');
  });
});


================================================
File: /cypress/e2e/triggerValidation.cy.ts
================================================
describe('form trigger', () => {
  it('should trigger input validation', () => {
    cy.visit('http://localhost:3000/trigger-validation');

    cy.get('#testError').should('be.empty');
    cy.get('#test1Error').should('be.empty');
    cy.get('#test2Error').should('be.empty');

    cy.get('#single').click();
    cy.get('#testError').contains('required');
    cy.get('#single').click();

    cy.get('#multiple').click();
    cy.get('#test1Error').contains('required');
    cy.get('#test2Error').contains('required');

    cy.get('#renderCount').contains('4');

    cy.get('#multiple').click();
    cy.get('#renderCount').contains('5');
  });
});


================================================
File: /cypress/e2e/useWatch.cy.ts
================================================
describe('useWatch', () => {
  it('should only trigger render when interact with input 1', () => {
    cy.visit('http://localhost:3000/useWatch');
    cy.get('input[name="test"]').type('t');

    cy.get('#parentCounter').contains('1');
    cy.get('#childCounter').contains('1');
    cy.get('#grandChildCounter').contains('2');
    cy.get('#grandChild1Counter').contains('2');
    cy.get('#grandChild2Counter').contains('2');
    cy.get('#grandchild01').contains('t');
    cy.get('#grandchild00').contains('t');

    cy.get('input[name="test"]').type('h');
    cy.get('#grandchild00').contains('th');
    cy.get('#grandchild01').contains('th');
    cy.get('#grandchild2').contains('t');
  });

  it('should only trigger render when interact with input 2', () => {
    cy.visit('http://localhost:3000/useWatch');
    cy.get('input[name="test1"]').type('h');

    cy.get('#parentCounter').contains('1');
    cy.get('#childCounter').contains('1');
    cy.get('#grandChildCounter').contains('2');
    cy.get('#grandChild1Counter').contains('2');
    cy.get('#grandChild2Counter').contains('2');

    cy.get('input[name="test1"]').type('h');
    cy.get('input[name="test"]').type('h');
    cy.get('#grandchild00').contains('h');
    cy.get('#grandchild01').contains('h');
    cy.get('#grandchild1').contains('hh');
    cy.get('#grandchild2').contains('hhh');
  });

  it('should only trigger render when interact with input 3', () => {
    cy.visit('http://localhost:3000/useWatch');
    cy.get('input[name="test2"]').type('e');

    cy.get('#parentCounter').contains('1');
    cy.get('#childCounter').contains('1');
    cy.get('#grandChildCounter').contains('2');
    cy.get('#grandChild1Counter').contains('2');
    cy.get('#grandChild2Counter').contains('2');

    cy.get('input[name="test2"]').type('eh');

    cy.get('input[name="test1"]').type('eh');
    cy.get('input[name="test"]').type('eh');
    cy.get('#grandchild00').contains('eh');
    cy.get('#grandchild01').contains('eh');
    cy.get('#grandchild1').contains('eh');
    cy.get('#grandchild2').contains('eheheeh');
  });
});


================================================
File: /cypress/e2e/setValueAsyncStrictMode.cy.ts
================================================
describe('form setValueAsyncStrictMode', () => {
  it('should set async input value correctly', () => {
    cy.visit('http://localhost:3000/setValueAsyncStrictMode');

    cy.wait(100);

    cy.get('#submit').click();

    cy.get('p').contains('["test","A","B","C","D"]');
  });
});


================================================
File: /cypress/e2e/watchDefaultValues.cy.ts
================================================
describe('watchDefaultValues', () => {
  it('should return default value with watch', () => {
    cy.visit('http://localhost:3000/watch-default-values');

    cy.get('#watchAll').should(
      'have.text',
      '{"test":"test","test1":{"firstName":"firstName","lastName":["lastName0","lastName1"],"deep":{"nest":"nest"}},"flatName[1]":{"whatever":"flat"}}',
    );
    cy.get('#array').should('have.text', '["test",{"whatever":"flat"}]');
    cy.get('#getArray').should('have.text', '["lastName0","lastName1"]');
    cy.get('#object').should('have.text', '["test","firstName"]');
    cy.get('#single').should('have.text', '"firstName"');
    cy.get('#singleDeepArray').should('have.text', '"lastName0"');
  });
});


================================================
File: /cypress/e2e/setValueCustomRegister.cy.ts
================================================
describe('setValue with react native or web', () => {
  it('should only trigger re-render when form state changed or error triggered', () => {
    cy.visit('http://localhost:3000/setValueCustomRegister');
    cy.get('#dirty').contains('false');
    cy.get('#TriggerDirty').click();
    cy.get('#dirty').contains('true');
    cy.get('#TriggerNothing').click();
    cy.get('#TriggerNothing').click();
    cy.get('#TriggerNothing').click();
    cy.get('#TriggerNothing').click();
    cy.get('#renderCount').contains('2');

    cy.get('#WithError').click();
    cy.get('#renderCount').contains('3');
    cy.get('#WithError').click();
    cy.get('#renderCount').contains('4');

    cy.get('#WithoutError').click();
    cy.get('#renderCount').contains('5');
    cy.get('#WithoutError').click();
    cy.get('#renderCount').contains('6');

    cy.get('#WithError').click();
    cy.get('#renderCount').contains('7');

    cy.get('#TriggerNothing').click();
    cy.get('#renderCount').contains('7');
  });
});


================================================
File: /cypress/e2e/formState.cy.ts
================================================
describe('form state', () => {
  it('should return correct form state with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formState/onSubmit');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('15');
  });

  it('should return correct form state with onChange mode', () => {
    cy.visit('http://localhost:3000/formState/onChange');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('13');
  });

  it('should return correct form state with onBlur mode', () => {
    cy.visit('http://localhost:3000/formState/onBlur');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="lastName"]').clear();

    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName'],
        isSubmitted: true,
        submitCount: 1,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="lastName"]').type('test');
    cy.get('#submit').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: true,
        submitCount: 2,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: true,
        isValid: true,
      }),
    );
    cy.get('#renderCount').contains('15');
  });

  it('should reset dirty value when inputs reset back to default with onSubmit mode', () => {
    cy.visit('http://localhost:3000/formState/onSubmit');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('select[name="select"]').select('test1');
    cy.get('select[name="select"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['select'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('select[name="select"]').select('');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="checkbox"]').click();
    cy.get('input[name="checkbox"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['checkbox'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select', 'checkbox'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="checkbox"]').uncheck();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName', 'select', 'checkbox'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="checkbox-checked"]').uncheck();
    cy.get('input[name="checkbox-checked"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['checkbox-checked'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('input[name="checkbox-checked"]').click();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
        ],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="radio"]').click();
    cy.get('input[name="radio"]').blur();
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['radio'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
          'radio',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('select[name="select"]').select('');
    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['radio'],
        isSubmitted: false,
        submitCount: 0,
        touched: [
          'firstName',
          'lastName',
          'select',
          'checkbox',
          'checkbox-checked',
          'radio',
        ],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('20');
  });

  it('should reset dirty value when inputs reset back to default with onBlur mode', () => {
    cy.visit('http://localhost:3000/formState/onBlur');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );
    cy.get('#renderCount').contains('9');
  });

  it('should reset dirty value when inputs reset back to default with onChange mode', () => {
    cy.visit('http://localhost:3000/formState/onChange');
    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: ['firstName', 'lastName'],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: true,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: true,
      }),
    );

    cy.get('#resetForm').click();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: [],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('input[name="firstName"]').type('test');
    cy.get('input[name="firstName"]').blur();
    cy.get('input[name="lastName"]').type('test');
    cy.get('input[name="lastName"]').blur();

    cy.get('input[name="firstName"]').clear();
    cy.get('input[name="lastName"]').clear();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        dirty: [],
        isSubmitted: false,
        submitCount: 0,
        touched: ['firstName', 'lastName'],
        isDirty: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
      }),
    );

    cy.get('#renderCount').contains('13');
  });
});


================================================
File: /cypress/e2e/watchUseFieldArray.cy.ts
================================================
describe('watchUseFieldArray', () => {
  it('should behaviour correctly when watching the field array', () => {
    cy.visit('http://localhost:3000/watch-field-array/normal');

    cy.get('#append').click();
    cy.get('#result').contains('[{"name":"2"}]');

    cy.get('#field0').type('test');
    cy.get('#result').contains('[{"name":"2test"}]');

    cy.get('#prepend').click();
    cy.get('#result').contains('[{"name":"8"},{"name":"2test"}]');

    cy.get('#append').click();
    cy.get('#append').click();
    cy.get('#append').click();
    cy.get('#update').click();
    cy.get('#result').contains(
      '[{"name":"8"},{"name":"2test"},{"name":"10"},{"name":"updated value"},{"name":"14"}]',
    );

    cy.get('#swap').click();
    cy.get('#result').contains(
      '[{"name":"8"},{"name":"10"},{"name":"2test"},{"name":"updated value"},{"name":"14"}]',
    );

    cy.get('#move').click();
    cy.get('#result').contains(
      '[{"name":"2test"},{"name":"8"},{"name":"10"},{"name":"updated value"},{"name":"14"}]',
    );

    cy.get('#insert').click();
    cy.get('#result').contains(
      '[{"name":"2test"},{"name":"22"},{"name":"8"},{"name":"10"},{"name":"updated value"},{"name":"14"}]',
    );

    cy.get('#remove').click();
    cy.get('#result').contains(
      '[{"name":"2test"},{"name":"8"},{"name":"10"},{"name":"updated value"},{"name":"14"}]',
    );

    cy.get('#removeAll').click();
    cy.get('#result').contains('[]');
    cy.get('#renderCount').contains('28');
  });

  it('should return empty when items been removed and defaultValues are supplied', () => {
    cy.visit('http://localhost:3000/watch-field-array/default');

    cy.get('#delete0').click();
    cy.get('#delete0').click();
    cy.get('#delete0').click();

    cy.get('#result').contains('[]');
  });
});


================================================
File: /cypress/e2e/useFormState.cy.ts
================================================
describe('useFormState', () => {
  it('should subscribed to the form state without re-render the root', () => {
    cy.visit('http://localhost:3000/useFormState');
    cy.get('button#submit').click();

    cy.get('input[name="firstName"]').type('bill');
    cy.get('input[name="firstName"]').type('a');
    cy.get('input[name="arrayItem.0.test1"]').type('ab');
    cy.get('input[name="nestItem.nest1"]').type('ab');
    cy.get('input[name="lastName"]').type('luo123456');
    cy.get('select[name="selectNumber"]').select('1');
    cy.get('input[name="pattern"]').type('luo');
    cy.get('input[name="min"]').type('1');
    cy.get('input[name="max"]').type('21');
    cy.get('input[name="minDate"]').type('2019-07-30');
    cy.get('input[name="maxDate"]').type('2019-08-02');
    cy.get('input[name="lastName"]').clear().type('luo');
    cy.get('input[name="minLength"]').type('b');
    cy.get('input[name="minLength"]').blur();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        touched: [
          'nestItem',
          'firstName',
          'arrayItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
        ],
        dirty: [
          'firstName',
          'arrayItem',
          'nestItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
        ],
        isSubmitted: true,
        isSubmitSuccessful: false,
        submitCount: 1,
        isValid: false,
      }),
    );

    cy.get('input[name="pattern"]').type('23');
    cy.get('input[name="minLength"]').type('bi');
    cy.get('input[name="minRequiredLength"]').type('bi');
    cy.get('input[name="min"]').clear().type('11');
    cy.get('input[name="max"]').clear().type('19');
    cy.get('input[name="minDate"]').type('2019-08-01');
    cy.get('input[name="maxDate"]').type('2019-08-01');

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        touched: [
          'nestItem',
          'firstName',
          'arrayItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
          'minRequiredLength',
        ],
        dirty: [
          'firstName',
          'arrayItem',
          'nestItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
          'minRequiredLength',
        ],
        isSubmitted: true,
        isSubmitSuccessful: false,
        submitCount: 1,
        isValid: true,
      }),
    );

    cy.get('#submit').click();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: true,
        touched: [
          'nestItem',
          'firstName',
          'arrayItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
          'minRequiredLength',
        ],
        dirty: [
          'firstName',
          'arrayItem',
          'nestItem',
          'lastName',
          'selectNumber',
          'pattern',
          'min',
          'max',
          'minDate',
          'maxDate',
          'minLength',
          'minRequiredLength',
        ],
        isSubmitted: true,
        isSubmitSuccessful: true,
        submitCount: 2,
        isValid: true,
      }),
    );

    cy.get('#resetForm').click();

    cy.get('#state').should(($state) =>
      expect(JSON.parse($state.text())).to.be.deep.equal({
        isDirty: false,
        touched: [],
        dirty: [],
        isSubmitted: false,
        isSubmitSuccessful: false,
        submitCount: 0,
        isValid: true,
      }),
    );

    cy.get('#renderCount').contains('1');
  });
});


================================================
File: /cypress/e2e/defaultValuesAsync.cy.ts
================================================
describe('defaultValues async', () => {
  it('should populate defaultValue async for inputs', () => {
    cy.visit('http://localhost:3000/default-values-async');

    cy.wait(10);

    cy.get('input[name="test"]').should('have.value', 'test');
    cy.get('input[name="test1.firstName"]').should('have.value', 'firstName');
    cy.get('input[name="test1.lastName.0"]').should('have.value', 'lastName0');
    cy.get('input[name="test1.lastName.1"]').should('have.value', 'lastName1');
    cy.get('input[name="checkbox"]').eq(0).should('have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('have.checked');

    cy.get('input[name="checkbox"]').eq(0).click();
    cy.get('#toggle').click();
    cy.get('#toggle').click();

    cy.get('input[name="checkbox"]').eq(0).should('not.have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('have.checked');
    cy.get('input[name="checkbox"]').eq(1).click();

    cy.get('#toggle').click();
    cy.get('#toggle').click();

    cy.get('input[name="checkbox"]').eq(0).should('not.have.checked');
    cy.get('input[name="checkbox"]').eq(1).should('not.have.checked');
  });
});


================================================
File: /cypress/support/e2e.js
================================================
// ***********************************************************
// This example support/index.js is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import './commands';

// Alternatively you can use CommonJS syntax:
// require('./commands')


================================================
File: /cypress/support/commands.js
================================================
// ***********************************************
// This example commands.js shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************
//
//
// -- This is a parent command --
// Cypress.Commands.add("login", (email, password) => { ... })
//
//
// -- This is a child command --
// Cypress.Commands.add("drag", { prevSubject: 'element'}, (subject, options) => { ... })
//
//
// -- This is a dual command --
// Cypress.Commands.add("dismiss", { prevSubject: 'optional'}, (subject, options) => { ... })
//
//
// -- This will overwrite an existing command --
// Cypress.Commands.overwrite("visit", (originalFn, url, options) => { ... })


================================================
File: /cypress/tsconfig.json
================================================
{
  "compilerOptions": {
    "strict": true,
    "baseUrl": "../node_modules",
    "target": "es5",
    "lib": ["es5", "dom"],
    "types": ["cypress"]
  },
  "include": ["**/*.ts"]
}


================================================
File: /docs/README.es-ES.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Validación simple de formularios React">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook personalizado para la validación de formularios" width="300px" />
        </a>
    </p>
</div>

<p align="center">Formas performantes, flexibles y extensibles con validación fácil de usar.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Validación de formularios de reacción simple">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React hook personalizado para la validacion de de formularios" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | Español | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Caracteristicas

- Construido con rendimiento y DX en mente
- Adopte la validación de forma no controlada
- Mejora el rendimiento de formularios controlados
- [Tiny size](https://bundlephobia.com/result?p=react-hook-form@latest) sin ninguna dependencia
- Sigue el estándar HTML para la validación
- Compatible con React Native
- Soporta [Yup](https://github.com/jquense/yup) validación basada en esquemas
- Admite la validación del navegador nativo
- Cree formularios rápidamente con el [form builder](https://react-hook-form.com/form-builder)

## Instalación

    $ npm install react-hook-form

## Enlaces

- [Motivación](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video tutorial](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Empezar](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Ejemplos](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com)
- [Generador de formularios](https://react-hook-form.com/form-builder)
- [FAQs](https://react-hook-form.com/faqs)

## Inicio rápido

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // inicializar el hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* registrar una entrada */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Patrocinadores

¡Gracias a todos nuestros patrocinadores! [[Hazte patrocinador](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## Organizaciones

Gracias a estas maravillosas organizaciones! [[Contribuir](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Colaboradores

Gracias a estas personas maravillosas! [[Hazte colaborador](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /docs/README.ko-KR.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">유연하고 확장 가능한 사용하기 쉬운 고성능 폼 검증 라이브러리</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | 한국어 | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## 특징

- 성능과 DX를 기반으로 구축
- 제어되지 않는 양식 검증
- 제어 된 양식의 성능을 향상시킵니다
- 의존성 없는 [작은 용량](https://bundlephobia.com/result?p=react-hook-form@latest)
- HTML 표준을 따르는 검증
- React Native 와 호환
- [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) 또는 custom 지원
- 브라우저 네이티브 검증 지원
- [Form Builder](https://react-hook-form.com/form-builder)로 폼 빠르게 생성

## 설치

    $ npm install react-hook-form

## 링크

- [만들게된 동기](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [비디오 튜토리얼](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [시작하기](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [예제](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [데모](https://react-hook-form.com)
- [Form Builder](https://react-hook-form.com/form-builder)
- [FAQs](https://react-hook-form.com/faqs)

## 시작하기

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## 기여자

모든 기여자 분들께 감사합니다! [[기여하기](../CONTRIBUTING.md)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>

## 조직

이 훌륭한 조직에 감사드립니다! [[기증하다](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## 후원자

모든 후원자 분들께 감사합니다! [[후원하기](https://opencollective.com/react-hook-form#backer)]

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>


================================================
File: /docs/README.fr-FR.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">Formulaires performants, flexibles et extensibles dotés d'une validation poussée et facile à utiliser.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | Français | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Fonctionnalités

- Développé en privilegiant les performances et l'experience developpeur.
- Formulaires non-contrôlés.
- Améliorez les performances du formulaire contrôlé.
- [Taille reduite](https://bundlephobia.com/result?p=react-hook-form@latest) sans aucune dépendance.
- Respecte les normes de validation HTML.
- Compatible avec React Native.
- Prend en charge [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) ou personnalisé
- Supporte la validation native du navigateur.
- Possibilité de développer des formulaires rapidement grâce au [form builder](https://react-hook-form.com/form-builder).

## Installation

    $ npm install react-hook-form

## Liens

- [Motivation](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Tutoriel vidéo](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Bien demarrer](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Exemples](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Démo](https://react-hook-form.com)
- [Form Builder](https://react-hook-form.com/form-builder)
- [FAQs](https://react-hook-form.com/faqs)

## Démarrage rapide

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Contributeurs

Merci à ces gens merveilleux! [[Become a contributor](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>

## Organisation

Merci à ces merveilleuses organisations! [[Contribuer](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Sponsors

Merci à tous nos sponsors! [[Become a backer](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>


================================================
File: /docs/README.ru-RU.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">Производительные, гибкие с возможностью расширения и простой в использовании валидацией формы.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | Русский | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Особенности

- Нацелены на производительность и DX
- Применение неконтролируемой проверки форм
- Улучшение производительности контролируемых форм
- [Крошечный размер](https://bundlephobia.com/result?p=react-hook-form@latest) без каких-либо зависимостей
- Следование стандартам HTML для валидации
- Совместимость с React Native
- Поддержка [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) и своих реализаций валидации
- Поддержка нативной браузерной валидации
- Возможность быстро создавать формы с [конструктором форм](https://react-hook-form.com/form-builder)

## Установка

    $ npm install react-hook-form

## Ссылки

- [Мотивация](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Видеоурок](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Начать](https://react-hook-form.com/get-started)
- [АПИ](https://react-hook-form.com/docs)
- [Примеры](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Демонстрация](https://react-hook-form.com)
- [Конструктор форм](https://react-hook-form.com/form-builder)
- [ЧЗВ](https://react-hook-form.com/faqs)

## Быстрый старт

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // инициализация хука
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* регистрация поля ввода */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Фамилия обязательна.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Пожалуйста, введите ваш возраст.'}
      <input type="submit" />
    </form>
  );
}
```

## Спонсоры

Спасибо всем кто поддерживает нас! [[Стать спонсором](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## Организации

Спасибо этим замечательным организациям! [[Спонсировать](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Участники

Спасибо этим замечательным людям! [[Стать участником](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /docs/README.ar-AR.md
================================================
<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - تحقق من صحة استمارة في React بسهولة">
            <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/logo.png" alt="شعار React Hook Form - خطاف React المخصص للتحقق من صحة استمارة" />
        </a>
</div>

https://user-images.githubusercontent.com/10513364/152621466-59a41c65-52b4-4518-9d79-ffa3fafa498a.mp4

<div align="center">

[![عدد التنزيلات من npm](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

<p align="center">
  <a href="https://react-hook-form.com/get-started">البدء</a> | 
  <a href="https://react-hook-form.com/docs">واجهة التطبيق البرمجية</a> |
  <a href="https://github.com/bluebill1049/react-hook-form/tree/master/examples">أمثلة</a> |
  <a href="https://react-hook-form.com">عرض توضيحي</a> |
  <a href="https://react-hook-form.com/form-builder">منشئ استمارة</a> |
  <a href="https://react-hook-form.com/faqs">أسئلة شائعة</a>
</p>

### الميزات

- تم تصميمه مع مراعاة الأداء وتجربة المستخدم وسهولة التطوير
- يدعم التحقق من صحة استمارة الأساسي في HTML [validation](https://react-hook-form.com/get-started#Applyvalidation)
- اندماج مباشر مع مكتبات واجهة المستخدم [UI libraries](https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5)
- [Small size] (https://bundlephobia.com/result?p=react-hook-form@latest) ولا [dependencies](./package.json)
- دعم [Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod), [AJV](https://github.com/ajv-validator/ajv), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi), [Vest](https://github.com/ealush/vest), [class-validator](https://github.com/typestack/class-validator), [io-ts](https://github.com/gcanti/io-ts), [nope](https://github.com/bvego/nope-validator) وبناء مخصص

### التثبيت

    npm install react-hook-form

### البداية السريعة

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} />
      <input {...register('lastName', { required: true })} />
      {errors.lastName && <p>اسم العائلة مطلوب.</p>}
      <input {...register('age', { pattern: /\d+/ })} />
      {errors.age && <p>الرجاء إدخال عدد للعمر.</p>}
      <input type="submit" />
    </form>
  );
}
``` 
<a href="https://ui.dev/bytes/?r=bill">
  <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/ads-1.jpeg" />
</a>
الرعاة
شكرًا لهذه الشركات والأفراد اللطفاء والمحبين!

~الرعاة

الداعمين
شكرًا لجميع داعمينا! [كن داعمًا].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>
المساهمين
شكرًا لهؤلاء الأشخاص الرائعين! [كن مساهمًا].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>
المساعدين
شكرًا لكم على مساعدتكم والإجابة على أسئلة المجتمع.

~المساعدين

المنظمات
شكرًا لهذه المنظمات الرائعة! [ساهم].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=890" />
</a>

================================================
File: /docs/README.pt-BR.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">Performático, Flexível e formulário extensível, com fácil validação.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="https://github.com/react-hook-form/react-hook-form"> English | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Funcionalidades

- Construído com performance e experiência do desenvolvedor em mente
- Validação de formulários incontrolados
- Melhore o desempenho do formulário controlado
- [Baixo Custo](https://bundlephobia.com/result?p=react-hook-form@latest) sem nenhuma dependência
- Segue as normas padrões de validação HTML
- Compatível com React Native
- Suporta [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) ou personalizado
- Suporte nativo a validação do navegador
- Possibilita construção rápida com [form builder](https://react-hook-form.com/form-builder)

## Instalação

    $ npm install react-hook-form

## Endereços

- [Motivação](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video tutorial](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Como iniciar](https://react-hook-form.com/pt/get-started)
- [API](https://react-hook-form.com/pt/api)
- [Exemplos](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demonstração](https://react-hook-form.com/pt)
- [Form Builder](https://react-hook-form.com/pt/form-builder)
- [FAQs](https://react-hook-form.com/pt/faqs)

## Começo rápido

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Contribuidores

Um obrigado especial para estas pessoas incríveis! [[Seja um contribuidor](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>

## Organizações

Obrigado por esta organização maravilhosa! [[Contribuir](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Patrocinadores

Obrigado a todos os patrocionadores! [[Seja um patrocinador](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>


================================================
File: /docs/README.de-DE.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Einfache React Formular Eingabeprüfung">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React einstellbare Hook für Formulareingabeprüfung" width="300px" />
        </a>
    </p>
</div>

<p align="center">Schnellladende, flexible und erweiterbare Formulare mit benutzerfreundlicher Eingabeprüfung</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Einfache React Formular Eingabeprüfung">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React einstellbare Hook für Formulareingabeprüfung" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | Deutsch | <a href="./README.tr-TR.md">Türkçe</a>

## Eigenschaften

- Mit Hinblick auf Leistung und Entwicklererfahrung geschrieben
- Akzeptiert unkontrollierter Eingabeprüfung
- Einfache integration mit [Benutzeroberflaechen Bibliotheken](https://codesandbox.io/s/react-hook-form-controller-079xx)
- [Wenig Speicherbedarf](https://bundlephobia.com/result?p=react-hook-form@latest) ohne Abhnägigkeiten
- Entspricht HTML Standart für [Eingabeprüfung](https://react-hook-form.com/get-started#Applyvalidation)
- Kompatibel mit React Native
- Unterstützt [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) or frei programierbar
- Erstelle Formulare schnell mit dem [Formular Erseller](https://react-hook-form.com/form-builder)

## Installation

    npm install react-hook-form

## Weitere Information

- [Motivation](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video Lehrgang](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Anfangen](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Beispiele](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demonstration](https://react-hook-form.com)
- [Formular Ersteller](https://react-hook-form.com/form-builder)
- [Häufige Fragen](https://react-hook-form.com/faqs)

## Schneller Einstieg

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Sponsoren

Möchten sie Ihr Logo hier? [Direktnachricht mit Twitter](https://twitter.com/HookForm)

## Unterstützer

Vielen Dank an alle unsere Unterstützer! [[Werde auch ein Unterstützer](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## Organisationen

Unser Dank geht auch an folgende wundervolle Organisationen! [[Spenden](https://opencollective.com/react-hook-form/contribute)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Kontributoren

Unser Dank geht auch an folgende wundervolle Personen! [[Werde auch ein Kontributor](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /docs/README.zh-CN.md
================================================
<div align="center">
    <p align="center">
      <a href="https://react-hook-form.com/zh" title="React Hook Form - Simple React forms validation">
        <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - hook custom hook for form validation" width="330px" />
      </a>
    </p>
</div>

<div align="center">

高性能、灵活、易拓展、易于使用的表单校验库

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center"><p align="center"><a href="https://react-hook-form.com/zh" title="React Hook Form - Simple React forms validation"><img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form Logo - React hook form validation" width="100%" /></a></p></div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | 简中 | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## 特性

- 使创建表单和集成更加便捷
- 非受控表单校验
- 以性能和开发体验为基础构建
- [迷你](https://bundlephobia.com/result?p=react-hook-form@latest)的体积而没有其他依赖
- 遵循 html 标准进行校验
- 与 React Native 兼容
- 支持[Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct)或自定义
- 支持浏览器原生校验
- 从[这里](https://react-hook-form.com/zh/form-builder)快速构建你的表单

## 安装

    $ npm install react-hook-form

## 链接

- [动机](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [开始](https://react-hook-form.com/zh/get-started)
- [API](https://react-hook-form.com/zh/api)
- [示例](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com/zh)
- [Form Builder](https://react-hook-form.com/zh/form-builder)
- [常见问题](https://react-hook-form.com/zh/faqs)

## 快速开始

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## 支持者

感谢所有支持者! [[成为支持者](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## 组织机构

感谢这些精彩的组织！ [[捐助](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## 贡献者

感谢这些出色的人！ [[成为贡献者](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /docs/README.tr-TR.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">Güçlü, esnek ve genişletilebilir, kolay doğrulama özelliğine sahip formlar.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | Türkçe

## Features

- Performans ve geliştirici deneyimi gözetilerek yazılmıştır
- Kontrolsüz form doğrulamasını kabul eder
- [Arayüz Kütüphaneleri](https://codesandbox.io/s/react-hook-form-controller-079xx) ile kolay entegrasyon
- Herhangi bir bağımlılık olmadan [ufak boyut](https://bundlephobia.com/result?p=react-hook-form@latest)
- [Validasyon](https://react-hook-form.com/get-started#Applyvalidation) için HTML standartlarını takip eder
- React Native ile uyumludur
- [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) ya da kişisel validasyonlarınızı destekler
- [Form Oluşturucu](https://react-hook-form.com/form-builder) ile formları hızlıca oluşturabilirsiniz

## Yükleme

    npm install react-hook-form

## Linkler

- [Motivasyon](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video eğitimi](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Başlangıç](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Örnekler](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com)
- [Form Oluşturucu](https://react-hook-form.com/form-builder)
- [Sıkça Sorulan Sorular](https://react-hook-form.com/faqs)

## Hızlı Başlangıç

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Sponsorlar

Logonuzu burada görmek istiyor musunuz? [Twitter'dan mesaj atın](https://twitter.com/HookForm)

## Destekleyenler

Tüm destekçilerimize teşekkür ediyoruz! [[Destekçi ol](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## Organizasyonlar

Bu harika organizasyonlar için çok teşekkürler! [[Katkıda bulunun](https://opencollective.com/react-hook-form/contribute)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Katkıda bulunanlar

Bu harika insanlara çok teşekkürler! [[Katkıda bulunun](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /docs/README.V7.zh-CN.md
================================================
<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" />
        </a>
</div>

<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/v7_example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
</div>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

<p align="center">
  <a href="https://react-hook-form.com/get-started">开始</a> | 
  <a href="https://react-hook-form.com/docs">API</a> |
  <a href="https://github.com/bluebill1049/react-hook-form/tree/master/examples">示例</a> |
  <a href="https://react-hook-form.com">Demo</a> |
  <a href="https://react-hook-form.com/form-builder">表单生成器</a> |
  <a href="https://react-hook-form.com/faqs">常见问题</a>
</p>

### Features

- 以性能和开发体验为基础构建
- 支持浏览器原生校验
- [UI库](https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5)开箱即用
- [小巧](https://bundlephobia.com/result?p=react-hook-form@latest)无[依赖](./package.json)
- 遵循 HTML 标准进行[校验](https://react-hook-form.com/get-started#Applyvalidation)
- 支持[Yup](https://github.com/jquense/yup), [Zod](https://github.com/vriad/zod), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi), [Vest](https://github.com/ealush/vest), [class-validator](https://github.com/typestack/class-validator), [io-ts](https://github.com/gcanti/io-ts), [nope](https://github.com/bvego/nope-validator)或自定义

### 安装

    npm install react-hook-form

### 快速开始

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} /> {/* register an input */}
      <input {...register('lastName', { required: true })} />
      {errors.lastName && <p>Last name is required.</p>}
      <input {...register('age', { pattern: /\d+/ })} />
      {errors.age && <p>Please enter number for age.</p>}
      <input type="submit" />
    </form>
  );
}
```

<a href="https://ui.dev/bytes/?r=bill">
  <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/ads-1.jpeg" />
</a>

### 赞助者

感谢所有可爱及热情的（公司/个人）赞助者

<a href="https://underbelly.is/" target="_blank">
  <img src="https://images.opencollective.com/underbelly/989a4a6/logo/256.png" width="94" height="94" />
</a>
<a href="https://www.leniolabs.com/" target="_blank">
  <img src="https://images.opencollective.com/leniolabs_/63e9b6e/logo/256.png" width="94" height="94" />
</a>
<a href="https://graphcms.com/" target="_blank">
  <img src="https://avatars.githubusercontent.com/u/31031438?s=200&v=4" width="94" height="94" />
</a>

<p>
    <a href="https://github.com/sayav"
    ><img
            src="https://avatars1.githubusercontent.com/u/42376060?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@sayav"
    /></a>
    <a href="https://github.com/lemcii"
    ><img
            src="https://avatars1.githubusercontent.com/u/35668113?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@lemcii"
    /></a>
    <a href="https://github.com/washingtonsoares"
    ><img
            src="https://avatars.githubusercontent.com/u/5726140?v=4"
            width="45"
            height="45"
            alt="@washingtonsoares"
    /></a>
    <a href="https://github.com/lixunn"
    ><img
            src="https://avatars.githubusercontent.com/u/4017964?v=4"
            width="45"
            height="45"
            alt="@lixunn"
    /></a>
    <a href="https://github.com/SamSamskies"
    ><img
            src="https://avatars2.githubusercontent.com/u/3655410?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@SamSamskies"
    /></a>
    <a href="https://github.com/peaonunes"
    ><img
            src="https://avatars2.githubusercontent.com/u/3356720?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@peaonunes"
    /></a>
    <a href="https://github.com/wilhelmeek"
    ><img
            src="https://avatars2.githubusercontent.com/u/609452?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@wilhelmeek"
    /></a>
    <a href="https://github.com/iwarner"
    ><img
            src="https://avatars2.githubusercontent.com/u/279251?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@iwarner"
    /></a>
    <a href="https://github.com/joejknowles"
    ><img
            src="https://avatars2.githubusercontent.com/u/10728145?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@joejknowles"
    /></a>
    <a href="https://github.com/chris-gunawardena"
    ><img
            src="https://avatars0.githubusercontent.com/u/5763108?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@chris-gunawardena"
    /></a>
    <a href="https://github.com/Tymek"
    ><img
            src="https://avatars1.githubusercontent.com/u/2625371?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@Tymek"
    /></a>
    <a href="https://github.com/Luchanso"
    ><img
            src="https://avatars0.githubusercontent.com/u/2098777?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@Luchanso"
    /></a>
    <a href="https://github.com/vcarel"
    ><img
            src="https://avatars1.githubusercontent.com/u/1541093?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@vcarel"
    /></a>
    <a href="https://github.com/gragland"
    ><img
            src="https://avatars0.githubusercontent.com/u/1481077?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@gragland"
    /></a>
    <a href="https://github.com/tjshipe"
    ><img
            src="https://avatars2.githubusercontent.com/u/1254942?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@tjshipe"
    /></a>
    <a href="https://github.com/krnlde"
    ><img
            src="https://avatars1.githubusercontent.com/u/1087002?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@krnlde"
    /></a>
    <a href="https://github.com/msutkowski"
    ><img
            src="https://avatars2.githubusercontent.com/u/784953?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@msutkowski"
    /></a>
    <a href="https://github.com/mlukaszczyk"
    ><img
            src="https://avatars3.githubusercontent.com/u/599247?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@mlukaszczyk"
    /></a>
    <a href="https://github.com/susshma"
    ><img
            src="https://avatars0.githubusercontent.com/u/2566818?s=460&u=754ee26b96e321ff28dbc4a2744132015f534fe0&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/MatiasCiccone"
    ><img
            src="https://avatars3.githubusercontent.com/u/32602795?s=460&u=6a0c4dbe23c4f9a5628dc8867842b75989ecc4aa&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/ghostwriternr"
    ><img
            src="https://avatars0.githubusercontent.com/u/10023615?s=460&u=3ec1e4ba991699762fd22a9d9ef47a0599f937dc&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/neighborhood999"
    ><img
            src="https://avatars3.githubusercontent.com/u/10325111?s=450&u=f60c932f81d95a60f77f5c7f2eab4590e07c29af&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/yjp20"
    ><img
            src="https://avatars3.githubusercontent.com/u/44457064?s=460&u=a55119c84e0167f6a3f830dbad3133b28f0c0a8f&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/samantha-wong"
    ><img
            src="https://avatars.githubusercontent.com/u/19571028?s=460&u=7421a02f600646b5836d5973359a257950cae8c4&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/msc-insure"
    ><img
            src="https://avatars.githubusercontent.com/u/44406870?s=200&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/ccheney"
    ><img
            src="https://avatars.githubusercontent.com/u/302437?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/artischockee"
    ><img
            src="https://avatars.githubusercontent.com/u/22125223?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/tsongas"
    ><img
            src="https://avatars.githubusercontent.com/u/2079598?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/knoefel"
    ><img
            src="https://avatars.githubusercontent.com/u/2396344?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/JGibel"
    ><img
            src="https://avatars.githubusercontent.com/u/1953965?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/gpalrepo"
    ><img
            src="https://avatars.githubusercontent.com/u/41862257?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/pjsachdev"
    ><img
            src="https://avatars.githubusercontent.com/u/43356139?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/svict4"
    ><img
            src="https://avatars.githubusercontent.com/u/1137112?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/raisiqueira"
    ><img
            src="https://avatars.githubusercontent.com/u/2914170?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/pashtet422"
    ><img
            src="https://avatars.githubusercontent.com/u/45594821?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/ozywuli"
    ><img
            src="https://avatars.githubusercontent.com/u/5769153?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/monkey0722"
    ><img
            src="https://avatars.githubusercontent.com/u/12868063?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/KATT"
    ><img
            src="https://avatars.githubusercontent.com/u/459267?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/jeroenvisser101"
    ><img
            src="https://avatars.githubusercontent.com/u/1941348?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/sainu"
    ><img
            src="https://avatars.githubusercontent.com/u/12888685?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/bkincart"
    ><img
            src="https://avatars.githubusercontent.com/u/22803185?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/37108"
    ><img
            src="https://avatars.githubusercontent.com/u/36793907?v=4"
            width="45"
            height="45"
    /></a>
</p>

### 支持者

感谢所有支持者! [[成为支持者](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

### 贡献者

感谢这些出色的人！ [[成为贡献者](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>

### 帮助者

感谢您帮助及回答社区中的问题

<a href="https://github.com/leapful">
  <img src="https://avatars.githubusercontent.com/u/18494222?v=4" width="25" />
</a>
<a href="https://github.com/thanh-nguyen-95">
  <img src="https://avatars.githubusercontent.com/u/44762180?v=4" width="25" />
</a>
<a href="https://github.com/slugmandrew">
  <img src="https://avatars.githubusercontent.com/u/153625?v=4" width="25" />
</a>
<a href="https://github.com/lundn">
  <img src="https://avatars.githubusercontent.com/u/4386964?v=4" width="25" />
</a>
<a href="https://github.com/ritikbanger">
  <img src="https://avatars.githubusercontent.com/u/47841501?v=4" width="25" />
</a>
<a href="https://github.com/fahadsohail482">
  <img src="https://avatars.githubusercontent.com/u/46647496?v=4" width="25" />
</a>
<a href="https://github.com/getTobiasNielsen">
  <img src="https://avatars.githubusercontent.com/u/54803528?v=4" width="25" />
</a>
<a href="https://github.com/jfreedman0212">
  <img src="https://avatars.githubusercontent.com/u/31392256?v=4" width="25" />
</a>
<a href="https://github.com/marr">
  <img src="https://avatars.githubusercontent.com/u/44376?v=4" width="25" />
</a>

## 组织机构

感谢这些精彩的组织！ [[捐助](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=890" />
</a>


================================================
File: /docs/README.V6.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" />
        </a>
    </p>
</div>

<p align="center">Performant, flexible and extensible forms with easy to use validation.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/v6_example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

English | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Features

- Built with performance and DX in mind
- Embrace native form validation
- Simple integration with [UI libraries](https://codesandbox.io/s/react-hook-form-v6-controller-qsd8r)
- [Tiny size](https://bundlephobia.com/result?p=react-hook-form@latest) without any dependency
- Follows HTML standard for [validation](https://react-hook-form.com/get-started#Applyvalidation)
- [Resolvers](https://github.com/react-hook-form/resolvers) support [Yup](https://github.com/jquense/yup), [Zod](https://github.com/vriad/zod), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi) or custom

## Install

    npm install react-hook-form

## Links

- [Motivation](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video tutorial](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Get started](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Examples](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com)
- [Form Builder](https://react-hook-form.com/form-builder)
- [FAQs](https://react-hook-form.com/faqs)

## Quickstart

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialize the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Sponsors

Thanks go to these kind and lovely sponsors (company and individuals)!

<a href="https://underbelly.is/" target="_blank">
  <img src="https://images.opencollective.com/underbelly/989a4a6/logo/256.png" width="84" height="84" />
</a>

<p>
    <a href="https://github.com/sayav"
    ><img
            src="https://avatars1.githubusercontent.com/u/42376060?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@sayav"
    /></a>
    <a href="https://github.com/lemcii"
    ><img
            src="https://avatars1.githubusercontent.com/u/35668113?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@lemcii"
    /></a>
    <a href="https://github.com/washingtonsoares"
    ><img
            src="https://avatars0.githubusercontent.com/u/5726140?s=460&u=b300a6fa08a24c59b9db6ebf246384cf8b16a140&v=4"
            width="40"
            height="40"
            alt="@washingtonsoares"
    /></a>
    <a href="https://github.com/lixunn"
    ><img
            src="https://avatars0.githubusercontent.com/u/4017964?s=460&u=3a3fdffeb97749d7509d9c5e9be2cafcb98e426f&v=4"
            width="40"
            height="40"
            alt="@lixunn"
    /></a>
    <a href="https://github.com/SamSamskies"
    ><img
            src="https://avatars2.githubusercontent.com/u/3655410?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@SamSamskies"
    /></a>
    <a href="https://github.com/peaonunes"
    ><img
            src="https://avatars2.githubusercontent.com/u/3356720?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@peaonunes"
    /></a>
    <a href="https://github.com/wilhelmeek"
    ><img
            src="https://avatars2.githubusercontent.com/u/609452?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@wilhelmeek"
    /></a>
    <a href="https://github.com/iwarner"
    ><img
            src="https://avatars2.githubusercontent.com/u/279251?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@iwarner"
    /></a>
    <a href="https://github.com/joejknowles"
    ><img
            src="https://avatars2.githubusercontent.com/u/10728145?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@joejknowles"
    /></a>
    <a href="https://github.com/chris-gunawardena"
    ><img
            src="https://avatars0.githubusercontent.com/u/5763108?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@chris-gunawardena"
    /></a>
    <a href="https://github.com/Tymek"
    ><img
            src="https://avatars1.githubusercontent.com/u/2625371?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@Tymek"
    /></a>
    <a href="https://github.com/Luchanso"
    ><img
            src="https://avatars0.githubusercontent.com/u/2098777?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@Luchanso"
    /></a>
    <a href="https://github.com/vcarel"
    ><img
            src="https://avatars1.githubusercontent.com/u/1541093?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@vcarel"
    /></a>
    <a href="https://github.com/gragland"
    ><img
            src="https://avatars0.githubusercontent.com/u/1481077?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@gragland"
    /></a>
    <a href="https://github.com/tjshipe"
    ><img
            src="https://avatars2.githubusercontent.com/u/1254942?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@tjshipe"
    /></a>
    <a href="https://github.com/krnlde"
    ><img
            src="https://avatars1.githubusercontent.com/u/1087002?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@krnlde"
    /></a>
    <a href="https://github.com/msutkowski"
    ><img
            src="https://avatars2.githubusercontent.com/u/784953?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@msutkowski"
    /></a>
    <a href="https://github.com/mlukaszczyk"
    ><img
            src="https://avatars3.githubusercontent.com/u/599247?s=60&amp;v=4"
            width="40"
            height="40"
            alt="@mlukaszczyk"
    /></a>
    <a href="https://github.com/susshma"
    ><img
            src="https://avatars0.githubusercontent.com/u/2566818?s=460&u=754ee26b96e321ff28dbc4a2744132015f534fe0&v=4"
            width="40"
            height="40"
    /></a>
    <a href="https://github.com/MatiasCiccone"
    ><img
            src="https://avatars3.githubusercontent.com/u/32602795?s=460&u=6a0c4dbe23c4f9a5628dc8867842b75989ecc4aa&v=4"
            width="40"
            height="40"
    /></a>
    <a href="https://github.com/ghostwriternr"
    ><img
            src="https://avatars0.githubusercontent.com/u/10023615?s=460&u=3ec1e4ba991699762fd22a9d9ef47a0599f937dc&v=4"
            width="40"
            height="40"
    /></a>
    <a href="https://github.com/neighborhood999"
    ><img
            src="https://avatars3.githubusercontent.com/u/10325111?s=400&u=f60c932f81d95a60f77f5c7f2eab4590e07c29af&v=4"
            width="40"
            height="40"
    /></a>
    <a href="https://github.com/yjp20"
    ><img
            src="https://avatars3.githubusercontent.com/u/44457064?s=460&u=a55119c84e0167f6a3f830dbad3133b28f0c0a8f&v=4"
            width="40"
            height="40"
    /></a>
    <a href="https://github.com/samantha-wong"
    ><img
            src="https://avatars.githubusercontent.com/u/19571028?s=460&u=7421a02f600646b5836d5973359a257950cae8c4&v=4"
            width="40"
            height="40"
    /></a>
</p>

## Backers

Thanks go to all our backers! [[Become a backer](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## Organizations

Thanks go to these wonderful organizations! [[Contribute](https://opencollective.com/react-hook-form/contribute)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=890" />
</a>

## Contributors

Thanks go to these wonderful people! [[Become a contributor](CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>


================================================
File: /docs/README.V7.ja-JP.md
================================================
<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" />
        </a>
</div>

<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/v7_example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
</div>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

Version 7 | [Version 6(日本語)](/docs/README.ja-JP.md)

## 特徴

- パフォーマンスと UX/DX を念頭に構築
- 非制御フォームバリデーション
- [UIライブラリ](https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5)と統合し、すぐに利用が可能
- [依存関係](./package.json)がなく、[小さいサイズ](https://bundlephobia.com/result?p=react-hook-form@latest)
- ブラウザのネイティブ[バリデーション](https://react-hook-form.com/get-started#Applyvalidation)をサポート
- [Yup](https://github.com/jquense/yup), [Zod](https://github.com/vriad/zod), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi), [Vest](https://github.com/ealush/vest), [class-validator](https://github.com/typestack/class-validator), [io-ts](https://github.com/gcanti/io-ts), [nope](https://github.com/bvego/nope-validator) また custom をサポート

## インストール

    npm install react-hook-form

## リンク集

- [Get started](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Examples](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com)
- [Form Builder](https://react-hook-form.com/form-builder)
- [FAQs](https://react-hook-form.com/faqs)

## Quickstart

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} /> {/* register an input */}
      <input {...register('lastName', { required: true })} />
      {errors.lastName && <p>Last name is required.</p>}
      <input {...register('age', { pattern: /\d+/ })} />
      {errors.age && <p>Please enter number for age.</p>}
      <input type="submit" />
    </form>
  );
}
```

<a href="https://ui.dev/bytes/?r=bill">
  <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/ads-1.jpeg" />
</a>

## スポンサー

親切で素敵なスポンサー(個人/企業)に感謝します!

<a href="https://underbelly.is/" target="_blank">
  <img src="https://images.opencollective.com/underbelly/989a4a6/logo/256.png" width="94" height="94" />
</a>
<a href="https://www.leniolabs.com/" target="_blank">
  <img src="https://images.opencollective.com/leniolabs_/63e9b6e/logo/256.png" width="94" height="94" />
</a>
<a href="https://graphcms.com/" target="_blank">
  <img src="https://avatars.githubusercontent.com/u/31031438?s=200&v=4" width="94" height="94" />
</a>

<p>
    <a href="https://github.com/sayav"
    ><img
            src="https://avatars1.githubusercontent.com/u/42376060?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@sayav"
    /></a>
    <a href="https://github.com/lemcii"
    ><img
            src="https://avatars1.githubusercontent.com/u/35668113?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@lemcii"
    /></a>
    <a href="https://github.com/washingtonsoares"
    ><img
            src="https://avatars.githubusercontent.com/u/5726140?v=4"
            width="45"
            height="45"
            alt="@washingtonsoares"
    /></a>
    <a href="https://github.com/lixunn"
    ><img
            src="https://avatars.githubusercontent.com/u/4017964?v=4"
            width="45"
            height="45"
            alt="@lixunn"
    /></a>
    <a href="https://github.com/SamSamskies"
    ><img
            src="https://avatars2.githubusercontent.com/u/3655410?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@SamSamskies"
    /></a>
    <a href="https://github.com/peaonunes"
    ><img
            src="https://avatars2.githubusercontent.com/u/3356720?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@peaonunes"
    /></a>
    <a href="https://github.com/wilhelmeek"
    ><img
            src="https://avatars2.githubusercontent.com/u/609452?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@wilhelmeek"
    /></a>
    <a href="https://github.com/iwarner"
    ><img
            src="https://avatars2.githubusercontent.com/u/279251?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@iwarner"
    /></a>
    <a href="https://github.com/joejknowles"
    ><img
            src="https://avatars2.githubusercontent.com/u/10728145?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@joejknowles"
    /></a>
    <a href="https://github.com/chris-gunawardena"
    ><img
            src="https://avatars0.githubusercontent.com/u/5763108?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@chris-gunawardena"
    /></a>
    <a href="https://github.com/Tymek"
    ><img
            src="https://avatars1.githubusercontent.com/u/2625371?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@Tymek"
    /></a>
    <a href="https://github.com/Luchanso"
    ><img
            src="https://avatars0.githubusercontent.com/u/2098777?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@Luchanso"
    /></a>
    <a href="https://github.com/vcarel"
    ><img
            src="https://avatars1.githubusercontent.com/u/1541093?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@vcarel"
    /></a>
    <a href="https://github.com/gragland"
    ><img
            src="https://avatars0.githubusercontent.com/u/1481077?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@gragland"
    /></a>
    <a href="https://github.com/tjshipe"
    ><img
            src="https://avatars2.githubusercontent.com/u/1254942?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@tjshipe"
    /></a>
    <a href="https://github.com/krnlde"
    ><img
            src="https://avatars1.githubusercontent.com/u/1087002?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@krnlde"
    /></a>
    <a href="https://github.com/msutkowski"
    ><img
            src="https://avatars2.githubusercontent.com/u/784953?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@msutkowski"
    /></a>
    <a href="https://github.com/mlukaszczyk"
    ><img
            src="https://avatars3.githubusercontent.com/u/599247?s=60&amp;v=4"
            width="45"
            height="45"
            alt="@mlukaszczyk"
    /></a>
    <a href="https://github.com/susshma"
    ><img
            src="https://avatars0.githubusercontent.com/u/2566818?s=460&u=754ee26b96e321ff28dbc4a2744132015f534fe0&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/MatiasCiccone"
    ><img
            src="https://avatars3.githubusercontent.com/u/32602795?s=460&u=6a0c4dbe23c4f9a5628dc8867842b75989ecc4aa&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/ghostwriternr"
    ><img
            src="https://avatars0.githubusercontent.com/u/10023615?s=460&u=3ec1e4ba991699762fd22a9d9ef47a0599f937dc&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/neighborhood999"
    ><img
            src="https://avatars3.githubusercontent.com/u/10325111?s=450&u=f60c932f81d95a60f77f5c7f2eab4590e07c29af&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/yjp20"
    ><img
            src="https://avatars3.githubusercontent.com/u/44457064?s=460&u=a55119c84e0167f6a3f830dbad3133b28f0c0a8f&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/samantha-wong"
    ><img
            src="https://avatars.githubusercontent.com/u/19571028?s=460&u=7421a02f600646b5836d5973359a257950cae8c4&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/msc-insure"
    ><img
            src="https://avatars.githubusercontent.com/u/44406870?s=200&v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/ccheney"
    ><img
            src="https://avatars.githubusercontent.com/u/302437?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/artischockee"
    ><img
            src="https://avatars.githubusercontent.com/u/22125223?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/tsongas"
    ><img
            src="https://avatars.githubusercontent.com/u/2079598?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/knoefel"
    ><img
            src="https://avatars.githubusercontent.com/u/2396344?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/JGibel"
    ><img
            src="https://avatars.githubusercontent.com/u/1953965?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/gpalrepo"
    ><img
            src="https://avatars.githubusercontent.com/u/41862257?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/pjsachdev"
    ><img
            src="https://avatars.githubusercontent.com/u/43356139?v=4"
            width="45"
            height="45"
    /></a>
    <a href="https://github.com/svict4"
    ><img
            src="https://avatars.githubusercontent.com/u/1137112?v=4"
            width="45"
            height="45"
    /></a>
</p>

## 支持者(後援者)

すべての支援者(後援者)に感謝します! [[支持者(後援者)になる](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## 組織

素晴らしい組織に感謝します! [[貢献する](https://opencollective.com/react-hook-form/contribute)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=890" />
</a>

## コントリビューター

素晴らしいコントリビューターに感謝します! [[コントリビューターになる](CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>


================================================
File: /docs/README.ja-JP.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com/jp" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">高性能で柔軟かつ拡張可能な使いやすいフォームバリデーションライブラリ。</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com/jp" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | 日本語 | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## 特徴

- パフォーマンスと DX を念頭に構築
- 非制御フォームバリデーション
- コントロールされたフォームのパフォーマンスを向上させます
- 依存関係のない[小さなサイズ](https://bundlephobia.com/result?p=react-hook-form@latest)
- React Native との互換性
- [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) またはカスタムをサポート
- ブラウザのネイティブバリデーションをサポート
- [Form Builder](https://react-hook-form.com/jp/form-builder) でフォームを素早く作成

## インストール

    $ npm install react-hook-form

## リンク集

- [動機](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [ビデオチュートリアル](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [始める](https://react-hook-form.com/jp/get-started)
- [API](https://react-hook-form.com/jp/api)
- [例](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [デモ](https://react-hook-form.com/jp)
- [Form Builder](https://react-hook-form.com/jp/form-builder)
- [FAQs](https://react-hook-form.com/jp/faqs)

## クイックスタート

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## コントリビューター

これらの素晴らしい人々に感謝します![[コントリビューターになる](../CONTRIBUTING.md)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>

## 組織

これらの素晴らしい組織に感謝します! [[する](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## スポンサー

全てのスポンサーに感謝します! [[スポンサーになる](https://opencollective.com/react-hook-form#backer)]

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>


================================================
File: /docs/Template.md
================================================
<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" />
        </a>
</div>

https://user-images.githubusercontent.com/10513364/152621466-59a41c65-52b4-4518-9d79-ffa3fafa498a.mp4

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

<p align="center">
  <a href="https://react-hook-form.com/get-started">Get started</a> | 
  <a href="https://react-hook-form.com/docs">API</a> |
  <a href="https://github.com/bluebill1049/react-hook-form/tree/master/examples">Examples</a> |
  <a href="https://react-hook-form.com">Demo</a> |
  <a href="https://react-hook-form.com/form-builder">Form Builder</a> |
  <a href="https://react-hook-form.com/faqs">FAQs</a>
</p>

### Features

- Built with performance, UX and DX in mind
- Embraces native HTML form [validation](https://react-hook-form.com/get-started#Applyvalidation)
- Out of the box integration with [UI libraries](https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5)
- [Small size](https://bundlephobia.com/result?p=react-hook-form@latest) and no [dependencies](./package.json)
- Support [Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod), [AJV](https://github.com/ajv-validator/ajv), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi), [Vest](https://github.com/ealush/vest), [class-validator](https://github.com/typestack/class-validator), [io-ts](https://github.com/gcanti/io-ts), [nope](https://github.com/bvego/nope-validator) and custom build

### Install

    npm install react-hook-form

### Quickstart

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} />
      <input {...register('lastName', { required: true })} />
      {errors.lastName && <p>Last name is required.</p>}
      <input {...register('age', { pattern: /\d+/ })} />
      {errors.age && <p>Please enter number for age.</p>}
      <input type="submit" />
    </form>
  );
}
```

<a href="https://ui.dev/bytes/?r=bill">
  <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/ads-1.jpeg" />
</a>

### Sponsors

Thanks go to these kind and lovely sponsors (companies and individuals)!

~Sponsors

### Backers

Thanks go to all our backers! [[Become a backer](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

### Contributors

Thanks go to these wonderful people! [[Become a contributor](CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>

### Helpers

Thank you for helping and answering questions from the community.

~Helpers

### Organizations

Thanks go to these wonderful organizations! [[Contribute](https://opencollective.com/react-hook-form/contribute)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=890" />
</a>

<!--  -->


================================================
File: /docs/README.it-IT.md
================================================
<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" width="300px" />
        </a>
    </p>
</div>

<p align="center">Form veloci, flessibili e personalizzabili con una validazione facile da usare.</p>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center">
    <p align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form video - React custom hook for form validation" width="100%" />
        </a>
    </p>
</div>

<a href="./README.V6.md">English</a> | <a href="./README.zh-TW.md">繁中</a> | <a href="./README.zh-CN.md">简中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | Italiano | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## Caratteristiche

- Sviluppata puntando l'attenzione su peformance ed esperienza di sviluppo
- Validazione form di tipo 'uncontrolled'
- Migliora le prestazioni della forma controllata
- [Leggera](https://bundlephobia.com/result?p=react-hook-form@latest), senza nessuna dipendenza
- Segue gli standard HTML per la validazione
- Compatibile con React Native
- Supporta [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi), [Superstruct](https://github.com/ianstormtaylor/superstruct) o personalizzati
- Supporta la validazione nativa del browser
- Sviluppa form velocemente grazie al [form builder](https://react-hook-form.com/form-builder)

## Installazione

    $ npm install react-hook-form

## Links

- [Perché react-hook-form](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [Video tutorial](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [Primi passi](https://react-hook-form.com/get-started)
- [API](https://react-hook-form.com/docs)
- [Esempi](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com)
- [Form Builder](https://react-hook-form.com/form-builder)
- [FAQ](https://react-hook-form.com/faqs)

## Come iniziare

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## Contributors

Grazie a queste splendide persone! [[Diventa un contributor](../CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>

## Organizzazioni

Grazie a queste meravigliose organizzazioni! [[Contribuire](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## Sostenitori

Grazie anche a tutti i nostri sostenitori! [[Diventa un sostenitore](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>


================================================
File: /docs/Sponsors.yaml
================================================

companies:

    -   website : wantedlyinc.com
        logo : wantedly/d94e44e/logo

    -   website : graphcms.com
        avatar : 31031438

    -   website : Formcarry
        logo : formcarry/a40a4ea/logo


individuals:


================================================
File: /docs/README.zh-TW.md
================================================
<div align="center">
    <p align="center">
      <a href="https://react-hook-form.com/zh" title="React Hook Form - Simple React forms validation">
        <img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - hook custom hook for form validation" width="330px" />
      </a>
    </p>
</div>

<div align="center">

高效能、靈活、易擴充、易於使用的表單

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/bundlephobia/minzip/react-hook-form?style=for-the-badge)](https://bundlephobia.com/result?p=react-hook-form)
[![Coverage Status](https://img.shields.io/coveralls/github/bluebill1049/react-hook-form/master?style=for-the-badge)](https://coveralls.io/github/bluebill1049/react-hook-form?branch=master)

[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=React+hooks+for+form+validation+without+the+hassle&url=https://github.com/bluebill1049/react-hook-form)&nbsp;[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/react-hook-form)

</div>

<div align="center"><p align="center"><a href="https://react-hook-form.com/zh" title="React Hook Form - Simple React forms validation"><img src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/example.gif" alt="React Hook Form Logo - React hook form validation" width="100%" /></a></p></div>

<a href="./README.V6.md">English</a> | 繁中 | <a href="./README.zh-CN.md">簡中</a> | <a href="./README.ja-JP.md">日本語</a> | <a href="./README.ko-KR.md">한국어</a> | <a href="./README.fr-FR.md">Français</a> | <a href="./README.it-IT.md">Italiano</a> | <a href="./README.pt-BR.md">Português</a> | <a href="./README.es-ES.md">Español</a> | <a href="./README.ru-RU.md">Русский</a> | <a href="./README.de-DE.md">Deutsch</a> | <a href="./README.tr-TR.md">Türkçe</a>

## 功能

- 感受效能與開發者體驗（DX）
- 使用原生表單驗證
- 簡單整合 [UI 套件](https://codesandbox.io/s/react-hook-form-v6-controller-24gcl)
- [輕巧](https://bundlephobia.com/result?p=react-hook-form@latest) 且沒有依賴
- 遵循 HTML 標準的 [驗證](https://react-hook-form.com/get-started#Applyvalidation)
- 支援 [Yup](https://github.com/jquense/yup)、[Superstruct](https://github.com/ianstormtaylor/superstruct)、[Joi](https://github.com/hapijs/joi) 等自定義 [Resolvers](https://github.com/react-hook-form/resolvers)
- 使用 [Form Builder](https://react-hook-form.com/form-builder) 快速建構表單

## 安裝

    $ npm install react-hook-form

## 連結

- [動機](https://medium.com/@bruce1049/form-validation-with-hook-in-3kb-c5414edf7d64)
- [影片教學](https://www.youtube.com/watch?v=-mFXqOaqgZk&t)
- [開始](https://react-hook-form.com/zh/get-started)
- [API](https://react-hook-form.com/zh/api)
- [範例](https://github.com/bluebill1049/react-hook-form/tree/master/examples)
- [Demo](https://react-hook-form.com/zh)
- [Form Builder](https://react-hook-form.com/zh/form-builder)
- [常見問題](https://react-hook-form.com/zh/faqs)

## 快速開始

```jsx
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
  const { register, handleSubmit, errors } = useForm(); // initialise the hook
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  );
}
```

## 贊助者

<a href="https://underbelly.is/" target="_blank">
<img src="https://images.opencollective.com/underbelly/989a4a6/logo/256.png" width="75" height="75" />
</a>

<br />

想在這裡秀你的 Logo 嗎？[在 Twitter 上私訊我](https://twitter.com/HookForm)

## 支持者

感謝所有支持者！ [[成為支持者](https://opencollective.com/react-hook-form#backer)]

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

## 組織機構

感謝這些優質的組織！ [[捐助](https://opencollective.com/react-hook-form/contribute)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/organizations.svg?width=950" />
</a>

## 貢獻者

感謝這些出色的人！ [[成為貢獻者](../CONTRIBUTING.md)]

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
    <img src="https://opencollective.com/react-hook-form/contributors.svg?width=950" />
</a>


================================================
File: /.prettierrc
================================================
{
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "trailingComma": "all"
}


================================================
File: /.prettierignore
================================================
/reports


================================================
File: /.npmrc
================================================
auto-install-peers=true


================================================
File: /scripts/jest/jest.config.js
================================================
const jestDefaultConfig = {
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true,
  rootDir: '.',
  roots: ['<rootDir>/src'],
  transformIgnorePatterns: ['[/\\\\]node_modules[/\\\\].+\\.(js|jsx)$'],
};

const web = {
  ...jestDefaultConfig,
  displayName: {
    name: 'Web',
    color: 'cyan',
  },
  testMatch: ['**/__tests__/**/*.(spec|test).ts?(x)'],
  transform: {
    '^.+\\.tsx?$': '@swc/jest',
    '^.+\\.(css|scss|sass)$': 'jest-preview/transforms/css',
    '^(?!.*\\.(js|jsx|mjs|cjs|ts|tsx|css|json)$)':
      'jest-preview/transforms/file',
  },
  setupFilesAfterEnv: ['<rootDir>/scripts/jest/setup.ts'],
  testEnvironment: 'jsdom',
  testEnvironmentOptions: {
    customExportConditions: [''],
  },
};

const server = {
  ...jestDefaultConfig,
  displayName: {
    name: 'Server',
    color: 'blue',
  },
  testMatch: ['**/+([a-zA-Z]).server.(spec|test).ts?(x)'],
  transform: {
    '^.+\\.tsx?$': '@swc/jest',
  },
  testEnvironment: 'node',
};

const getProjects = () => {
  const testEnv = process.env.TEST_ENV;
  if (!testEnv) {
    return [web, server];
  }

  switch (testEnv) {
    case 'web':
      return [web];
    case 'server':
      return [server];
  }
};

module.exports = {
  collectCoverageFrom: [
    '**/**/*.{ts,tsx}',
    '!**/**/*.test.{ts,tsx}',
    '!**/src/types/**',
    '!**/node_modules/**',
    '!**/dist/**',
    '!**/__tests__/**',
  ],
  projects: getProjects(),
};


================================================
File: /scripts/jest/setup.ts
================================================
import '@testing-library/jest-dom';

import { jestPreviewConfigure } from 'jest-preview';
import { TextEncoder } from 'util';

global.TextEncoder = TextEncoder;

// Automatically preview failed tests to Jest Preview Dashboard
// https://www.jest-preview.com/blog/automatic-mode
jestPreviewConfigure({
  autoPreview: true,
});


================================================
File: /scripts/README/Insert.js
================================================
import generators from './Generators.js';

/*
 *  Match lines starting with `~`
 */

const insert_id = /^~\S*$/gm;

const comment_unknown = (type) => `<!-- Unknown Insertion Type : '${type}' -->`;

function insert(raw) {
  const type = toType(raw);

  return generators[type]?.() ?? comment_unknown(type);
}

function toType(string) {
  return string.trim().substring(1);
}

export default function insertInto(template) {
  return template.replace(insert_id, insert);
}


================================================
File: /scripts/README/Previews/Helper.js
================================================
import { toProfile, toAvatar } from 'Link';

export default function generate(helper) {
  const { github, avatar } = helper;

  const lines = [
    `<a href = '${toProfile(github)}'>`,
    `    <img`,
    `        width = 25`,
    `        src = '${toAvatar(avatar)}'`,
    `    />`,
    `</a>`,
  ];

  return lines.join('\n');
}


================================================
File: /scripts/README/Previews/mod.ts
================================================
import individuals from './Individual.js';
import companies from './Company.js';
import helpers from './Helper.js';

export default { individuals, companies, helpers };


================================================
File: /scripts/README/Previews/Company.js
================================================
import { toAvatar, toLogo, toLink } from 'Link';

export default function generate(company) {
  const { website, avatar, logo } = company;

  const icon = avatar ? toAvatar(avatar) : toLogo(logo);

  const lines = [
    `<a`,
    `    target = _blank`,
    `    href = '${toLink(website)}'`,
    `/>`,
    `    <img`,
    `        width = 94`,
    `        src = '${icon}'`,
    `    />`,
    `</a>`,
  ];

  return lines.join('\n');
}


================================================
File: /scripts/README/Previews/Individual.js
================================================
import { toProfile, toAvatar } from 'Link';

export default function generate(individual) {
  const { github, avatar, alt } = individual;

  const lines = [
    `<a href = '${toProfile(github)}'>`,
    `    <img`,
    `        width = 45`,
    `        src = '${toAvatar(avatar)}'`,
    `    />`,
    `</a>`,
  ];

  if (alt) lines.slice(2, 0, `        alt = ${alt}`);

  return lines.join('\n');
}


================================================
File: /scripts/README/Updater.js
================================================
import { format } from 'Time';
import insertInto from './Insert.js';
import Files from 'Files';

const { readTextFile, writeTextFile } = Deno;

const timestamp = format(new Date(), 'yyyy / MM / dd  HH:mm:ss');

/*
 *  Template.md ➞ Insert ➞ README.md
 */

const template = await readTextFile(Files.template);

let build = insertInto(template);

build += `\n<!-- Generated @ ${timestamp} -->\n`;

await writeTextFile(Files.readme, build);


================================================
File: /scripts/README/Imports.json
================================================
{
    "imports" : {
        "YAML" : "https://deno.land/std@0.148.0/encoding/yaml.ts" ,
        "Time" : "https://deno.land/std@0.148.0/datetime/mod.ts" ,
        "Path" : "https://deno.land/std@0.148.0/path/mod.ts" ,
        
        "Previews" : "./Previews/mod.ts" ,
        "Files" : "./Files.js" ,
        "Link" : "./Link.js" ,
        "Data" : "./Data.js"
    }
}

================================================
File: /scripts/README/Link.js
================================================
export function toProfile(username) {
  return `https://github.com/${username}`;
}

export function toAvatar(id) {
  return `https://avatars.githubusercontent.com/u/${id}`;
}

export function toLogo(path) {
  return `https://images.opencollective.com/${path}/256.png`;
}

export function toLink(path) {
  return `https://${path}`;
}


================================================
File: /scripts/README/Data.js
================================================
import { parse } from 'YAML';
import Files from 'Files';

const { readTextFile } = Deno;

const readYAML = async (path) => parse(await readTextFile(path));

const { individuals, companies } = await readYAML(Files.sponsors);

export default { individuals, companies };


================================================
File: /scripts/README/Generators.js
================================================
import Previews from 'Previews';
import Data from 'Data';

function Helpers() {
  return toPreviews('helpers');
}

function Sponsors() {
  return toPreviews('companies') + toPreviews('individuals');
}

function toPreviews(type) {
  return Array.isArray(Data[type])
    ? Data[type].map(Previews[type]).join('\n')
    : '';
}

export default { Sponsors, Helpers };


================================================
File: /scripts/README/Files.js
================================================
import { fromFileUrl, dirname, join } from 'Path';

const folder = dirname(fromFileUrl(import.meta.url));

const root = join(folder, '..', '..'),
  source = join(root, 'docs');

const sponsors = join(source, 'Sponsors.yaml'),
  template = join(source, 'Template.md'),
  helpers = join(source, 'Helpers.yaml'),
  readme = join(root, 'README.md');

export default { template, helpers, sponsors, readme };


================================================
File: /scripts/README/README.md
================================================

# README Updater

*A tool / script that generates  [` README.md `][README] .*

<br>

## Description

This script replaces markers in  [` docs/Template.md `][Template] <br>
with linked icons generated from the data found in <br>
[` docs/Helpers.yaml `][Helpers]  and  [` docs/Sponsors.yaml `][Sponsors] .

<br>
<br>

## Markers

A marker is placed at the start of a line.

<br>

### Syntax

```markdown
~Marker_Id
```

<br>

### Types

-   `Sponsors`

    *Generates icons for sponsors.*

-   `Helpers`

    *Generates icons for helpers.*

<br>
<br>

## Requirements

*Things you need if you run it manually.*

-   **[Deno]**

<br>
<br>

## Running

*Manual execution of the tool.*

<br>

```shell
deno run                                    \
    --allow-read                            \
    --allow-write                           \
    --importmap=scripts/README/Imports.json \
    scripts/README/Updater.js
```

<br>


<!----------------------------------------------------------------------------->

[Sponsors]: ../../docs/Sponsors.yaml
[Template]: ../../docs/Template.md
[Helpers]: ../../docs/Helpers.yaml
[README]: ../../README.md

[Deno]: https://deno.land/

================================================
File: /scripts/apiExtractor.js
================================================
/* eslint-disable @typescript-eslint/no-var-requires */
const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor');
const fs = require('fs');
const path = require('path');

/**
 * Command which developers need to run to generate an updated API report.
 */
const API_EXTRACTOR_YARN_COMMAND = 'yarn api-extractor:build';

const config = loadExtractorConfig();
checkReportMatchesApi(config);
checkNoErrorsAndWarnings(config);
checkLineEndings(config);

/**
 * Runs the API Extractor to check if the API report matches the API.
 * Exits with status code 1 if it does not match.
 * @param config {ExtractorConfig}
 */
function checkReportMatchesApi(config) {
  const result = Extractor.invoke(config, {
    localBuild: false, // validate report, fail on warnings or errors
    messageCallback: (message) => {
      // suppress all error or warnings
      message.handled = true;
    },
  });

  if (result.apiReportChanged) {
    exit(
      `The API Extractor report does not match the exported API.`,
      `Please run \`${API_EXTRACTOR_YARN_COMMAND}\` to generate an`,
      `updated report and commit it.`,
    );
  }
}

/**
 * Runs the API Extractor.
 * Exits with status code 1 if API Extractor reports any warnings or errors.
 * @param config {ExtractorConfig}
 */
function checkNoErrorsAndWarnings(config) {
  const result = Extractor.invoke(config, {
    localBuild: false, // validate report, fail on warnings or errors,
  });

  if (!result.succeeded) {
    exit(
      `API Extractor completed with ${result.errorCount} errors and`,
      `${result.warningCount} warnings.`,
    );
  }
}

/**
 * Checks the line endings of the API extractor report.
 * Exits with status code 1 if the line endings don't match the
 * API Extractor config.
 * @param config {ExtractorConfig}
 */
function checkLineEndings(config) {
  const report = fs.readFileSync(config.reportFilePath);

  const LF = '\n';
  const CRLF = '\r\n';

  const containsLf = report.includes(LF);
  const containsCrLf = report.includes(CRLF);

  const relativeReportPath = path.relative(
    process.cwd(),
    config.reportFilePath,
  );

  if (config.newlineKind === LF && containsCrLf) {
    exit(
      `${relativeReportPath} contains CRLF.`,
      `Please convert its line endings to LF.`,
    );
  }
  if (config.newlineKind === CRLF && containsLf && !containsCrLf) {
    exit(
      `${relativeReportPath} contains LF.`,
      `Please convert its line endings to CRLF.`,
    );
  }
}

/**
 * Finds and loads the API Extractor config relative to the
 * current working directory.
 * @returns {ExtractorConfig}
 */
function loadExtractorConfig() {
  const rawConfig = ExtractorConfig.tryLoadForFolder({
    startingFolder: process.cwd(),
  });
  if (!rawConfig) {
    exit(
      `No API Extractor config could be found for the`,
      `current working directory.`,
    );
  }
  return ExtractorConfig.prepare(rawConfig);
}

/**
 * Surrounds the message with control characters to display red text on a
 * terminal.
 * See {@link https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html}
 * @param message {string}
 */
function red(message) {
  return `\u001b[31m${message}\u001b[0m`;
}

/**
 * Prints a failure reason and exits the process with status code 1.
 * @param message {string}
 */
function exit(...message) {
  /* eslint-disable-next-line no-console */
  console.log(`${red('FAILURE REASON')} ${message.join(' ')}`);
  process.exit(1);
}


================================================
File: /scripts/rollup/all-exports.json
================================================
[
  "Controller",
  "Form",
  "FormProvider",
  "appendErrors",
  "get",
  "set",
  "useController",
  "useFieldArray",
  "useForm",
  "useFormContext",
  "useFormState",
  "useWatch"
]


================================================
File: /scripts/rollup/createRollupConfig.js
================================================
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';
import typescript from 'rollup-plugin-typescript2';

import pkg from '../../package.json';

/**
 *
 * @returns {import("rollup").RollupOptions}
 */
export function createRollupConfig(options, callback) {
  const name = options.name;
  // A file with the extension ".mjs" will always be treated as ESM, even when pkg.type is "commonjs" (the default)
  // https://nodejs.org/docs/latest/api/packages.html#packages_determining_module_system
  const extName = options.format === 'esm' ? 'mjs' : 'js';
  const outputName = 'dist/' + [name, options.format, extName].join('.');

  const config = {
    input: options.input,
    output: {
      file: outputName,
      format: options.format,
      name: 'ReactHookForm',
      sourcemap: true,
      globals: { react: 'React' },
      exports: 'named',
    },
    external: Object.keys(pkg.peerDependencies),
    plugins: [
      typescript({
        tsconfig: options.tsconfig,
        clean: true,
        exclude: ['**/__tests__', '**/*.test.ts'],
      }),
      options.format === 'umd' &&
        commonjs({
          include: /\/node_modules\//,
        }),
      options.format !== 'esm' &&
        terser({
          output: { comments: false },
          compress: {
            drop_console: true,
          },
        }),
    ].filter(Boolean),
  };

  return callback ? callback(config) : config;
}


================================================
File: /scripts/rollup/rollup.esm.config.js
================================================
import pkg from '../../package.json';

import { createRollupConfig } from './createRollupConfig';

export default createRollupConfig({
  name: 'index',
  format: 'esm',
  input: pkg.source,
});


================================================
File: /scripts/rollup/assert-cjs-exports.cjs
================================================
/**
 * This file, when executed in the postbuild lifecycle, ensures that
 * the CJS output is valid CJS according to the package.json spec.
 *
 * @see https://nodejs.org/docs/latest/api/packages.html#packages_determining_module_system
 */
/* eslint-disable @typescript-eslint/no-var-requires */
const exported = require('react-hook-form');
const assert = require('assert');
const fs = require('fs');

/**
 * When this fails, fine the update one-liner in ./assert-esm-exports.mjs
 */
const expected = JSON.parse(
  fs.readFileSync(
    require('path').resolve(__dirname, './all-exports.json'),
    'utf-8',
  ),
);

assert.deepStrictEqual(Object.keys(exported), expected);


================================================
File: /scripts/rollup/rollup.config.js
================================================
import pkg from '../../package.json';

import { createRollupConfig } from './createRollupConfig';

const name = 'index';
const options = [
  {
    name,
    format: 'cjs',
    input: pkg.source,
  },
  { name, format: 'esm', input: pkg.source },
  {
    name: 'react-server',
    format: 'esm',
    input: 'src/index.react-server.ts',
  },
  {
    name,
    format: 'umd',
    input: pkg.source,
  },
];

export default options.map((option) => createRollupConfig(option));


================================================
File: /scripts/rollup/assert-esm-exports.mjs
================================================
/**
 * This file, when executed in the postbuild lifecycle, ensures that
 * the ESM output is valid ESM according to the package.json spec.
 *
 * @see https://nodejs.org/docs/latest/api/packages.html#packages_determining_module_system
 */
import * as exported from 'react-hook-form';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import url from 'url';

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

/**
 * A shell one-liner to update this array when neccessary (run from root of repo):
 *  node -e "import('react-hook-form').then((mod) => console.log(JSON.stringify(Object.keys(mod), null, 2)))" > scripts/rollup/all-exports.json
 */
const expected = JSON.parse(
  fs.readFileSync(
    path.resolve(__dirname, './all-exports.json'),
    'utf-8',
  ),
);

assert.deepStrictEqual(Object.keys(exported), expected);


================================================
File: /.github/workflows/lock-issue.yml
================================================
name: 'Lock Issues'

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0,6,12,18 * * *'

permissions:
  issues: write

concurrency:
  group: lock

jobs:
  action:
    runs-on: ubuntu-latest
    steps:
      - uses: dessant/lock-threads@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          issue-inactive-days: 60


================================================
File: /.github/workflows/README.yml
================================================
name : README

on:
    pull_request:
        types : [ opened , synchronize ]
        paths:
            -   docs/Helpers.yaml
            -   docs/Sponsors.yaml
            -   docs/Template.md

jobs:
    Update-README:
        runs-on : ubuntu-latest
        steps:
            
            -   uses : denoland/setup-deno@v1
                with:
                    deno-version : 1.23.4
                    
            -   uses : actions/checkout@v3
                with:
                    repository: ${{ github.event.pull_request.head.repo.full_name }}
                    ref: ${{ github.event.pull_request.head.ref }}
                
            -   name : Run README updater
                run : 'deno run 
                    --allow-read 
                    --allow-write 
                    --importmap=scripts/README/Imports.json 
                    scripts/README/Updater.js'
                    
            -   name : Commit generated README
                uses : EndBug/add-and-commit@v9
                with:
                    default_author : github_actor
                    message : 'Regenerated README'
                    add: 'README.md'


================================================
File: /.github/workflows/build-test.yml
================================================
name: Unit Test / Lint

on: [pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Dependencies
        uses: ./.github/actions/install-dependencies

      - name: Lint
        run: |
          pnpm lint
          pnpm type

      - name: Test
        run: |
          pnpm run test --ci
          pnpm test:type

      - name: Bundle watch
        run: |
          pnpm bundlewatch


================================================
File: /.github/workflows/compressed-size.yml
================================================
name: Package Size

on: [pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Dependencies
        uses: ./.github/actions/install-dependencies

      - uses: preactjs/compressed-size-action@v2
        with:
          repo-token: '${{ secrets.GITHUB_TOKEN }}'


================================================
File: /.github/workflows/api-extrator.yml
================================================
name: API Extrator

on: [pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Dependencies
        uses: ./.github/actions/install-dependencies

      - name: Build
        run: pnpm build:esm

      - name: API Extractor
        run: pnpm api-extractor:ci


================================================
File: /.github/workflows/automation.yml
================================================
name: E2E Test

on: [pull_request]

jobs:
  cypress-run:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Dependencies
        uses: ./.github/actions/install-dependencies

      - name: Cypress run
        uses: cypress-io/github-action@v6
        with:
          start: pnpm start
          wait-on: 'http://ip6-localhost:3000'
          wait-on-timeout: 120


================================================
File: /.github/workflows/codeql-analysis.yml
================================================
name: 'CodeQL'

on:
  push:
    branches: [master, v6]
  pull_request:
    branches: [master]
  schedule:
    - cron: '40 0 * * 3'

permissions:
  contents: read

jobs:
  analyze:
    permissions:
      security-events: write
    name: Analyze
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        language: ['javascript']

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3


================================================
File: /.github/FUNDING.yml
================================================
# These are supported funding model platforms

github: [bluebill1049, jorisre, kotarella1110, Moshyfawn]
open_collective: react-hook-form
custom: https://youtube.com/@bluebill1049


================================================
File: /.github/stale.yml
================================================
# Configuration for probot-stale - https://github.com/probot/stale

# Number of days of inactivity before an Issue or Pull Request becomes stale
daysUntilStale: 30

# Number of days of inactivity before an Issue or Pull Request with the stale label is closed.
# Set to false to disable. If disabled, issues still need to be closed manually, but will remain marked as stale.
daysUntilClose: 5

# Only issues or pull requests with all of these labels are check if stale. Defaults to `[]` (disabled)
onlyLabels: []

# Issues or Pull Requests with these labels will never be considered stale. Set to `[]` to disable
exemptLabels:
  - waiting-up-vote
  - pinned
  - security

# Set to true to ignore issues in a project (defaults to false)
exemptProjects: false

# Set to true to ignore issues in a milestone (defaults to false)
exemptMilestones: false

# Set to true to ignore issues with an assignee (defaults to false)
exemptAssignees: false

# Label to use when marking as stale
staleLabel: stale

# Comment to post when marking as stale. Set to `false` to disable
markComment: >
  Thank you for your contributions! This Pull Request has been automatically marked as stale 
  because it has not had any recent activity. It will be closed if no further activity occurs.  
  Best, RHF Team ❤️

# Comment to post when removing the stale label.
# unmarkComment: >
#   Your comment here.

# Comment to post when closing a stale Issue or Pull Request.
closeComment: >
  Thank you for your contributions! This Pull Request is being closed because it has
  not had any recent activity. Feel free to re-open the issue and begin work again! 
  Best, RHF Team ❤️

# Limit the number of actions per hour, from 1-30. Default is 30
limitPerRun: 10

# Limit to only `issues` or `pulls`
only: pulls
# Optionally, specify configuration settings that are specific to just 'issues' or 'pulls':
# pulls:
#   daysUntilStale: 30
#   markComment: >
#     This pull request has been automatically marked as stale because it has not had
#     recent activity. It will be closed if no further activity occurs. Thank you
#     for your contributions.

# issues:
#   exemptLabels:
#     - confirmed


================================================
File: /.github/PULL_REQUEST_TEMPLATE/pull_request_template.md
================================================
# Pull Request Template

## Proposed Changes

Please include a summary of the change and which issue is fixed. Please also include relevant motivation and context. List any dependencies that are required for this change.

Fixes # (issue)

## Type of change

Please delete options that are not relevant.

- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] This change requires a documentation update

## Checklist:

- [ ] My code follows the style guidelines of this project
- [ ] I have performed a self-review of my own code
- [ ] My changes generate no new warnings
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing tests pass locally with my changes


================================================
File: /.github/actions/install-dependencies/action.yml
================================================
name: Install Dependencies
description: This is a composite GitHub Action that sets up pnpm, node and installs the project's dependencies.

runs:
  using: composite
  steps:
    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: 9
    - name: Setup Node version to 20
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: pnpm

    - name: Install Dependencies
      run: pnpm install --frozen-lockfile
      shell: bash


================================================
File: /.github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false
contact_links:
  - name: Ask a question
    url: https://github.com/react-hook-form/react-hook-form/discussions
    about: Ask questions and discuss with other community members


================================================
File: /.github/ISSUE_TEMPLATE/bug_report.yml
================================================
name: Bug Report
description: File a bug report
title: 'issue: '
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: input
    id: version
    attributes:
      label: Version Number
      description: What's the version number?
      placeholder: Version number.
    validations:
      required: true
  - type: input
    id: codesandbox
    attributes:
      label: Codesandbox/Expo snack
      description: Codesandbox/Expo snack link
    validations:
      required: true
  - type: markdown
    attributes:
      value: |
        V7
        - [JS](https://codesandbox.io/s/great-paper-deove) Template
        - [TS](https://codesandbox.io/s/eager-sun-jt4df) Template

        V6
        - [JS](https://codesandbox.io/s/mystifying-keller-5jwf5) Template
        - [TS](https://codesandbox.io/s/romantic-moon-0chz7) Template
  - type: textarea
    id: what-happened
    attributes:
      label: Steps to reproduce
      placeholder: Tell us what you see!
      value: |
        1. Go to '...'
        2. Click on '....'
        3. Scroll down to '....'
        4. See error
    validations:
      required: true
  - type: textarea
    id: what-expect
    attributes:
      label: Expected behaviour
    validations:
      required: true
  - type: dropdown
    id: browsers
    attributes:
      label: What browsers are you seeing the problem on?
      multiple: true
      options:
        - Firefox
        - Chrome
        - Safari
        - Edge
  - type: textarea
    id: logs
    attributes:
      label: Relevant log output
      description: Please copy and paste any relevant log output. This will be automatically formatted into code, so no need for backticks.
      render: shell
  - type: checkboxes
    id: terms
    attributes:
      label: Code of Conduct
      description: By submitting this issue, you agree to follow our [Code of Conduct](https://github.com/react-hook-form/react-hook-form/blob/master/CODE_OF_CONDUCT.md)
      options:
        - label: I agree to follow this project's Code of Conduct
          required: true


================================================
File: /.github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: 'feature request, waiting-up-vote'
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.


================================================
File: /cypress.config.ts
================================================
import { defineConfig } from 'cypress';

export default defineConfig({
  video: false,
  e2e: {
    // We've imported your old cypress plugins here.
    // You may want to clean this up later by importing these.
    setupNodeEvents(on, config) {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      return require('./cypress/plugins/index.ts')(on, config);
    },
    baseUrl: 'http://localhost:3000/',
  },
});


================================================
File: /api-extractor.json
================================================
/**
 * Config file for API Extractor.  For more info, please visit: https://api-extractor.com
 */
{
  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
  "newlineKind": "lf",

  /**
   * Optionally specifies another JSON config file that this file extends from.  This provides a way for
   * standard settings to be shared across multiple projects.
   *
   * If the path starts with "./" or "../", the path is resolved relative to the folder of the file that contains
   * the "extends" field.  Otherwise, the first path segment is interpreted as an NPM package name, and will be
   * resolved using NodeJS require().
   *
   * SUPPORTED TOKENS: none
   * DEFAULT VALUE: ""
   */
  // "extends": "./shared/api-extractor-base.json"
  // "extends": "my-package/include/api-extractor-base.json"

  /**
   * Determines the "<projectFolder>" token that can be used with other config file settings.  The project folder
   * typically contains the tsconfig.json and package.json config files, but the path is user-defined.
   *
   * The path is resolved relative to the folder of the config file that contains the setting.
   *
   * The default value for "projectFolder" is the token "<lookup>", which means the folder is determined by traversing
   * parent folders, starting from the folder containing api-extractor.json, and stopping at the first folder
   * that contains a tsconfig.json file.  If a tsconfig.json file cannot be found in this way, then an error
   * will be reported.
   *
   * SUPPORTED TOKENS: <lookup>
   * DEFAULT VALUE: "<lookup>"
   */
  // "projectFolder": "..",

  /**
   * (REQUIRED) Specifies the .d.ts file to be used as the starting point for analysis.  API Extractor
   * analyzes the symbols exported by this module.
   *
   * The file extension must be ".d.ts" and not ".ts".
   *
   * The path is resolved relative to the folder of the config file that contains the setting; to change this,
   * prepend a folder token such as "<projectFolder>".
   *
   * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
   */
  "mainEntryPointFilePath": "<projectFolder>/dist/index.d.ts",

  /**
   * A list of NPM package names whose exports should be treated as part of this package.
   *
   * For example, suppose that Webpack is used to generate a distributed bundle for the project "library1",
   * and another NPM package "library2" is embedded in this bundle.  Some types from library2 may become part
   * of the exported API for library1, but by default API Extractor would generate a .d.ts rollup that explicitly
   * imports library2.  To avoid this, we can specify:
   *
   *   "bundledPackages": [ "library2" ],
   *
   * This would direct API Extractor to embed those types directly in the .d.ts rollup, as if they had been
   * local files for library1.
   */
  "bundledPackages": [],

  /**
   * Determines how the TypeScript compiler engine will be invoked by API Extractor.
   */
  "compiler": {
    /**
     * Specifies the path to the tsconfig.json file to be used by API Extractor when analyzing the project.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * Note: This setting will be ignored if "overrideTsconfig" is used.
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<projectFolder>/tsconfig.json"
     */
    // "tsconfigFilePath": "<projectFolder>/tsconfig.json",
    /**
     * Provides a compiler configuration that will be used instead of reading the tsconfig.json file from disk.
     * The object must conform to the TypeScript tsconfig schema:
     *
     * http://json.schemastore.org/tsconfig
     *
     * If omitted, then the tsconfig.json file will be read from the "projectFolder".
     *
     * DEFAULT VALUE: no overrideTsconfig section
     */
    // "overrideTsconfig": {
    //   . . .
    // }
    /**
     * This option causes the compiler to be invoked with the --skipLibCheck option. This option is not recommended
     * and may cause API Extractor to produce incomplete or incorrect declarations, but it may be required when
     * dependencies contain declarations that are incompatible with the TypeScript engine that API Extractor uses
     * for its analysis.  Where possible, the underlying issue should be fixed rather than relying on skipLibCheck.
     *
     * DEFAULT VALUE: false
     */
    // "skipLibCheck": true,
  },

  /**
   * Configures how the API report file (*.api.md) will be generated.
   */
  "apiReport": {
    /**
     * (REQUIRED) Whether to generate an API report.
     */
    "enabled": true,

    /**
     * The filename for the API report files.  It will be combined with "reportFolder" or "reportTempFolder" to produce
     * a full file path.
     *
     * The file extension should be ".api.md", and the string should not contain a path separator such as "\" or "/".
     *
     * SUPPORTED TOKENS: <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<unscopedPackageName>.api.md"
     */
    "reportFileName": "api-extractor.md",

    /**
     * Specifies the folder where the API report file is written.  The file name portion is determined by
     * the "reportFileName" setting.
     *
     * The API report file is normally tracked by Git.  Changes to it can be used to trigger a branch policy,
     * e.g. for an API review.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<projectFolder>/etc/"
     */
    "reportFolder": "<projectFolder>/reports/",

    /**
     * Specifies the folder where the temporary report file is written.  The file name portion is determined by
     * the "reportFileName" setting.
     *
     * After the temporary file is written to disk, it is compared with the file in the "reportFolder".
     * If they are different, a production build will fail.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<projectFolder>/temp/"
     */
    "reportTempFolder": "<projectFolder>/temp/"
  },

  /**
   * Configures how the doc model file (*.api.json) will be generated.
   */
  "docModel": {
    /**
     * (REQUIRED) Whether to generate a doc model file.
     */
    "enabled": true

    /**
     * The output path for the doc model file.  The file extension should be ".api.json".
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<projectFolder>/temp/<unscopedPackageName>.api.json"
     */
    // "apiJsonFilePath": "<projectFolder>/temp/<unscopedPackageName>.api.json"
  },

  /**
   * Configures how the .d.ts rollup file will be generated.
   */
  "dtsRollup": {
    /**
     * (REQUIRED) Whether to generate the .d.ts rollup file.
     */
    "enabled": false

    /**
     * Specifies the output path for a .d.ts rollup file to be generated without any trimming.
     * This file will include all declarations that are exported by the main entry point.
     *
     * If the path is an empty string, then this file will not be written.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<projectFolder>/dist/<unscopedPackageName>.d.ts"
     */
    // "untrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>.d.ts",

    /**
     * Specifies the output path for a .d.ts rollup file to be generated with trimming for a "beta" release.
     * This file will include only declarations that are marked as "@public" or "@beta".
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: ""
     */
    // "betaTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-beta.d.ts",

    /**
     * Specifies the output path for a .d.ts rollup file to be generated with trimming for a "public" release.
     * This file will include only declarations that are marked as "@public".
     *
     * If the path is an empty string, then this file will not be written.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: ""
     */
    // "publicTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-public.d.ts",

    /**
     * When a declaration is trimmed, by default it will be replaced by a code comment such as
     * "Excluded from this release type: exampleMember".  Set "omitTrimmingComments" to true to remove the
     * declaration completely.
     *
     * DEFAULT VALUE: false
     */
    // "omitTrimmingComments": true
  },

  /**
   * Configures how the tsdoc-metadata.json file will be generated.
   */
  "tsdocMetadata": {
    /**
     * Whether to generate the tsdoc-metadata.json file.
     *
     * DEFAULT VALUE: true
     */
    // "enabled": true,
    /**
     * Specifies where the TSDoc metadata file should be written.
     *
     * The path is resolved relative to the folder of the config file that contains the setting; to change this,
     * prepend a folder token such as "<projectFolder>".
     *
     * The default value is "<lookup>", which causes the path to be automatically inferred from the "tsdocMetadata",
     * "typings" or "main" fields of the project's package.json.  If none of these fields are set, the lookup
     * falls back to "tsdoc-metadata.json" in the package folder.
     *
     * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
     * DEFAULT VALUE: "<lookup>"
     */
    // "tsdocMetadataFilePath": "<projectFolder>/dist/tsdoc-metadata.json"
  },

  /**
   * Specifies what type of newlines API Extractor should use when writing output files.  By default, the output files
   * will be written with Windows-style newlines.  To use POSIX-style newlines, specify "lf" instead.
   * To use the OS's default newline kind, specify "os".
   *
   * DEFAULT VALUE: "crlf"
   */
  // "newlineKind": "crlf",

  /**
   * Configures how API Extractor reports error and warning messages produced during analysis.
   *
   * There are three sources of messages:  compiler messages, API Extractor messages, and TSDoc messages.
   */
  "messages": {
    /**
     * Configures handling of diagnostic messages reported by the TypeScript compiler engine while analyzing
     * the input .d.ts files.
     *
     * TypeScript message identifiers start with "TS" followed by an integer.  For example: "TS2551"
     *
     * DEFAULT VALUE:  A single "default" entry with logLevel=warning.
     */
    "compilerMessageReporting": {
      /**
       * Configures the default routing for messages that don't match an explicit rule in this table.
       */
      "default": {
        /**
         * Specifies whether the message should be written to the tool's output log.  Note that
         * the "addToApiReportFile" property may supersede this option.
         *
         * Possible values: "error", "warning", "none"
         *
         * Errors cause the build to fail and return a nonzero exit code.  Warnings cause a production build fail
         * and return a nonzero exit code.  For a non-production build (e.g. when "api-extractor run" includes
         * the "--local" option), the warning is displayed but the build will not fail.
         *
         * DEFAULT VALUE: "warning"
         */
        "logLevel": "warning"

        /**
         * When addToApiReportFile is true:  If API Extractor is configured to write an API report file (.api.md),
         * then the message will be written inside that file; otherwise, the message is instead logged according to
         * the "logLevel" option.
         *
         * DEFAULT VALUE: false
         */
        // "addToApiReportFile": false
      }

      // "TS2551": {
      //   "logLevel": "warning",
      //   "addToApiReportFile": true
      // },
      //
      // . . .
    },

    /**
     * Configures handling of messages reported by API Extractor during its analysis.
     *
     * API Extractor message identifiers start with "ae-".  For example: "ae-extra-release-tag"
     *
     * DEFAULT VALUE: See api-extractor-defaults.json for the complete table of extractorMessageReporting mappings
     */
    "extractorMessageReporting": {
      "default": {
        "logLevel": "warning"
        // "addToApiReportFile": false
      },

      "ae-missing-release-tag": {
        "logLevel": "none"
      }

      // "ae-extra-release-tag": {
      //   "logLevel": "warning",
      //   "addToApiReportFile": true
      // },
      //
      // . . .
    },

    /**
     * Configures handling of messages reported by the TSDoc parser when analyzing code comments.
     *
     * TSDoc message identifiers start with "tsdoc-".  For example: "tsdoc-link-tag-unescaped-text"
     *
     * DEFAULT VALUE:  A single "default" entry with logLevel=warning.
     */
    "tsdocMessageReporting": {
      "default": {
        "logLevel": "warning"
        // "addToApiReportFile": false
      }

      // "tsdoc-link-tag-unescaped-text": {
      //   "logLevel": "warning",
      //   "addToApiReportFile": true
      // },
      //
      // . . .
    }
  }
}


================================================
File: /.codesandbox/ci.json
================================================
{
  "installCommand": "csb:install",
  "sandboxes": [
    "react-hook-form-v7-js-template-quqov",
    "react-hook-form-v7-ts-template-4tn8i"
  ],
  "node": "18",
  "silent": true
}


================================================
File: /package.json
================================================
{
  "name": "react-hook-form",
  "description": "Performant, flexible and extensible forms library for React Hooks",
  "version": "7.54.1",
  "main": "dist/index.cjs.js",
  "module": "dist/index.esm.mjs",
  "umd:main": "dist/index.umd.js",
  "unpkg": "dist/index.umd.js",
  "jsdelivr": "dist/index.umd.js",
  "jsnext:main": "dist/index.esm.mjs",
  "source": "src/index.ts",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "files": [
    "dist",
    "dist/__tests__"
  ],
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "react-server": "./dist/react-server.esm.mjs",
      "import": "./dist/index.esm.mjs",
      "require": "./dist/index.cjs.js"
    }
  },
  "scripts": {
    "clean": "rimraf dist",
    "prepare": "husky",
    "prebuild": "pnpm clean",
    "build": "pnpm build:modern",
    "build:watch": "pnpm build:modern -w",
    "postbuild": "rimraf dist/__tests__ && node ./scripts/rollup/assert-esm-exports.mjs && node ./scripts/rollup/assert-cjs-exports.cjs",
    "build:modern": "rollup --bundleConfigAsCjs -c ./scripts/rollup/rollup.config.js",
    "build:esm": "rollup --bundleConfigAsCjs -c ./scripts/rollup/rollup.esm.config.js",
    "prettier:fix": "prettier --config .prettierrc --write \"**/*.{js,ts,tsx,css}\"",
    "lint": "eslint '**/*.{js,ts,tsx}'",
    "lint:fix": "pnpm lint --fix",
    "type": "tsc --noEmit",
    "jest-preview": "jest-preview",
    "test": "jest --config ./scripts/jest/jest.config.js",
    "test:coverage": "pnpm test -- --coverage",
    "test:watch": "pnpm test -- --onlyChanged --watch",
    "test:web": "TEST_ENV=web pnpm test",
    "test:type": "tsd src/__typetest__",
    "e2e": "cypress run",
    "e2e:watch": "cypress open",
    "api-extractor": "api-extractor run --local",
    "api-extractor:build": "pnpm build:esm && pnpm api-extractor",
    "api-extractor:ci": "node scripts/apiExtractor.js",
    "postversion": "git push && git push origin v$npm_package_version",
    "prepublishOnly": "pnpm install && pnpm lint:fix && pnpm type && pnpm test && pnpm build",
    "bundlewatch": "pnpm build:modern && bundlewatch",
    "start": "pnpm build:esm && pnpm --dir ./app install && pnpm --dir ./app run dev",
    "csb:install": "npm i -g pnpm@8 && pnpm i"
  },
  "keywords": [
    "react",
    "hooks",
    "form",
    "forms",
    "form-validation",
    "validation",
    "typescript",
    "react-hooks"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/react-hook-form/react-hook-form"
  },
  "homepage": "https://www.react-hook-form.com",
  "author": "<bluebill1049@hotmail.com>",
  "license": "MIT",
  "devDependencies": {
    "@eslint/compat": "^1.2.0",
    "@microsoft/api-extractor": "^7.47.9",
    "@rollup/plugin-commonjs": "^26.0.3",
    "@rollup/plugin-node-resolve": "^15.3.0",
    "@rollup/plugin-terser": "^0.4.4",
    "@swc/core": "^1.7.35",
    "@swc/jest": "^0.2.36",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^16.0.1",
    "@types/jest": "^29.5.13",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^18.3.0",
    "@types/testing-library__jest-dom": "^5.14.9",
    "eslint": "^9.8.0",
    "bundlewatch": "^0.3.3",
    "cypress": "^13.15.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-cypress": "^3.5.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react": "^7.37.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "husky": "^9.1.6",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "jest-preview": "^0.3.1",
    "lint-staged": "^15.2.10",
    "msw": "^2.4.10",
    "prettier": "3.3.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-test-renderer": "^18.3.1",
    "rimraf": "^5.0.10",
    "rollup": "^4.24.0",
    "rollup-plugin-typescript2": "^0.36.0",
    "typescript-eslint": "7.18.0",
    "tsd": "^0.31.2",
    "typescript": "^5.6.3",
    "whatwg-fetch": "^3.6.20"
  },
  "bundlewatch": {
    "files": [
      {
        "path": "./dist/index.cjs.js",
        "maxSize": "10.5 kB"
      }
    ]
  },
  "peerDependencies": {
    "react": "^16.8.0 || ^17 || ^18 || ^19"
  },
  "lint-staged": {
    "*.{js,ts,tsx}": [
      "pnpm lint:fix",
      "pnpm prettier:fix"
    ],
    "*.{md,json,yml}": [
      "prettier --write"
    ]
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/react-hook-form"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}


================================================
File: /CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at bluebill1049@hotmail.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq


================================================
File: /.husky/.gitignore
================================================
_


================================================
File: /.husky/pre-commit
================================================
pnpm type
pnpm lint-staged


================================================
File: /examples/V7/asyncSubmitValidation.tsx
================================================
import { useForm } from 'react-hook-form';

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export default function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
  } = useForm();

  const onSubmit = async (data) => {
    await sleep(2000);
    if (data.username === 'bill') {
      alert(JSON.stringify(data));
    } else {
      alert('There is error');
      setError('username', 'validate');
    }
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="username">User Name</label>
          <input id="username" placeholder="Bill" {...register('username')} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input id="lastName" placeholder="Luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            id="email"
            placeholder="bluebill1049@hotmail.com"
            type="text"
            {...register('email')}
          />
        </div>

        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/customMaskedInputWithController.tsx
================================================
import React from 'react';
import MaskedInput from 'react-input-mask';
import { useForm, Controller } from 'react-hook-form';

import './styles.css';

export const clearTel = (tel) => tel.replace(/[^0-9]/g, '');

const isNotFilledTel = (v) => {
  const clearedTel = clearTel(v);
  return clearedTel.length < 11 ? 'Phone number is required.' : undefined;
};

const Input = (props) => {
  const { onChange, ...restProps } = props;
  return <input {...restProps} onChange={onChange} />;
};

const CustomMaskedInput = (props) => {
  const { value, onChange, name } = props;
  return (
    <MaskedInput
      name={name}
      value={value}
      mask="+7 (999) 999-99-99"
      maskPlaceholder={'_'}
      alwaysShowMask
      onChange={(e) => {
        e.persist();
        onChange(e.target.value);
      }}
    >
      {(inputProps) => (
        <Input {...inputProps} type="text" autoComplete="tel-national" />
      )}
    </MaskedInput>
  );
};

const onSubmit = (data) => {
  console.log('submit', data);
};

export default function App() {
  const {
    handleSubmit,
    formState: { errors },
    control,
  } = useForm({
    reValidateMode: 'onSubmit',
    defaultValues: {
      ControlledMaskedInput: '7',
    },
  });
  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <Controller
            render={({ field }) => <CustomMaskedInput {...field} />}
            rules={{
              validate: {
                inputTelRequired: isNotFilledTel,
              },
            }}
            name="ControlledMaskedInput"
            control={control}
          />

          {errors.ControlledMaskedInput && (
            <p>{errors.ControlledMaskedInput.message}</p>
          )}
        </div>
        <input type="submit" />
      </form>
    </div>
  );
}


================================================
File: /examples/V7/dirtyTouchedSubmitted.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, formState } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(formState);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First name</label>
        <input type="text" {...register('firstName')} />
      </div>
      <div>
        <label>Last name</label>
        <input type="text" {...register('lastName')} />
      </div>
      <div>
        <label>Email</label>
        <input type="text" {...register('email')} />
      </div>
      <div>
        <label>Mobile number</label>
        <input type="tel" {...register('mobileNumber')} />
      </div>
      <div>
        <label>Title</label>
        <select {...register('title')}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input type="radio" value="Yes" {...register('developer')} />
        <input type="radio" value="No" {...register('developer')} />
      </div>

      <pre>{JSON.stringify(formState, null, 2)}</pre>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/asyncFieldValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export default function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="username">User Name</label>
          <input
            id="username"
            placeholder="Bill"
            {...register('username', {
              validate: async (value) => {
                await sleep(3000);
                return value === 'bill';
              },
            })}
          />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input id="lastName" placeholder="Luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            id="email"
            placeholder="bluebill1049@hotmail.com"
            type="text"
            {...register('email')}
          />
        </div>

        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/getValuesCompareFields.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    getValues,
    handleSubmit,
  } = useForm();

  return (
    <div className="App">
      <h1>getValue - Compare Field Values</h1>
      <form onSubmit={handleSubmit((data) => console.log(data))}>
        <label>New Password: </label>
        <input
          name="password"
          ref={register({ required: 'Password is required!' })}
        />
        {errors.password && (
          <p style={{ color: 'white' }}>{errors.password.message}</p>
        )}

        <label>Confirm Password: </label>
        <input
          name="passwordConfirmation"
          ref={register({
            required: 'Please confirm password!',
            validate: {
              matchesPreviousPassword: (value) => {
                const { password } = getValues();
                return password === value || 'Passwords should match!';
              },
            },
          })}
        />
        {errors.passwordConfirmation && (
          <p style={{ color: 'white' }}>
            {errors.passwordConfirmation.message}
          </p>
        )}

        <button type="submit">Trigger</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/normalizeField.tsx
================================================
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import NumberFormat from 'react-number-format';
import { TextField, ThemeProvider, createMuiTheme } from '@material-ui/core';

const theme = createMuiTheme({
  palette: {
    type: 'dark',
  },
});
const defaultValues = {
  priceInCents: 1234567,
  muiPriceInCents: 1234567,
};
function App() {
  const form = useForm({ defaultValues });

  const onSubmit = (data) => {
    form.reset(defaultValues);
  };

  return (
    <ThemeProvider theme={theme}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <label htmlFor="priceInCents">Price</label>
        <label htmlFor="muiPriceInCents">Material UI Price</label>
        <Controller
          name="muiPriceInCents"
          control={form.control}
          render={(props) => <MuiCurrencyFormat {...props} />}
        />

        <input type="submit" />
        <input
          style={{ display: 'block', marginTop: 20 }}
          type="button"
          onClick={() => form.reset(defaultValues)}
          value="Custom Reset"
        />

        <pre style={{ color: '#fff', marginTop: 24 }}>
          {JSON.stringify(form.watch(), null, 2)}
        </pre>
      </form>
    </ThemeProvider>
  );
}

const MuiCurrencyFormat = (props) => {
  const { onChange, value, ...rest } = props;

  return (
    <NumberFormat
      customInput={TextField}
      {...rest}
      value={value}
      fullWidth
      thousandSeparator={true}
      decimalScale={2}
      onValueChange={(target) => {
        onChange(target.floatValue);
      }}
      isNumericString
      prefix="$ "
    />
  );
};


================================================
File: /examples/V7/nativeMultipleInput.tsx
================================================
import React from 'react';
import { useForm, NestedValue } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    handleSubmit,
  } = useForm<{
    email: NestedValue<string[]>;
  }>({
    defaultValues: {
      email: ['first@react.hook.form', 'last@react.hook.form'],
    },
  });

  const onSubmit = handleSubmit<{ email: string }>((data) => {
    alert(JSON.stringify(data));
  });

  return (
    <form onSubmit={onSubmit}>
      <label>Native Multiple Input</label>
      <input
        multiple
        type="email"
        name="email"
        list="email"
        ref={register({ required: 'This is required.' })}
      />
      <datalist id="email">
        <option value="first@react.hook.form" />
        <option value="second@react.hook.form" />
        <option value="third@react.hook.form" />
        <option value="last@react.hook.form" />
      </datalist>
      {errors?.email && <p>{errors.email.message}</p>}

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/resetForm.tsx
================================================
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, reset } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data, e) => {
    e.target.reset(); // reset after form submit
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First name</label>
        <input type="text" ref={register('firstName', { required: true })} />
      </div>
      <div>
        <label>Last name</label>
        <input type="text" {...register('lastName')} />
      </div>
      <div>
        <label>Email</label>
        <input type="text" {...register('email')} />
      </div>
      <div>
        <label>Mobile number</label>
        <input type="tel" {...register('mobileNumber')} />
      </div>
      <div>
        <label>Title</label>
        <select {...register('title')}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input type="radio" value="Yes" {...register('developer')} />
        <input type="radio" value="No" {...register('developer')} />
      </div>

      <input type="submit" />
      <input
        style={{ display: 'block', marginTop: 20 }}
        type="reset"
        value="Standard Reset Field Values"
      />
      <input
        style={{ display: 'block', marginTop: 20 }}
        type="reset"
        onClick={reset}
        value="Custom Reset Field Values & Errors"
      />
    </form>
  );
}


================================================
File: /examples/V7/typescript/Resolver.tsx
================================================
import React from 'react';
import { useForm, Resolver } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
};

const resolver: Resolver<FormValues> = async (values) => {
  return {
    values: !values.firstName ? {} : values,
    errors: !values.firstName
      ? {
          firstName: {
            type: 'required',
            message: 'This is required.',
          },
        }
      : {},
  };
};

export default function App() {
  const { register, handleSubmit, errors } = useForm<FormValues>({
    resolver: resolver,
  });
  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>First Name</label>
        <input {...register('firstName')} />
        {errors?.firstName && <p>{errors.firstName.message}</p>}
      </div>

      <div>
        <label>Last Name</label>
        <input {...register('lastName')} />
      </div>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/typescript/NestedValue.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import {
  TextField,
  FormControl,
  Select,
  MenuItem,
  FormHelperText,
} from '@material-ui/core';
import { Autocomplete } from '@material-ui/lab';

type Option = {
  label: string;
  value: string;
};

const options = [
  { label: 'Chocolate', value: 'chocolate' },
  { label: 'Strawberry', value: 'strawberry' },
  { label: 'Vanilla', value: 'vanilla' },
];

export default function App() {
  const { register, handleSubmit, watch, setValue, errors } = useForm<{
    autocomplete: Option[];
    select: number[];
  }>({
    defaultValues: { autocomplete: [], select: [] },
  });
  const select = watch('select');

  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  useEffect(() => {
    register('autocomplete', {
      validate: (value) => value.length || 'This is required.',
    });
    register('select', {
      validate: (value) => value.length || 'This is required.',
    });
  }, [register]);

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>MUI Autocomplete</label>
        <Autocomplete
          multiple
          options={options}
          getOptionLabel={(option: Option) => option.label}
          onChange={(e, options) => setValue('autocomplete', options)}
          renderInput={(params) => (
            <TextField
              {...params}
              error={Boolean(errors?.autocomplete)}
              helperText={errors?.autocomplete?.message}
            />
          )}
        />
      </div>
      <div>
        <label>MUI Select</label>
        <FormControl>
          <Select
            multiple
            value={select}
            onChange={(e) => setValue('muiSelect', e.target.value as number[])}
            error={Boolean(errors?.select)}
          >
            <MenuItem value={10}>Ten</MenuItem>
            <MenuItem value={20}>Twenty</MenuItem>
            <MenuItem value={30}>Thirty</MenuItem>
          </Select>
          <FormHelperText error={Boolean(errors?.select)}>
            {errors?.select?.message}
          </FormHelperText>
        </FormControl>
      </div>

      <input type="submit" className="button" />
    </form>
  );
}


================================================
File: /examples/V7/typescript/UseFormMethods.tsx
================================================
import React from 'react';
import {
  useForm,
  UseFormReturn,
  UseFormRegisterReturn,
  SubmitHandler,
} from 'react-hook-form';

import './styles.css';

const Input = (props: Partial<UseFormRegisterReturn> & { type?: string }) => (
  <input {...props} />
);

type Option = {
  label: React.ReactNode;
  value: string | number | string[];
};

type SelectProps = UseFormRegisterReturn & { options: Option[] };

const Select = ({ options, ...props }: SelectProps) => (
  <select {...props}>
    {options.map(({ label, value }) => (
      <option value={value}>{label}</option>
    ))}
  </select>
);

type FormProps<TFormValues> = {
  onSubmit: SubmitHandler<TFormValues>;
  children: (methods: UseFormReturn<TFormValues>) => React.ReactNode;
};

const Form = <TFormValues extends Record<string, any> = Record<string, any>>({
  onSubmit,
  children,
}: FormProps<TFormValues>) => {
  const methods = useForm<TFormValues>();
  return (
    <form onSubmit={methods.handleSubmit(onSubmit)}>{children(methods)}</form>
  );
};

type FormValues = {
  firstName: string;
  lastName: string;
  sex: string;
};

export default function App() {
  const onSubmit = (data: FormValues) => alert(JSON.stringify(data));

  return (
    <div className="App">
      <h1>React Hook Form - UseFormReturn</h1>
      <Form<FormValues> onSubmit={onSubmit}>
        {({ register }) => (
          <>
            <Input {...register('firstName')} />
            <Input {...register('lastName')} />
            <Select
              {...register('sex')}
              options={[
                { label: 'Female', value: 'female' },
                { label: 'Male', value: 'male' },
              ]}
            />
            <Input type="submit" />
          </>
        )}
      </Form>
    </div>
  );
}


================================================
File: /examples/V7/typescript/SubmitHandler.tsx
================================================
import React from 'react';
import { useForm, SubmitHandler } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
  email: string;
};

export default function App() {
  const { register, handleSubmit } = useForm<FormValues>();
  const onSubmit: SubmitHandler<FormValues> = (data) =>
    alert(JSON.stringify(data));

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First Name</label>
        <input {...register('firstName')} />
      </div>

      <div>
        <label>Last Name</label>
        <input {...register('lastName')} />
      </div>

      <div>
        <label htmlFor="email">Email</label>
        <input type="email" {...register('email')} />
      </div>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/typescript/Control.tsx
================================================
import React from 'react';
import { useForm, useWatch, Control } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
};

function IsolateReRender({ control }: { control: Control }) {
  const firstName = useWatch<FormValues['firstName']>({
    control,
    name: 'firstName',
    defaultValue: 'default',
  });

  return <div>{firstName}</div>;
}

export default function App() {
  const { register, control, handleSubmit } = useForm<FormValues>();
  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>First Name</label>
        <input {...register('firstName')} />
      </div>
      <div>
        <label>Last Name</label>
        <input {...register('lastName')} />
      </div>
      <IsolateReRender control={control} />

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/defaultValues.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm({
    defaultValues: {
      firstName: 'bill',
      lastName: 'luo',
      email: 'test@test.com',
      isDeveloper: true,
    },
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input placeholder="bill" {...register('firstName')} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input placeholder="luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            placeholder="bluebill1049@hotmail.com"
            type="email"
            {...register('email')}
          />
        </div>

        <div>
          <label>Is developer?</label>
          <input type="checkbox" {...register('isDeveloper')} />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/validationOnFieldChange.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    handleSubmit,
  } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            placeholder="bill"
            {...register('firstName', { required: true })}
          />
          {errors.firstName && 'This is required'}
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            placeholder="luo"
            {...register('lastName', { required: true })}
          />
          {errors.lastName && 'This is required'}
        </div>

        <div>
          <label htmlFor="email" placeholder="bluebill1049@hotmail.com">
            Email
          </label>
          <input {...register('email', { required: true })} />
          {errors.email && 'This is required'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/remoteTriggerFormSubmit.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input {...register('firstName')} placeholder="bill" />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input {...register('lastName')} placeholder="luo" />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            {...register('email')}
            placeholder="bluebill1049@hotmail.com"
            type="email"
          />
        </div>
      </form>

      <button type="button" onClick={handleSubmit(onSubmit)}>
        submit button outside of form
      </button>
    </div>
  );
}


================================================
File: /examples/V7/customInput.tsx
================================================
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';
import Input from '@material-ui/core/Input';
import Select from 'react-select';
import { Input as StrapInput } from 'reactstrap';

const options = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
];

const MyInput = ({ label, name, onChange, onBlur, ref }) => {
  return (
    <>
      <label htmlFor={name}>{label}</label>
      <input
        name={name}
        placeholder="Jane"
        onChange={onChange}
        onBlur={onBlur}
        ref={ref}
      />
    </>
  );
};

export default function App() {
  const { register, handleSubmit, setValue } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data, null));
  };
  const [values, setReactSelect] = useState({
    selectedOption: [],
  });

  const handleMultiChange = (selectedOption) => {
    setValue('reactSelect', selectedOption);
    setReactSelect({ selectedOption });
  };

  useEffect(() => {
    register({ name: 'reactSelect' });
  }, []);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <Input
            style={{
              marginBottom: '20px',
            }}
            name="HelloWorld"
            inputRef={register}
            placeholder="Material UI - Input"
            inputProps={{
              'aria-label': 'Description',
            }}
          />
        </div>

        <div>
          <StrapInput
            placeholder="Strap - Input"
            name="strapInput"
            innerRef={register}
          />
        </div>

        <div>
          <label className="reactSelectLabel">React select</label>
          <Select
            className="reactSelect"
            name="filters"
            placeholder="Filters"
            value={values.selectedOption}
            options={options}
            onChange={handleMultiChange}
            isMulti
          />
        </div>

        <div>
          <MyInput label="First Name" {...register('firstName')} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input placeholder="Luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            placeholder="bluebill1049@hotmail.com"
            type="email"
            {...register('email')}
          />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/conditionalFields.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, watch, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  const moreDetail = watch('moreDetail');

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input placeholder="Bill" {...register('firstName')} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input placeholder="Luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            placeholder="bluebill1049@hotmail.com"
            type="email"
            {...register('email')}
          />
        </div>

        <div>
          <label htmlFor="lastName">More Details</label>
          <input type="checkbox" {...register('moreDetail')} />
        </div>

        {moreDetail && (
          <div>
            <label>Interests</label>
            <input type="text" {...register('interests')} />
          </div>
        )}
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/customValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };
  const initialValues = {
    firstName: 'bill',
    lastName: 'luo',
    email: 'bluebill1049@hotmail.com',
    age: -1,
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            defaultValue={initialValues.firstName}
            placeholder="bill"
            {...register('firstName', {
              validate: (value) => value !== 'bill',
            })}
          />
        </div>
        {errors.firstName && <p>Your name is not bill</p>}

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            defaultValue={initialValues.lastName}
            placeholder="luo"
            {...register('lastName', {
              validate: (value) => value.length > 3,
            })}
          />
        </div>
        {errors.lastName && <p>Your last name is less than 3 characters</p>}

        <div>
          <label htmlFor="email">Email</label>
          <input
            defaultValue={initialValues.email}
            placeholder="bluebill1049@hotmail.com"
            type="email"
            {...register('email')}
          />
        </div>

        <div>
          <label htmlFor="age">Age</label>
          <input
            defaultValue={initialValues.age}
            placeholder="0"
            type="text"
            {...register('age', {
              validate: {
                positiveNumber: (value) => parseFloat(value) > 0,
                lessThanHundred: (value) => parseFloat(value) < 200,
              },
            })}
          />
        </div>
        {errors.age && errors.age.type === 'positiveNumber' && (
          <p>Your age is invalid</p>
        )}
        {errors.age && errors.age.type === 'lessThanHundred' && (
          <p>Your age should be less than 200</p>
        )}

        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/disableNativeValidation.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    formState: { errors },
    handleSubmit,
    register,
  } = useForm();

  const onSubmit = (data) => {
    console.log({ data });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} noValidate>
      <label htmlFor="email">Email</label>
      <input
        name="email"
        type="email"
        ref={register({
          required: 'Email is required',
          validate: (value) =>
            value.includes('@') || "Email must include '@' symbol",
        })}
      />
      {errors.email && errors.email.message}
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/registerWithErrorMessages.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    handleSubmit,
  } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <label htmlFor="firstName">First Name</label>
        <input
          placeholder="Bill"
          {...register('firstName', {
            required: 'this is a required',
            maxLength: {
              value: 2,
              message: 'Max length is 2',
            },
          })}
        />
        <br />
        {errors.firstName && errors.firstName.message}
        <br />

        <label htmlFor="lastName">Last Name</label>
        <input
          placeholder="Luo"
          {...register('lastName', {
            required: 'this is required',
            minLength: {
              value: 2,
              message: 'Min length is 2',
            },
          })}
        />
        <br />
        {errors.lastName && errors.lastName.message}
        <br />

        <label htmlFor="email">Email</label>
        <input
          placeholder="bluebill1049@hotmail.com"
          type="text"
          {...register('email', {
            required: 'this is required',
            pattern: {
              value:
                /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/,
              message: 'Invalid email address',
            },
          })}
        />
        <br />
        {errors.email && errors.email.message}
        <br />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/initalFormState.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

import './styles.css';

const defaultValues = {
  firstName: 'bill',
  lastName: 'luo',
  email: 'bluebill1049@hotmail.com',
};

function App() {
  const { register, handleSubmit } = useForm();
  // or you can set the defaultValues within useForm
  // const { register, handleSubmit } = useForm({
  //   defaultValues,
  // });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <label htmlFor="firstName">First Name</label>
      <input
        defaultValue={defaultValues.firstName}
        placeholder="bill"
        {...register('firstName')}
      />

      <label htmlFor="lastName">Last Name</label>
      <input
        defaultValue={defaultValues.lastName}
        placeholder="luo"
        {...register('lastName')}
      />

      <label htmlFor="email">Email</label>
      <input
        defaultValue={defaultValues.email}
        placeholder="bluebill1049@hotmail.com"
        type="email"
        {...register('email')}
      />

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/formProvider.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm, FormProvider, useFormContext } from 'react-hook-form';

export default function App() {
  const methods = useForm();
  const { register, handleSubmit } = methods;
  return (
    <FormProvider {...methods}>
      <form onSubmit={handleSubmit((data) => console.log(data))}>
        <label>Test</label>
        <input {...register('test', { required: true })} />
        <label>Nested Input</label>
        <Test />
        <input type="submit" />
      </form>
    </FormProvider>
  );
}

function Test() {
  const data = useFormContext();
  return <input {...data.register('bill')} />;
}


================================================
File: /examples/V7/nestedFields.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export function FormSection1({ register }) {
  return (
    <>
      <div>
        <label>First name</label>
        <input
          type="text"
          {...register('firstName', { required: true, maxLength: 80 })}
        />
      </div>
      <div>
        <label>Last name</label>
        <input
          type="text"
          {...register('lastName', { required: true, maxLength: 100 })}
        />
      </div>
    </>
  );
}

export function FormSection2({ register }) {
  return (
    <>
      <div>
        <label>Email</label>
        <input
          type="email"
          {...register('email', {
            required: true,
          })}
        />
      </div>
      <div>
        <label>Mobile number</label>
        <input
          type="tel"
          {...register('mobileNumber', {
            required: true,
            maxLength: 11,
            minLength: 8,
          })}
        />
      </div>
      <div>
        <label>Title</label>
        <select {...register('title', { required: true })}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input
          type="radio"
          value="Yes"
          {...register('developer', { required: true })}
        />
        <input
          type="radio"
          value="No"
          {...register('developer', { required: true })}
        />
      </div>
    </>
  );
}

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <FormSection1 register={register} />
      <FormSection2 register={register} />
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/triggerFieldValidation.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    trigger,
    handleSubmit,
  } = useForm();

  console.log('errors', errors);

  return (
    <form onSubmit={handleSubmit((data) => console.log(data))}>
      <h1>validationField</h1>
      <label>First name: </label>
      <input {...register('firstName', { required: true })} />

      <label>Last name: </label>
      <input {...register('lastName', { required: true })} />

      <button
        type="button"
        onClick={async () => {
          const result = await trigger(['firstName', 'lastName']);
          if (result) {
            console.log('Valid input');
          }
        }}
      >
        Trigger
      </button>
    </form>
  );
}


================================================
File: /examples/V7/validationSchema.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup'; // you will have to install yup
import { yupResolver } from '@hookform/resolvers/yup'; // you will have to install @hookform/resolvers

const SignupSchema = yup.object().shape({
  firstName: yup.string().required(),
  age: yup.number().required().positive().integer(),
  website: yup.string().url(),
});

export default function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: yupResolver(SignupSchema),
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Are you a Developer?</label>
        Yes
        <input type="radio" {...register('test')} value="yes" />
        No
        <input type="radio" {...register('test')} value="no" />
      </div>
      <div>
        <label>First Name</label>
        <input type="text" {...register('firstName')} />
      </div>
      <div>
        <label>Last Name</label>
        <input type="text" {...register('lastName')} />
      </div>
      <div>
        <label>Age</label>
        <input type="text" {...register('age')} />
      </div>
      <div>
        <label>Website</label>
        <input type="text" {...register('website')} />
      </div>

      <div style={{ color: 'red' }}>
        <pre>
          {Object.keys(errors).length > 0 && (
            <label>Errors: {JSON.stringify(errors, null, 2)}</label>
          )}
        </pre>
      </div>
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/basicValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

import './styles.css';

export default function Form() {
  const { register, errors, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };
  console.log(errors);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="firstName">First name</label>
        <input
          id="firstName"
          type="text"
          {...register('firstName', { required: true, maxLength: 80 })}
        />
      </div>
      <div>
        <label htmlFor="lastName">Last name</label>
        <input
          id="lastName"
          type="text"
          {...register('lastName', { required: true, maxLength: 100 })}
        />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="text"
          {...register('email', {
            required: true,
            pattern:
              /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
          })}
        />
      </div>
      <div>
        <label htmlFor="mobileNumber">Mobile number</label>
        <input
          id="mobileNumber"
          type="tel"
          {...register('mobileNumber', {
            required: true,
            maxLength: 11,
            minLength: 8,
          })}
        />
      </div>
      <div>
        <label htmlFor="title">Title</label>
        <select id="title" {...register('title', { required: true })}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <fieldset>
          <legend>Are you a developer?</legend>

          <div>
            <input
              id="devYes"
              type="radio"
              value="Yes"
              {...register('developer', { required: true })}
            />
            <label htmlFor="devYes">Yes</label>
          </div>

          <div>
            <input
              id="devNo"
              type="radio"
              value="No"
              {...register('developer', { required: true })}
            />
            <label htmlFor="devNo">No</label>
          </div>
        </fieldset>
      </div>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/parseFormatInputValues.tsx
================================================
import React from 'react';
import { Controller, useForm } from 'react-hook-form';

const ParseFormatTextarea = ({ value = [], onChange }) => {
  const [text, setText] = React.useState(value);

  const handleChange = (e) => {
    const value = e.target.value.split('\n');

    setText(e.target.value);
    onChange(value);
  };

  return <textarea onChange={handleChange} value={text} />;
};

export default function App() {
  const { control, handleSubmit } = useForm();
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="emails"
        render={ParseFormatTextarea}
        control={control}
        defaultValue={[]}
      />

      <Controller
        name="number"
        render={({ value, onChange }) => (
          <input
            type="number"
            value={value}
            onChange={(e) => onChange(parseInt(e.target.value, 10))}
          />
        )}
        control={control}
        defaultValue={0}
      />

      <button type="submit">Submit</button>
    </form>
  );
}


================================================
File: /examples/V7/asyncSetFormValues.tsx
================================================
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, reset } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  useEffect(() => {
    // you can use `async` server requests to populate your form!
    setTimeout(() => {
      reset({
        firstName: 'bill',
        lastName: 'luo',
      });
    }, 2000);
  }, [reset]);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h1>Async Set Form Values</h1>
      <label>First name</label>
      <input {...register('firstName')} />

      <label>Last name</label>
      <input {...register('lastName')} />
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/FieldArray.tsx
================================================
import React, { useState } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

function createArrayWithNumbers(length) {
  return Array.from({ length }, (_, i) => i);
}

export default function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();
  const [size, setSize] = useState(1);
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        {createArrayWithNumbers(size).map((number) => {
          return (
            <div key={number}>
              <div>
                <label htmlFor={`firstName.${number}`}>First Name</label>
                <input
                  id={`firstName.${number}`}
                  placeholder="first name"
                  {...register(`firstName.${number}`, { required: true })}
                />
              </div>

              <div>
                <label htmlFor={`lastName.${number}`}>Last Name</label>
                <input
                  id={`firstName.${number}`}
                  placeholder="last name"
                  {...register(`lastName.${number}`, { required: true })}
                />
              </div>

              <div>
                <label htmlFor={`email.${number}`}>Email</label>
                <input
                  id={`email.${number}`}
                  placeholder="email"
                  {...register(`email.${number}`, { required: true })}
                />
              </div>

              <hr />
            </div>
          );
        })}

        <button type="button" onClick={() => setSize(size + 1)}>
          Add Person
        </button>
        <br />
        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/validationOnFieldBlur.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const {
    register,
    formState: { errors },
    handleSubmit,
  } = useForm({
    mode: 'onBlur',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            placeholder="bill"
            {...register('firstName', { required: true })}
          />
          {errors.firstName && 'This is required'}
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            placeholder="luo"
            {...register('lastName', { required: true })}
          />
          {errors.lastName && 'This is required'}
        </div>

        <div>
          <label htmlFor="email" placeholder="bluebill1049@hotmail.com">
            Email
          </label>
          <input {...register('email', { required: true })} />
          {errors.email && 'This is required'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/basic.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input id="firstName" placeholder="bill" {...register('firstName')} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input id="lastName" placeholder="luo" {...register('lastName')} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            id="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            {...register('email')}
          />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V7/fieldArrayMinLength.tsx
================================================
import React from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { object, array, string } from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

const validationSchema = object().shape({
  questions: array()
    .of(
      object().shape({
        text: string().required('Some text is required'),
      }),
    )
    .required(),
});

function App() {
  const {
    control,
    register,
    formState: { errors },
    clearErrors,
    setValue,
    unregister,
    handleSubmit,
    trigger,
  } = useForm({
    mode: 'onChange',
    resolver: yupResolver(validationSchema),
  });
  const { fields, append, remove } = useFieldArray({
    control,
    name: 'questions',
  });

  const isInitialRender = React.useRef(true);
  const appendQuestion = () => {
    append({
      text: '',
    });

    if (errors.questions?.type === 'min') {
      clearErrors('questions'); // always clear errors when a question is appended
    }
  };

  React.useEffect(() => {
    if (!fields.length && !isInitialRender.current) {
      trigger('questions');
    }

    if (isInitialRender.current) {
      isInitialRender.current = false;
    }
  }, [fields, register, setValue, unregister, trigger]);

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <h1>Yup Validation - Field Array</h1>
      {fields.map((question, questionIndex) => (
        <div key={question.id}>
          <input
            ref={register()}
            name={`questions[${questionIndex}].text`}
            control={control}
            defaultValue=""
          />

          <button
            type="button"
            onClick={() => {
              remove(questionIndex);
              trigger();
            }}
          >
            Remove question {question.id}
          </button>
        </div>
      ))}
      <p>Errors: {JSON.stringify(errors)}</p>
      <button type="button" onClick={appendQuestion}>
        Add question
      </button>
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V7/setValue.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, setValue } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="firstName">First Name</label>
        <input placeholder="bill" {...register('firstName')} />
      </div>

      <div>
        <label htmlFor="lastName">Last Name</label>
        <input placeholder="luo" {...register('lastName')} />
      </div>

      <div>
        <label htmlFor="email">Email</label>
        <input
          placeholder="bluebill1049@hotmail.com"
          type="email"
          {...register('email')}
        />
      </div>

      <div>
        <label>Is developer?</label>
        <input type="checkbox" {...register('isDeveloper')} />
      </div>

      <div>
        <label>Age group</label>
        <select {...register('ageGroup')}>
          <option value="0">0 - 1</option>
          <option value="1">1 - 100</option>
        </select>
      </div>
      <button
        type="button"
        onClick={() => {
          setValue('firstName', 'Set value by action');
          setValue('ageGroup', '1');
          setValue('isDeveloper', true);
        }}
      >
        Set All Values
      </button>
      <button type="submit">Submit</button>
    </form>
  );
}


================================================
File: /examples/V6/asyncSubmitValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export default function App() {
  const { register, handleSubmit, errors, setError } = useForm();
  const onSubmit = async (data) => {
    await sleep(2000);
    if (data.username === 'bill') {
      alert(JSON.stringify(data));
    } else {
      alert('There is error');
      setError('username', 'validate');
    }
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="username">User Name</label>
          <input name="username" placeholder="Bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="Luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="text"
            ref={register}
          />
        </div>

        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/customMaskedInputWithController.tsx
================================================
import React from 'react';
import MaskedInput from 'react-input-mask';
import { useForm, Controller } from 'react-hook-form';

import './styles.css';

export const clearTel = (tel) => tel.replace(/[^0-9]/g, '');

const isNotFilledTel = (v) => {
  const clearedTel = clearTel(v);
  return clearedTel.length < 11 ? 'Phone number is required.' : undefined;
};

const Input = (props) => {
  const { onChange, ...restProps } = props;
  return <input {...restProps} onChange={onChange} />;
};

const CustomMaskedInput = (props) => {
  const { value, onChange, name } = props;
  return (
    <MaskedInput
      name={name}
      value={value}
      mask="+7 (999) 999-99-99"
      maskPlaceholder={'_'}
      alwaysShowMask
      onChange={(e) => {
        e.persist();
        onChange(e.target.value);
      }}
    >
      <Input type="text" autoComplete="tel-national" />
    </MaskedInput>
  );
};

const onSubmit = (data) => {
  console.log('submit', data);
};

export default function App() {
  const { handleSubmit, errors, control } = useForm({
    reValidateMode: 'onSubmit',
  });
  const [tel, setTel] = React.useState('7');
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <Controller
            as={<CustomMaskedInput />}
            value={tel}
            onChange={([e]) => {
              setTel(e);
              return { value: e };
            }}
            rules={{
              validate: {
                inputTelRequired: isNotFilledTel,
              },
            }}
            defaultValue={tel}
            name="ControlledMaskedInput"
            control={control}
          />

          {errors.ControlledMaskedInput && (
            <p>{errors.ControlledMaskedInput.message}</p>
          )}
        </div>
        <input type="submit" />
      </form>
    </div>
  );
}


================================================
File: /examples/V6/dirtyTouchedSubmitted.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, formState } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(formState);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First name</label>
        <input type="text" name="First name" ref={register} />
      </div>
      <div>
        <label>Last name</label>
        <input type="text" name="Last name" ref={register} />
      </div>
      <div>
        <label>Email</label>
        <input type="text" name="Email" ref={register} />
      </div>
      <div>
        <label>Mobile number</label>
        <input type="tel" name="Mobile number" ref={register} />
      </div>
      <div>
        <label>Title</label>
        <select name="Title" ref={register}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input name="developer" type="radio" value="Yes" ref={register} />
        <input name="developer" type="radio" value="No" ref={register} />
      </div>

      <pre>{JSON.stringify(formState, null, 2)}</pre>

      <input type="submit" />
    </form>
  );
}

ReactDOM.render(<Form />, rootElement);


================================================
File: /examples/V6/custom-masked-input.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export const maskPhoneNumber = (phone) => {
  //Example: 0(999) 999 99 99
  const x = phone
    .replace(/\D/g, '')
    .match(/(\d?)(\d{0,3})(\d{0,3})(\d{0,2})(\d{0,2})/);
  return !x[3]
    ? x[1] + x[2]
    : `${x[1]}(${x[2]}) ${x[3]}${x[4] ? ` ${x[4]}` : ''}${
        x[5] ? ` ${x[5]}` : ''
      }`;
};

export default function App() {
  const { register, handleSubmit, setValue } = useForm();
  const onSubmit = (data) => console.log(data);

  return (
    <Form onSubmit={handleSubmit(onSubmit)}>
      <input
        type="tel"
        name="phoneNumber"
        ref={register}
        onChange={(e) =>
          setValue('phoneNumber', maskPhoneNumber(e.target.value))
        }
      />
      <button>Submit</button>
    </Form>
  );
}


================================================
File: /examples/V6/asyncFieldValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export default function App() {
  const { register, handleSubmit, errors } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="username">User Name</label>
          <input
            name="username"
            placeholder="Bill"
            ref={register({
              validate: async (value) => {
                await sleep(3000);
                return value === 'bill';
              },
            })}
          />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="Luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="text"
            ref={register}
          />
        </div>

        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/getValuesCompareFields.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, getValues, handleSubmit } = useForm();

  return (
    <div className="App">
      <h1>getValue - Compare Field Values</h1>
      <form onSubmit={handleSubmit((data) => console.log(data))}>
        <label>New Password: </label>
        <input
          name="password"
          ref={register({ required: 'Password is required!' })}
        />
        {errors.password && (
          <p style={{ color: 'white' }}>{errors.password.message}</p>
        )}

        <label>Confirm Password: </label>
        <input
          name="passwordConfirmation"
          ref={register({
            required: 'Please confirm password!',
            validate: {
              matchesPreviousPassword: (value) => {
                const { password } = getValues();
                return password === value || 'Passwords should match!';
              },
            },
          })}
        />
        {errors.passwordConfirmation && (
          <p style={{ color: 'white' }}>
            {errors.passwordConfirmation.message}
          </p>
        )}

        <button type="submit">Trigger</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/normalizeField.tsx
================================================
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import NumberFormat from 'react-number-format';
import { TextField, ThemeProvider, createMuiTheme } from '@material-ui/core';

const theme = createMuiTheme({
  palette: {
    type: 'dark',
  },
});
const defaultValues = {
  priceInCents: 1234567,
  muiPriceInCents: 1234567,
};
function App() {
  const form = useForm({ defaultValues });

  const onSubmit = (data) => {
    form.reset(defaultValues);
  };

  return (
    <ThemeProvider theme={theme}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <label htmlFor="priceInCents">Price</label>
        <label htmlFor="muiPriceInCents">Material UI Price</label>
        <Controller
          name="muiPriceInCents"
          control={form.control}
          render={(props) => <MuiCurrencyFormat {...props} />}
        />

        <input type="submit" />
        <input
          style={{ display: 'block', marginTop: 20 }}
          type="button"
          onClick={() => form.reset(defaultValues)}
          value="Custom Reset"
        />

        <pre style={{ color: '#fff', marginTop: 24 }}>
          {JSON.stringify(form.watch(), null, 2)}
        </pre>
      </form>
    </ThemeProvider>
  );
}

const MuiCurrencyFormat = (props) => {
  const { onChange, value, ...rest } = props;

  return (
    <NumberFormat
      customInput={TextField}
      {...rest}
      value={value}
      fullWidth
      thousandSeparator={true}
      decimalScale={2}
      onValueChange={(target) => {
        onChange(target.floatValue);
      }}
      isNumericString
      prefix="$ "
    />
  );
};


================================================
File: /examples/V6/nativeMultipleInput.tsx
================================================
import React from 'react';
import { useForm, NestedValue } from 'react-hook-form';

export default function App() {
  const { register, errors, handleSubmit } = useForm<{
    email: NestedValue<string[]>;
  }>({
    defaultValues: {
      email: ['first@react.hook.form', 'last@react.hook.form'],
    },
  });

  const onSubmit = handleSubmit<{ email: string }>((data) => {
    alert(JSON.stringify(data));
  });

  return (
    <form onSubmit={onSubmit}>
      <label>Native Multiple Input</label>
      <input
        multiple
        type="email"
        name="email"
        list="email"
        ref={register({ required: 'This is required.' })}
      />
      <datalist id="email">
        <option value="first@react.hook.form" />
        <option value="second@react.hook.form" />
        <option value="third@react.hook.form" />
        <option value="last@react.hook.form" />
      </datalist>
      {errors?.email && <p>{errors.email.message}</p>}

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/resetForm.tsx
================================================
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, reset } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data, e) => {
    e.target.reset(); // reset after form submit
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First name</label>
        <input
          type="text"
          name="First name"
          ref={register({ required: true })}
        />
      </div>
      <div>
        <label>Last name</label>
        <input type="text" name="Last name" ref={register} />
      </div>
      <div>
        <label>Email</label>
        <input type="text" name="Email" ref={register} />
      </div>
      <div>
        <label>Mobile number</label>
        <input type="tel" name="Mobile number" ref={register} />
      </div>
      <div>
        <label>Title</label>
        <select name="Title" ref={register}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input name="developer" type="radio" value="Yes" ref={register} />
        <input name="developer" type="radio" value="No" ref={register} />
      </div>

      <input type="submit" />
      <input
        style={{ display: 'block', marginTop: 20 }}
        type="reset"
        value="Standard Reset Field Values"
      />
      <input
        style={{ display: 'block', marginTop: 20 }}
        type="reset"
        onClick={reset}
        value="Custom Reset Field Values & Errors"
      />
    </form>
  );
}

ReactDOM.render(<Form />, rootElement);


================================================
File: /examples/V6/typescript/Resolver.tsx
================================================
import React from 'react';
import { useForm, Resolver } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
};

const resolver: Resolver<FormValues> = async (values) => {
  return {
    values: !values.firstName ? {} : values,
    errors: !values.firstName
      ? {
          firstName: {
            type: 'required',
            message: 'This is required.',
          },
        }
      : {},
  };
};

export default function App() {
  const { register, handleSubmit, errors } = useForm<FormValues>({
    resolver: resolver,
  });
  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>First Name</label>
        <input name="firstName" ref={register} />
        {errors?.firstName && <p>{errors.firstName.message}</p>}
      </div>

      <div>
        <label>Last Name</label>
        <input name="lastName" ref={register} />
      </div>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/typescript/NestedValue.tsx
================================================
import React, { useEffect } from 'react';
import { useForm, NestedValue } from 'react-hook-form';
import {
  TextField,
  FormControl,
  Select,
  MenuItem,
  FormHelperText,
} from '@material-ui/core';
import { Autocomplete } from '@material-ui/lab';

type Option = {
  label: string;
  value: string;
};

const options = [
  { label: 'Chocolate', value: 'chocolate' },
  { label: 'Strawberry', value: 'strawberry' },
  { label: 'Vanilla', value: 'vanilla' },
];

export default function App() {
  const { register, handleSubmit, watch, setValue, errors } = useForm<{
    autocomplete: NestedValue<Option[]>;
    select: NestedValue<number[]>;
  }>({
    defaultValues: { autocomplete: [], select: [] },
  });
  const select = watch('select');

  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  useEffect(() => {
    register('autocomplete', {
      validate: (value) => value.length || 'This is required.',
    });
    register('select', {
      validate: (value) => value.length || 'This is required.',
    });
  }, [register]);

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>MUI Autocomplete</label>
        <Autocomplete
          multiple
          options={options}
          getOptionLabel={(option: Option) => option.label}
          onChange={(e, options) => setValue('autocomplete', options)}
          renderInput={(params) => (
            <TextField
              {...params}
              error={Boolean(errors?.autocomplete)}
              helperText={errors?.autocomplete?.message}
            />
          )}
        />
      </div>
      <div>
        <label>MUI Select</label>
        <FormControl>
          <Select
            multiple
            value={select}
            onChange={(e) => setValue('muiSelect', e.target.value as number[])}
            error={Boolean(errors?.select)}
          >
            <MenuItem value={10}>Ten</MenuItem>
            <MenuItem value={20}>Twenty</MenuItem>
            <MenuItem value={30}>Thirty</MenuItem>
          </Select>
          <FormHelperText error={Boolean(errors?.select)}>
            {errors?.select?.message}
          </FormHelperText>
        </FormControl>
      </div>

      <input type="submit" className="button" />
    </form>
  );
}


================================================
File: /examples/V6/typescript/UseFormMethods.tsx
================================================
import React from 'react';
import { useForm, UseFormMethods, SubmitHandler } from 'react-hook-form';

type InputProps = React.DetailedHTMLProps<
  React.InputHTMLAttributes<HTMLInputElement>,
  HTMLInputElement
>;

const Input = React.forwardRef<HTMLInputElement, InputProps>((props, ref) => (
  <input ref={ref} {...props} />
));

type Option = {
  label: React.ReactNode;
  value: string | number | string[];
};

type SelectProps = React.DetailedHTMLProps<
  React.SelectHTMLAttributes<HTMLSelectElement>,
  HTMLSelectElement
> & { options: Option[] };

const Select = React.forwardRef<HTMLSelectElement, SelectProps>(
  ({ options, ...props }, ref) => (
    <select ref={ref} {...props}>
      {options.map(({ label, value }) => (
        <option value={value}>{label}</option>
      ))}
    </select>
  ),
);

type FormProps<TFormValues> = {
  onSubmit: SubmitHandler<TFormValues>;
  children: (methods: UseFormMethods<TFormValues>) => React.ReactNode;
};

const Form = <TFormValues extends Record<string, any> = Record<string, any>>({
  onSubmit,
  children,
}: FormProps<TFormValues>) => {
  const methods = useForm<TFormValues>();
  return (
    <form onSubmit={methods.handleSubmit(onSubmit)}>{children(methods)}</form>
  );
};

type FormValues = {
  firstName: string;
  lastName: string;
  gender: string;
};

export default function App() {
  const onSubmit = (data: FormValues) => alert(JSON.stringify(data));

  return (
    <Form<FormValues> onSubmit={onSubmit}>
      {({ register }) => (
        <>
          <Input name="firstName" ref={register} />
          <Input name="lastName" ref={register} />
          <Select
            name="gender"
            ref={register}
            options={[
              { label: 'Female', value: 'female' },
              { label: 'Male', value: 'male' },
              { label: 'Other', value: 'other' },
            ]}
          />
          <Input type="submit" />
        </>
      )}
    </Form>
  );
}


================================================
File: /examples/V6/typescript/SubmitHandler.tsx
================================================
import React from 'react';
import { useForm, SubmitHandler } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
  email: string;
};

export default function App() {
  const { register, handleSubmit } = useForm<FormValues>();
  const onSubmit: SubmitHandler<FormValues> = (data) =>
    alert(JSON.stringify(data));

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First Name</label>
        <input name="firstName" ref={register} />
      </div>

      <div>
        <label>Last Name</label>
        <input name="lastName" ref={register} />
      </div>

      <div>
        <label htmlFor="email">Email</label>
        <input name="email" type="email" ref={register} />
      </div>

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/typescript/Control.tsx
================================================
import React from 'react';
import { useForm, useWatch, Control } from 'react-hook-form';

type FormValues = {
  firstName: string;
  lastName: string;
};

function IsolateReRender({ control }: { control: Control }) {
  const firstName = useWatch<FormValues['firstName']>({
    control,
    name: 'firstName',
    defaultValue: 'default',
  });

  return <div>{firstName}</div>;
}

export default function App() {
  const { register, control, handleSubmit } = useForm<FormValues>();
  const onSubmit = handleSubmit((data) => alert(JSON.stringify(data)));

  return (
    <form onSubmit={onSubmit}>
      <div>
        <label>First Name</label>
        <input ref={register} name="firstName" />
      </div>
      <div>
        <label>Last Name</label>
        <input ref={register} name="lastName" />
      </div>
      <IsolateReRender control={control} />

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/defaultValues.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm({
    defaultValues: {
      firstName: 'bill',
      lastName: 'luo',
      email: 'test@test.com',
      isDeveloper: true,
    },
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input name="firstName" placeholder="bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>

        <div>
          <label>Is developer?</label>
          <input name="isDeveloper" type="checkbox" ref={register} />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/validationOnFieldChange.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, handleSubmit } = useForm({
    mode: 'onChange',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            name="firstName"
            placeholder="bill"
            ref={register({ required: true })}
          />
          {errors.firstName && 'This is required'}
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            name="lastName"
            placeholder="luo"
            ref={register({ required: true })}
          />
          {errors.lastName && 'This is required'}
        </div>

        <div>
          <label htmlFor="email" placeholder="bluebill1049@hotmail.com">
            Email
          </label>
          <input name="email" ref={register({ required: true })} />
          {errors.email && 'This is required'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/remoteTriggerFormSubmit.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input name="firstName" placeholder="bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>
      </form>

      <button type="button" onClick={handleSubmit(onSubmit)}>
        submit button outside of form
      </button>
    </div>
  );
}


================================================
File: /examples/V6/customInput.tsx
================================================
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';
import Input from '@material-ui/core/Input';
import Select from 'react-select';
import { Input as StrapInput } from 'reactstrap';

const options = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
];

const MyInput = ({ name, label, register }) => {
  return (
    <>
      <label htmlFor={name}>{label}</label>
      <input name={name} placeholder="Jane" ref={register} />
    </>
  );
};

export default function App() {
  const { register, handleSubmit, setValue } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data, null));
  };
  const [values, setReactSelect] = useState({
    selectedOption: [],
  });

  const handleMultiChange = (selectedOption) => {
    setValue('reactSelect', selectedOption);
    setReactSelect({ selectedOption });
  };

  useEffect(() => {
    register({ name: 'reactSelect' });
  }, []);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <Input
            style={{
              marginBottom: '20px',
            }}
            name="HelloWorld"
            inputRef={register}
            placeholder="Material UI - Input"
            inputProps={{
              'aria-label': 'Description',
            }}
          />
        </div>

        <div>
          <StrapInput
            placeholder="Strap - Input"
            name="strapInput"
            innerRef={register}
          />
        </div>

        <div>
          <label className="reactSelectLabel">React select</label>
          <Select
            className="reactSelect"
            name="filters"
            placeholder="Filters"
            value={values.selectedOption}
            options={options}
            onChange={handleMultiChange}
            isMulti
          />
        </div>

        <div>
          <MyInput name="firstName" label="First Name" register={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="Luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/conditionalFields.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, watch, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  const moreDetail = watch('moreDetail');

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input name="firstName" placeholder="Bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="Luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>

        <div>
          <label htmlFor="lastName">More Details</label>
          <input name="moreDetail" type="checkbox" ref={register} />
        </div>

        {moreDetail && (
          <div>
            <label>Interests</label>
            <input type="text" name="Interests" ref={register} />
          </div>
        )}
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/customValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, errors } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };
  const initialValues = {
    firstName: 'bill',
    lastName: 'luo',
    email: 'bluebill1049@hotmail.com',
    age: -1,
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            defaultValue={initialValues.firstName}
            name="firstName"
            placeholder="bill"
            ref={register({
              validate: (value) => value !== 'bill',
            })}
          />
        </div>
        {errors.firstName && <p>Your name is not bill</p>}

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            defaultValue={initialValues.lastName}
            name="lastName"
            placeholder="luo"
            ref={register({
              validate: (value) => value.length > 3,
            })}
          />
        </div>
        {errors.lastName && <p>Your last name is less than 3 characters</p>}

        <div>
          <label htmlFor="email">Email</label>
          <input
            defaultValue={initialValues.email}
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>

        <div>
          <label htmlFor="age">Age</label>
          <input
            defaultValue={initialValues.age}
            name="age"
            placeholder="0"
            type="text"
            ref={register({
              validate: {
                positiveNumber: (value) => parseFloat(value) > 0,
                lessThanHundred: (value) => parseFloat(value) <= 150,
              },
            })}
          />
        </div>
        {errors.age && errors.age.type === 'positiveNumber' && (
          <p>Your age is invalid</p>
        )}
        {errors.age && errors.age.type === 'lessThanHundred' && (
          <p>
            Your age is higher than 150. No one is that old, are you a vampire?
          </p>
        )}

        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/disableNativeValidation.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export default function App() {
  const { errors, handleSubmit, register } = useForm();

  const onSubmit = (data) => {
    console.log({ data });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} noValidate>
      <label htmlFor="email">Email</label>
      <input
        name="email"
        type="email"
        ref={register({
          required: 'Email is required',
          validate: (value) =>
            value.includes('@') || "Email must include '@' symbol",
        })}
      />
      {errors.email && errors.email.message}
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/registerWithErrorMessages.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <label htmlFor="firstName">First Name</label>
        <input
          name="firstName"
          placeholder="Bill"
          ref={register({
            required: 'this is a required',
            maxLength: {
              value: 2,
              message: 'Max length is 2',
            },
          })}
        />
        <br />
        {errors.firstName && errors.firstName.message}
        <br />

        <label htmlFor="lastName">Last Name</label>
        <input
          name="lastName"
          placeholder="Luo"
          ref={register({
            required: 'this is required',
            minLength: {
              value: 2,
              message: 'Min length is 2',
            },
          })}
        />
        <br />
        {errors.lastName && errors.lastName.message}
        <br />

        <label htmlFor="email">Email</label>
        <input
          name="email"
          placeholder="bluebill1049@hotmail.com"
          type="text"
          ref={register({
            required: 'this is required',
            pattern: {
              value:
                /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/,
              message: 'Invalid email address',
            },
          })}
        />
        <br />
        {errors.email && errors.email.message}
        <br />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/initalFormState.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

import './styles.css';

const defaultValues = {
  firstName: 'bill',
  lastName: 'luo',
  email: 'bluebill1049@hotmail.com',
};

function App() {
  const { register, handleSubmit } = useForm();
  // or you can set up the defaultValues at useForm
  // const { register, handleSubmit } = useForm({
  //   defaultValues,
  // });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <label htmlFor="firstName">First Name</label>
      <input
        defaultValue={defaultValues.firstName}
        name="firstName"
        placeholder="bill"
        ref={register}
      />

      <label htmlFor="lastName">Last Name</label>
      <input
        defaultValue={defaultValues.lastName}
        name="lastName"
        placeholder="luo"
        ref={register}
      />

      <label htmlFor="email">Email</label>
      <input
        defaultValue={defaultValues.email}
        name="email"
        placeholder="bluebill1049@hotmail.com"
        type="email"
        ref={register}
      />

      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/formProvider.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm, FormProvider, useFormContext } from 'react-hook-form';

export default function App() {
  const methods = useForm();
  const { register, handleSubmit } = methods;
  return (
    <FormProvider {...methods}>
      <form onSubmit={handleSubmit((data) => console.log(data))}>
        <label>Test</label>
        <input name="test" ref={register({ required: true })} />
        <label>Nested Input</label>
        <Test />
        <input type="submit" />
      </form>
    </FormProvider>
  );
}

function Test() {
  const data = useFormContext();
  return <input name="bill" ref={data.register} />;
}


================================================
File: /examples/V6/nestedFields.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';
import FormSection1 from './formSection1';
import FormSection2 from './formSection2';

export default function Section1({ register }) {
  return (
    <>
      <div>
        <label>First name</label>
        <input
          type="text"
          name="First name"
          ref={register({ required: true, maxLength: 80 })}
        />
      </div>
      <div>
        <label>Last name</label>
        <input
          type="text"
          name="Last name"
          ref={register({ required: true, maxLength: 100 })}
        />
      </div>
    </>
  );
}

export default function formSection2({ register }) {
  return (
    <>
      <div>
        <label>Email</label>
        <input
          type="text"
          name="Email"
          ref={register({
            required: true,
            pattern:
              /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
          })}
        />
      </div>
      <div>
        <label>Mobile number</label>
        <input
          type="tel"
          name="Mobile number"
          ref={register({ required: true, maxLength: 11, minLength: 8 })}
        />
      </div>
      <div>
        <label>Title</label>
        <select name="Title" ref={register({ required: true })}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input
          name="developer"
          type="radio"
          value="Yes"
          ref={register({ required: true })}
        />
        <input
          name="developer"
          type="radio"
          value="No"
          ref={register({ required: true })}
        />
      </div>
    </>
  );
}

export default function App() {
  const { register, errors, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };
  console.log(errors);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <FormSection1 register={register} />
      <FormSection2 register={register} />
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/triggerFieldValidation.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, trigger } = useForm();

  console.log('errors', errors);

  return (
    <div className="App">
      <h1>validationField</h1>
      <label>First name: </label>
      <input name="firstName" ref={register({ required: true })} />

      <label>Last name: </label>
      <input name="lastName" ref={register({ required: true })} />

      <button
        type="button"
        onClick={async () => {
          const result = await trigger(['firstName', 'lastName']);
          if (result) {
            console.log('Valid input');
          }
        }}
      >
        Trigger
      </button>
    </div>
  );
}


================================================
File: /examples/V6/validationSchema.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';
import * as yup from 'yup'; // you will have to install yup

const SignupSchema = yup.object().shape({
  firstName: yup.string().required(),
  age: yup.number().required().positive().integer(),
  website: yup.string().url(),
});

export default function App() {
  const { register, handleSubmit, errors } = useForm({
    validationSchema: SignupSchema,
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Develop?</label>
        Yes
        <input type="radio" name="test" value="yes" ref={register} />
        No
        <input type="radio" name="test" value="no" ref={register} />
      </div>
      <div>
        <label>First Name</label>
        <input type="text" name="firstName" ref={register} />
      </div>
      <div>
        <label>Last Name</label>
        <input type="text" name="lastName" ref={register} />
      </div>
      <div>
        <label>Age</label>
        <input type="text" name="age" ref={register} />
      </div>
      <div>
        <label>Website</label>
        <input type="text" name="website" ref={register} />
      </div>

      <div style={{ color: 'red' }}>
        <pre>
          {Object.keys(errors).length > 0 && (
            <label>Errors: {JSON.stringify(errors, null, 2)}</label>
          )}
        </pre>
      </div>
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/forwardRefToPassRefProp.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

const Input = React.forwardRef(({ name }, ref) => {
  return <input ref={ref} name={name} />;
});

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data, event) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Input ref={register} name="firstName" />
      <Input ref={register} name="lastName" />

      <button>Submit</button>
    </form>
  );
}


================================================
File: /examples/V6/basicValidation.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };
  console.log(errors);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>First name</label>
        <input
          type="text"
          name="First name"
          ref={register({ required: true, maxLength: 80 })}
        />
      </div>
      <div>
        <label>Last name</label>
        <input
          type="text"
          name="Last name"
          ref={register({ required: true, maxLength: 100 })}
        />
      </div>
      <div>
        <label>Email</label>
        <input
          type="text"
          name="Email"
          ref={register({
            required: true,
            pattern:
              /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
          })}
        />
      </div>
      <div>
        <label>Mobile number</label>
        <input
          type="tel"
          name="Mobile number"
          ref={register({ required: true, maxLength: 11, minLength: 8 })}
        />
      </div>
      <div>
        <label>Title</label>
        <select name="Title" ref={register({ required: true })}>
          <option value="Mr">Mr</option>
          <option value="Mrs">Mrs</option>
          <option value="Miss">Miss</option>
          <option value="Dr">Dr</option>
        </select>
      </div>

      <div>
        <label>Are you a developer?</label>
        <input type="radio" value="Yes" ref={register({ required: true })} />
        <input type="radio" value="No" ref={register({ required: true })} />
      </div>

      <div>
        <input type="text" name="asdasd" ref={register} />
      </div>

      <input type="submit" />
    </form>
  );
}

ReactDOM.render(<Form />, rootElement);


================================================
File: /examples/V6/parseFormatInputValues.tsx
================================================
import React from 'react';
import { Controller, useForm } from 'react-hook-form';

const ParseFormatTextarea = ({ value = [], onChange }) => {
  const [text, setText] = React.useState(value);

  const handleChange = (e) => {
    const value = e.target.value.split('\n');

    setText(e.target.value);
    onChange(value);
  };

  return <textarea onChange={handleChange} value={text} />;
};

export default function App() {
  const { control, handleSubmit } = useForm();
  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="emails"
        as={ParseFormatTextarea}
        control={control}
        defaultValue={[]}
      />

      <Controller
        name="number"
        render={({ value, onChange }) => (
          <input
            type="number"
            value={value}
            onChange={(e) => onChange(parseInt(e.target.value, 10))}
          />
        )}
        control={control}
        defaultValue={0}
      />

      <button type="submit">Submit</button>
    </form>
  );
}


================================================
File: /examples/V6/asyncSetFormValues.tsx
================================================
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, reset } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  useEffect(() => {
    // you can do async server request and fill up form
    setTimeout(() => {
      reset({
        firstName: 'bill',
        lastName: 'luo',
      });
    }, 2000);
  }, [reset]);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h1>Async Set Form Values</h1>
      <label>First name</label>
      <input name="firstName" ref={register} />

      <label>Last name</label>
      <input name="lastName" ref={register} />
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/FieldArray.tsx
================================================
import React, { useState } from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

function createArrayWithNumbers(length) {
  return Array.from({ length }, (_, k) => k);
}

export default function App() {
  const { register, handleSubmit, errors } = useForm();
  const [size, setSize] = useState(1);
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  console.log(errors);

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        {createArrayWithNumbers(size).map((number) => {
          return (
            <div key={number}>
              <div>
                <label htmlFor="firstName">First Name</label>
                <input
                  name={`firstName[${number}]`}
                  placeholder="first name"
                  ref={register({ required: true })}
                />
              </div>

              <div>
                <label htmlFor="lastName">Last Name</label>
                <input
                  name={`lastName[${number}]`}
                  placeholder="last name"
                  ref={register({ required: true })}
                />
              </div>

              <div>
                <label htmlFor="email">Email</label>
                <input
                  name={`email[${number}]`}
                  placeholder="email"
                  ref={register({ required: true })}
                />
              </div>

              <hr />
            </div>
          );
        })}

        <button type="button" onClick={() => setSize(size + 1)}>
          Add Person
        </button>
        <br />
        <div style={{ color: 'red' }}>
          {Object.keys(errors).length > 0 &&
            'There are errors, check your console.'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/validationOnFieldBlur.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, errors, handleSubmit } = useForm({
    mode: 'onBlur',
  });
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input
            name="firstName"
            placeholder="bill"
            ref={register({ required: true })}
          />
          {errors.firstName && 'This is required'}
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input
            name="lastName"
            placeholder="luo"
            ref={register({ required: true })}
          />
          {errors.lastName && 'This is required'}
        </div>

        <div>
          <label htmlFor="email" placeholder="bluebill1049@hotmail.com">
            Email
          </label>
          <input name="email" ref={register({ required: true })} />
          {errors.email && 'This is required'}
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/README.md
================================================
# Examples

You can view the source code for most examples within their folder, or visit Code Sandbox to see how the example works live.

- V6
- [V7](/examples)

| Name                                    | Link                                                                                 |
| --------------------------------------- | ------------------------------------------------------------------------------------ |
| Async Submit Validation                 | https://codesandbox.io/s/xrjv48o0qp                                                  |
| Async Set Form Values                   | https://codesandbox.io/s/react-hook-from-async-set-form-values-ztpd6                 |
| Async Field Validation                  | https://codesandbox.io/s/m5pj55yj7x                                                  |
| Array of Field Array                    | https://codesandbox.io/s/react-hook-form-usefieldarray-nested-arrays-x7btr           |
| Basic                                   | https://codesandbox.io/s/yj07z1639                                                   |
| Basic Validation                        | https://codesandbox.io/s/rwpz2jn6ln                                                  |
| Custom Validation                       | https://codesandbox.io/s/8n937m64o9                                                  |
| Conditional Fields                      | https://codesandbox.io/s/13ykqx4wx7                                                  |
| Custom Input                            | https://codesandbox.io/s/72j69vnk1x                                                  |
| Custom Input with ForwardRef            | https://codesandbox.io/s/rhfex-en254                                                 |
| Custom Masked Input with Controller     | https://codesandbox.io/s/morning-sunset-8n3sx                                        |
| Custom Masked Input with Tel Number     | https://codesandbox.io/s/react-hook-form-gv5su                                       |
| Controller (MUI, React-Select and etc)  | https://codesandbox.io/s/react-hook-form-controller-079xx                            |
| Controller modify return value          | https://codesandbox.io/s/react-hook-form-v6-customise-controller-return-value-jopm9  |
| Checkbox minimum checked (Native)       | https://codesandbox.io/s/checkbox-min-checked-5vocd                                  |
| Compare Field Values                    | https://codesandbox.io/s/react-hook-form-getvalues-compare-field-values-qrtvx        |
| DefaultValues                           | https://codesandbox.io/s/react-hook-form-defaultvalues-n5gvx                         |
| Default/Initial Form Value              | https://codesandbox.io/s/l3mxpvmm9                                                   |
| Dirty/Touched/Submitted                 | https://codesandbox.io/s/7o2wrp86k6                                                  |
| Disable Native Validation               | https://codesandbox.io/s/keen-mccarthy-4pqn6                                         |
| Field Array                             | https://codesandbox.io/s/6j1760jkjk                                                  |
| Field Array Min Length                  | https://codesandbox.io/s/react-hook-form-fieldsarray-yup-validation-min-length-57qtb |
| FormProvider                            | https://codesandbox.io/s/react-hook-form-form-context-dkvjz                          |
| Parse and format input value            | https://codesandbox.io/s/react-hook-form-parse-and-format-textarea-furtc             |
| Persist input value on onUnmount        | https://codesandbox.io/s/headless-sound-wgetb                                        |
| Modal/Toggle input                      | https://codesandbox.io/s/react-hook-form-conditional-inputs-c7n0r                    |
| Nested Fields                           | https://codesandbox.io/s/react-hook-form-nested-fields-mv1bb                         |
| Normalize/Format/Mask Field             | https://codesandbox.io/s/react-hook-form-normalize-field-forked-01lgs                |
| Format/Mask Field (Third Party Library) | https://codesandbox.io/s/react-hook-form-normalize-field-1jumn                       |
| Native Validation                       | https://codesandbox.io/s/react-hook-form-native-validation-ez5ww                     |
| Reset Form                              | https://codesandbox.io/s/jjm3wyqmjy                                                  |
| Remote/Trigger Form Submit              | https://codesandbox.io/s/remote-handlesubmit-w0win                                   |
| Register Error Messages                 | https://codesandbox.io/s/o766kp4z05                                                  |
| Set input/select value                  | https://codesandbox.io/s/react-hook-form-set-inputselect-value-c46ly                 |
| Set input/select Error                  | https://codesandbox.io/s/o7rxyym3q5                                                  |
| Tabs Form (MUI)                         | https://codesandbox.io/s/tabs-760h9                                                  |
| Trigger field validation                | https://codesandbox.io/s/react-hook-form-trigger-validation-w1g0m                    |
| ValidationSchema                        | https://codesandbox.io/s/928po918qr                                                  |
| Validation On Blur                      | https://codesandbox.io/s/w7p3km6nyw                                                  |
| Validation On Change                    | https://codesandbox.io/s/74zw1oqozx                                                  |
| Wizard (funnel / multi-step) form       | https://codesandbox.io/s/react-hook-form-wizard-form-13yud                           |
| Native Multiple Input                   | https://codesandbox.io/s/react-hook-form-native-multiple-input-tyhue                 |

## Types

The following table contains a list of support Types in this library.

| Type Name     | Link                                                          |
| ------------- | ------------------------------------------------------------- |
| NestedValue   | https://codesandbox.io/s/react-hook-form-nestedvalue-dujyc    |
| SubmitHandler | https://codesandbox.io/s/react-hook-form-submithandler-kfmqy  |
| Resolver      | https://codesandbox.io/s/react-hook-form-resolver-juwui       |
| UseFormReturn | https://codesandbox.io/s/react-hook-form-useformmethods-mycp2 |
| Control       | https://codesandbox.io/s/react-hook-form-control-yq73k        |


================================================
File: /examples/V6/basic.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input name="firstName" placeholder="bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/V6/persistInputOnUnmount.tsx
================================================
import React from 'react';
import { useForm, useWatch } from 'react-hook-form';

function useInputCache(values, causeField, effectField, callback) {
  const [effectCache, setEffectCache] = React.useState(values[effectField]);

  const evaluateRegStatus = (vals, currentState) => {
    // check if field is registered (naive implementation for demonstration)
    const isRegistered = !!vals[causeField];
    return {
      isRegistered,
      registrationStatusChanged: isRegistered !== currentState,
      hasValue: vals[effectField] !== undefined,
    };
  };

  // use ref to track registration state across renders
  const currentRegState = React.useRef(false);

  React.useEffect(() => {
    const { isRegistered, registrationStatusChanged, hasValue } =
      evaluateRegStatus(values, currentRegState.current);

    if (registrationStatusChanged && hasValue) {
      if (isRegistered && !!effectCache) {
        console.debug('Deploying cache');
        callback(effectField, effectCache);
      } else if (!isRegistered) {
        console.debug('Caching before unmount');
        setEffectCache(values[effectField]);
      }
      currentRegState.current = !!isRegistered;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [values, causeField, effectField, callback]);
}

export default function App() {
  const { register, handleSubmit, setValue, control } = useForm({
    mode: 'onChange',
    defaultValues: {
      name: '',
      check: false,
      optionalText: '',
    },
  });

  const values = useWatch({
    control,
  });
  useInputCache(values, 'check', 'optionalText', setValue);

  return (
    <div className="App">
      <h1>Here's a form with conditional fields.</h1>
      <form onSubmit={handleSubmit(console.log)}>
        <input
          name={'name'}
          type={'text'}
          ref={register({ required: true, min: 3 })}
          placeholder={'Enter a name'}
        />
        <br />
        <label htmlFor={'check'}>
          toggle field:
          <input
            name={'check'}
            type={'checkbox'}
            ref={register({ required: true })}
          />
        </label>
        <br />
        {values.check && (
          <input
            name={'optionalText'}
            ref={register({ required: false })}
            placeholder={'Mandatory when check=true'}
          />
        )}
      </form>
    </div>
  );
}


================================================
File: /examples/V6/fieldArrayMinLength.tsx
================================================
import React from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { object, array, string } from 'yup';
import { yupResolver } from '@hookform/resolvers';

const validationSchema = object().shape({
  questions: array()
    .of(
      object().shape({
        text: string().required('Some text is required'),
      }),
    )
    .required(),
});

function App() {
  const {
    control,
    register,
    errors,
    clearErrors,
    setValue,
    unregister,
    handleSubmit,
    trigger,
  } = useForm({
    mode: 'onChange',
    resolver: yupResolver(validationSchema),
  });
  const { fields, append, remove } = useFieldArray({
    control,
    name: 'questions',
  });

  const isInitialRender = React.useRef(true);
  const appendQuestion = () => {
    append({
      text: '',
    });

    if (errors.questions?.type === 'min') {
      clearErrors('questions'); // always clear errors when there is add action.
    }
  };

  React.useEffect(() => {
    if (!fields.length && !isInitialRender.current) {
      trigger('questions');
    }

    if (isInitialRender.current) {
      isInitialRender.current = false;
    }
  }, [fields, register, setValue, unregister, trigger]);

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <h1>Yup Validation - Field Array</h1>
      {fields.map((question, questionIndex) => (
        <div key={question.id}>
          <input
            ref={register()}
            name={`questions[${questionIndex}].text`}
            control={control}
            defaultValue=""
          />

          <button
            type="button"
            onClick={() => {
              remove(questionIndex);
              trigger();
            }}
          >
            Remove question {question.id}
          </button>
        </div>
      ))}
      <p>Errors: {JSON.stringify(errors)}</p>
      <button type="button" onClick={appendQuestion}>
        Add question
      </button>
      <input type="submit" />
    </form>
  );
}


================================================
File: /examples/V6/setValue.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom';
import { useForm } from 'react-hook-form';

export default function App() {
  const { register, handleSubmit, setValue } = useForm();
  const onSubmit = (data) => {
    alert(JSON.stringify(data));
  };

  return (
    <div className="App">
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <label htmlFor="firstName">First Name</label>
          <input name="firstName" placeholder="bill" ref={register} />
        </div>

        <div>
          <label htmlFor="lastName">Last Name</label>
          <input name="lastName" placeholder="luo" ref={register} />
        </div>

        <div>
          <label htmlFor="email">Email</label>
          <input
            name="email"
            placeholder="bluebill1049@hotmail.com"
            type="email"
            ref={register}
          />
        </div>

        <div>
          <label>Is developer?</label>
          <input name="isDeveloper" type="checkbox" ref={register} />
        </div>

        <div>
          <label>Age group</label>
          <select ref={register} name="ageGroup">
            <option value="0">0 - 1</option>
            <option value="1">1 - 100</option>
          </select>
        </div>
        <button
          type="button"
          onClick={() => {
            setValue('firstName', 'Set value by action');
            setValue('ageGroup', '1');
            setValue('isDeveloper', true);
          }}
        >
          Set All Values
        </button>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}


================================================
File: /examples/README.md
================================================
## Examples

You can view the source code for most examples within their folder, or visit Code Sandbox to see how the example works live.

- V7
- [V6](/examples/V6)

## Web

| Name                                   | Link                                                                                    |
| -------------------------------------- | --------------------------------------------------------------------------------------- |
| Async Submit Validation                | https://codesandbox.io/s/react-hook-form-async-submit-validation-hy9oe                  |
| Async Set Form Values                  | https://codesandbox.io/s/react-hook-from-async-set-form-values-tyk12                    |
| Async Field Validation                 | https://codesandbox.io/s/react-hook-form-async-field-validation-w1chw                   |
| Array of Field Array                   | https://codesandbox.io/s/react-hook-form-usefieldarray-nested-arrays-m8w6j              |
| Basic                                  | https://codesandbox.io/s/react-hook-form-basic-6mlii                                    |
| Basic Validation                       | https://codesandbox.io/s/react-hook-form-basic-validation-qdyye                         |
| Custom Validation                      | https://codesandbox.io/s/react-hook-form-custom-validation-8kuu7                        |
| Conditional Fields                     | https://codesandbox.io/s/react-hook-form-conditional-fields-qgr41                       |
| Custom Input                           | https://codesandbox.io/s/react-hook-form-custom-input-hmyeu                             |
| Controller (MUI, React-Select and etc) | https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5                            |
| Controller modify return value         | https://codesandbox.io/s/react-hook-form-v7-customise-controller-return-value-wuhrd     |
| Checkbox minimum checked (Native)      | https://codesandbox.io/s/checkbox-min-checked-forked-0tkjz                              |
| Compare Field Values                   | https://codesandbox.io/s/react-hook-form-getvalues-compare-field-values-orf0p           |
| DefaultValues                          | https://codesandbox.io/s/react-hook-form-defaultvalues-wv8c4                            |
| Default/Initial Form Value             | https://codesandbox.io/s/react-hook-form-defaultinitial-form-value-cujvt                |
| Dirty/Touched/Submitted                | https://codesandbox.io/s/react-hook-form-formstate-dirty-touched-submitted-forked-wjk0k |
| Dirty Fields Only Submitted            | https://codesandbox.io/s/react-hook-form-submit-only-dirty-fields-ol5d2                 |
| Disable Native Validation              | https://codesandbox.io/s/purple-glitter-4pgqq                                           |
| Field Array Min Length                 | https://codesandbox.io/s/react-hook-form-fieldsarray-yup-validation-min-length-k87iy    |
| Field Array Controlled                 | https://codesandbox.io/s/infallible-bush-c92l0                                          |
| Field Array Conditional                | https://codesandbox.io/s/react-hook-form-conditional-0g9qx                              |
| FormProvider                           | https://codesandbox.io/s/react-hook-form-form-context-2703c                             |
| Parse and format input value           | https://codesandbox.io/s/react-hook-form-parse-and-format-textarea-zbgog                |
| Modal/Toggle input                     | https://codesandbox.io/s/react-hook-form-modal-form-conditional-inputs-h09tf            |
| Nested Fields                          | https://codesandbox.io/s/react-hook-form-nested-fields-9xhg0                            |
| Nested Forms                           | https://codesandbox.io/s/react-hook-form-nested-portal-bw8m75                           |
| Normalize/Format/Mask Field            | https://codesandbox.io/s/react-hook-form-normalize-field-forked-jhrq9                   |
| Reset Form                             | https://codesandbox.io/s/react-hook-form-reset-form-r8z56                               |
| Remote/Trigger Form Submit             | https://codesandbox.io/s/remote-handlesubmit-ipbqb                                      |
| Register Error Messages                | https://codesandbox.io/s/react-hook-form-register-with-error-messages-h9m8p             |
| Set input/select value                 | https://codesandbox.io/s/react-hook-form-set-inputselect-value-forked-kh0mk             |
| Set input/select Error                 | https://codesandbox.io/s/react-hook-form-set-error-clear-error-rmtp1                    |
| Tabs Form (MUI)                        | https://codesandbox.io/s/tab-form-34oio                                                 |
| Trigger field validation               | https://codesandbox.io/s/react-hook-form-trigger-validation-utih0                       |
| ValidationSchema                       | https://codesandbox.io/s/react-hook-form-validationschema-v6-12p66                      |
| Validation On Blur / Change            | https://codesandbox.io/s/react-hook-form-validation-onblur-onchange-pnq16               |
| Wizard (funnel / multi-step) form      | https://codesandbox.io/s/react-hook-form-wizard-form-ir780                              |

## React Native

| Type Name  | Link                                                                |
| ---------- | ------------------------------------------------------------------- |
| Controller | https://snack.expo.io/@bluebill1049/react-hook-form-v7---controller |

## Types

The following table contains a list of support Types in this library.

| Type Name     | Link                                                              |
| ------------- | ----------------------------------------------------------------- |
| NestedValue   | https://codesandbox.io/s/react-hook-form-nestedvalue-forked-7bt6l |
| SubmitHandler | https://codesandbox.io/s/react-hook-form-submithandler-e2r3u      |
| Resolver      | https://codesandbox.io/s/react-hook-form-resolver-rvspp           |
| UseFormReturn | https://codesandbox.io/s/react-hook-form-useformmethods-e3411     |
| Control       | https://codesandbox.io/s/react-hook-form-control-forked-giq0e     |


================================================
File: /SECURITY.md
================================================
# Security Policy

## Supported Versions

currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| > 7.0   | :white_check_mark: |


================================================
File: /eslint.config.mjs
================================================
// @ts-check

import tseslint from 'typescript-eslint';
import reactPlugin from 'eslint-plugin-react';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import pluginCypress from 'eslint-plugin-cypress/flat';
import reactHookPlugin from "eslint-plugin-react-hooks";
import simpleImportSort from "eslint-plugin-simple-import-sort";
import { fixupPluginRules } from '@eslint/compat';

export default tseslint.config(
  {
    ignores: ["app", "examples", "node_modules", "dist", "coverage", "src/types/global.d.ts","!.*.js", "reports", "scripts/README"],
  },
  reactPlugin.configs.flat.recommended,
  ...tseslint.configs.recommended,
  eslintPluginPrettierRecommended,
  pluginCypress.configs.recommended,
  {
    plugins: {
      'react-hooks': fixupPluginRules(reactHookPlugin),
      "simple-import-sort": simpleImportSort
    },
    languageOptions: {
      ecmaVersion: 2020,
      sourceType: 'module',
      parserOptions: {
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    settings: {
      react: {
        pragma: 'React',
        version: 'detect',
      },
    },
    rules: {
      curly: 'error',
      'no-extra-boolean-cast': 'error',
      'cypress/unsafe-to-chain-command': 'off',
      '@typescript-eslint/no-non-null-assertion': 'off',
      '@typescript-eslint/no-empty-function': 'off',
      '@typescript-eslint/ban-ts-comment': 'warn',
      '@typescript-eslint/ban-types': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-unused-vars': [
        'warn',
        { ignoreRestSiblings: true },
      ],
      'cypress/no-unnecessary-waiting': 'off',
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'error',
      'react/display-name': 'warn',
      'react/prop-types': 'off',
      'no-console': ['error'],
      'simple-import-sort/imports': [
        'error',
        {
          groups: [
            // Side effect imports.
            ['^\\u0000'],
            // Packages. `react` related packages come first.
            ['^react', '^@?\\w'],
            // Parent imports. Put `..` last.
            ['^\\.\\.(?!/?$)', '^\\.\\./?$'],
            // Other relative imports. Put same-folder imports and `.` last.
            ['^\\./(?=.*/)(?!/?$)', '^\\.(?!/?$)', '^\\./?$'],
          ],
        },
      ],
      'simple-import-sort/exports': 'error',
    },
  },
  {
    files: ['*.test.ts', '*.test.tsx'],
    rules: {
      // Allow testing runtime errors to suppress TS errors
      '@typescript-eslint/ban-ts-comment': 'off',
    },
  },
);


================================================
File: /reports/api-extractor.md.api.md
================================================
## API Report File for "react-hook-form"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { JSXElementConstructor } from 'react';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';

// @public (undocumented)
export const appendErrors: (name: InternalFieldName, validateAllFieldCriteria: boolean, errors: InternalFieldErrors, type: string, message: ValidateResult) => {};

// Warning: (ae-forgotten-export) The symbol "ArrayPathInternal" needs to be exported by the entry point index.d.ts
//
// @public
export type ArrayPath<T> = T extends any ? ArrayPathInternal<T> : never;

// @public (undocumented)
export type BatchFieldArrayUpdate = <T extends Function, TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>>(name: InternalFieldName, updatedFieldArrayValues?: Partial<FieldArray<TFieldValues, TFieldArrayName>>[], method?: T, args?: Partial<{
    argA: unknown;
    argB: unknown;
}>, shouldSetValue?: boolean, shouldUpdateFieldsAndErrors?: boolean) => void;

// Warning: (ae-forgotten-export) The symbol "FileList_2" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "File_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type BrowserNativeObject = Date | FileList_2 | File_2;

// @public (undocumented)
export type ChangeHandler = (event: {
    target: any;
    type?: any;
}) => Promise<void | boolean>;

// @public (undocumented)
export type Control<TFieldValues extends FieldValues = FieldValues, TContext = any> = {
    _subjects: Subjects<TFieldValues>;
    _removeUnmounted: Noop;
    _names: Names;
    _state: {
        mount: boolean;
        action: boolean;
        watch: boolean;
    };
    _reset: UseFormReset<TFieldValues>;
    _options: UseFormProps<TFieldValues, TContext>;
    _getDirty: GetIsDirty;
    _resetDefaultValues: Noop;
    _formState: FormState<TFieldValues>;
    _updateValid: (shouldUpdateValid?: boolean) => void;
    _updateFormState: (formState: Partial<FormState<TFieldValues>>) => void;
    _fields: FieldRefs;
    _formValues: FieldValues;
    _proxyFormState: ReadFormState;
    _defaultValues: Partial<DefaultValues<TFieldValues>>;
    _getWatch: WatchInternal<TFieldValues>;
    _updateFieldArray: BatchFieldArrayUpdate;
    _getFieldArray: <TFieldArrayValues>(name: InternalFieldName) => Partial<TFieldArrayValues>[];
    _setErrors: (errors: FieldErrors<TFieldValues>) => void;
    _updateDisabledField: (props: {
        disabled?: boolean;
        name: FieldName<any>;
        value?: unknown;
    } & ({
        field?: Field;
        fields?: undefined;
    } | {
        field?: undefined;
        fields?: FieldRefs;
    })) => void;
    _executeSchema: (names: InternalFieldName[]) => Promise<{
        errors: FieldErrors;
    }>;
    register: UseFormRegister<TFieldValues>;
    handleSubmit: UseFormHandleSubmit<TFieldValues>;
    _disableForm: (disabled?: boolean) => void;
    unregister: UseFormUnregister<TFieldValues>;
    getFieldState: UseFormGetFieldState<TFieldValues>;
    setError: UseFormSetError<TFieldValues>;
};

// @public
export const Controller: <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: ControllerProps<TFieldValues, TName>) => ReactElement<unknown, string | JSXElementConstructor<any>>;

// @public (undocumented)
export type ControllerFieldState = {
    invalid: boolean;
    isTouched: boolean;
    isDirty: boolean;
    isValidating: boolean;
    error?: FieldError;
};

// @public
export type ControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    render: ({ field, fieldState, formState, }: {
        field: ControllerRenderProps<TFieldValues, TName>;
        fieldState: ControllerFieldState;
        formState: UseFormStateReturn<TFieldValues>;
    }) => React_2.ReactElement;
} & UseControllerProps<TFieldValues, TName>;

// @public (undocumented)
export type ControllerRenderProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    onChange: (...event: any[]) => void;
    onBlur: Noop;
    value: FieldPathValue<TFieldValues, TName>;
    disabled?: boolean;
    name: TName;
    ref: RefCallBack;
};

// @public (undocumented)
export type CriteriaMode = 'firstError' | 'all';

// @public (undocumented)
export type CustomElement<TFieldValues extends FieldValues> = Partial<HTMLElement> & {
    name: FieldName<TFieldValues>;
    type?: string;
    value?: any;
    disabled?: boolean;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: Noop;
};

// @public (undocumented)
export type DeepMap<T, TValue> = IsAny<T> extends true ? any : T extends BrowserNativeObject | NestedValue ? TValue : T extends object ? {
    [K in keyof T]: DeepMap<NonUndefined<T[K]>, TValue>;
} : TValue;

// @public (undocumented)
export type DeepPartial<T> = T extends BrowserNativeObject | NestedValue ? T : {
    [K in keyof T]?: ExtractObjects<T[K]> extends never ? T[K] : DeepPartial<T[K]>;
};

// @public (undocumented)
export type DeepPartialSkipArrayKey<T> = T extends BrowserNativeObject | NestedValue ? T : T extends ReadonlyArray<any> ? {
    [K in keyof T]: DeepPartialSkipArrayKey<T[K]>;
} : {
    [K in keyof T]?: DeepPartialSkipArrayKey<T[K]>;
};

// @public (undocumented)
export type DeepRequired<T> = T extends BrowserNativeObject | Blob ? T : {
    [K in keyof T]-?: NonNullable<DeepRequired<T[K]>>;
};

// Warning: (ae-forgotten-export) The symbol "AsyncDefaultValues" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DefaultValues<TFieldValues> = TFieldValues extends AsyncDefaultValues<TFieldValues> ? DeepPartial<Awaited<TFieldValues>> : DeepPartial<TFieldValues>;

// @public (undocumented)
export type DelayCallback = (wait: number) => void;

// @public (undocumented)
export type EmptyObject = {
    [K in string | number]: never;
};

// @public (undocumented)
export type ErrorOption = {
    message?: Message;
    type?: LiteralUnion<keyof RegisterOptions, string>;
    types?: MultipleFieldErrors;
};

// @public (undocumented)
export type EventType = 'focus' | 'blur' | 'change' | 'changeText' | 'valueChange' | 'contentSizeChange' | 'endEditing' | 'keyPress' | 'submitEditing' | 'layout' | 'selectionChange' | 'longPress' | 'press' | 'pressIn' | 'pressOut' | 'momentumScrollBegin' | 'momentumScrollEnd' | 'scroll' | 'scrollBeginDrag' | 'scrollEndDrag' | 'load' | 'error' | 'progress' | 'custom';

// @public (undocumented)
export type ExtractObjects<T> = T extends infer U ? U extends object ? U : never : never;

// @public (undocumented)
export type Field = {
    _f: {
        ref: Ref;
        name: InternalFieldName;
        refs?: HTMLInputElement[];
        mount?: boolean;
    } & RegisterOptions;
};

// @public (undocumented)
export type FieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = FieldArrayPathValue<TFieldValues, TFieldArrayName> extends ReadonlyArray<infer U> | null | undefined ? U : never;

// @public
export type FieldArrayMethodProps = {
    shouldFocus?: boolean;
    focusIndex?: number;
    focusName?: string;
};

// @public
export type FieldArrayPath<TFieldValues extends FieldValues> = ArrayPath<TFieldValues>;

// @public
export type FieldArrayPathValue<TFieldValues extends FieldValues, TFieldArrayPath extends FieldArrayPath<TFieldValues>> = PathValue<TFieldValues, TFieldArrayPath>;

// @public
export type FieldArrayWithId<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = FieldArray<TFieldValues, TFieldArrayName> & Record<TKeyName, string>;

// @public (undocumented)
export type FieldElement<TFieldValues extends FieldValues = FieldValues> = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | CustomElement<TFieldValues>;

// @public (undocumented)
export type FieldError = {
    type: LiteralUnion<keyof RegisterOptions, string>;
    root?: FieldError;
    ref?: Ref;
    types?: MultipleFieldErrors;
    message?: Message;
};

// @public (undocumented)
export type FieldErrors<T extends FieldValues = FieldValues> = Partial<FieldValues extends IsAny<FieldValues> ? any : FieldErrorsImpl<DeepRequired<T>>> & {
    root?: Record<string, GlobalError> & GlobalError;
};

// @public (undocumented)
export type FieldErrorsImpl<T extends FieldValues = FieldValues> = {
    [K in keyof T]?: T[K] extends BrowserNativeObject | Blob ? FieldError : K extends 'root' | `root.${string}` ? GlobalError : T[K] extends object ? Merge<FieldError, FieldErrorsImpl<T[K]>> : FieldError;
};

// @public (undocumented)
export type FieldName<TFieldValues extends FieldValues> = IsFlatObject<TFieldValues> extends true ? Extract<keyof TFieldValues, string> : string;

// @public (undocumented)
export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<DeepPartial<TFieldValues>, boolean>;

// @public
export type FieldPath<TFieldValues extends FieldValues> = Path<TFieldValues>;

// @public
export type FieldPathByValue<TFieldValues extends FieldValues, TValue> = {
    [Key in FieldPath<TFieldValues>]: FieldPathValue<TFieldValues, Key> extends TValue ? Key : never;
}[FieldPath<TFieldValues>];

// @public
export type FieldPathValue<TFieldValues extends FieldValues, TFieldPath extends FieldPath<TFieldValues>> = PathValue<TFieldValues, TFieldPath>;

// @public
export type FieldPathValues<TFieldValues extends FieldValues, TPath extends FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[]> = {} & {
    [K in keyof TPath]: FieldPathValue<TFieldValues, TPath[K] & FieldPath<TFieldValues>>;
};

// @public (undocumented)
export type FieldRefs = Partial<{
    [key: InternalFieldName]: Field | FieldRefs;
}>;

// @public (undocumented)
export type FieldValue<TFieldValues extends FieldValues> = TFieldValues[InternalFieldName];

// @public (undocumented)
export type FieldValues = Record<string, any>;

// @public
export function Form<T extends FieldValues, U extends FieldValues | undefined = undefined>(props: FormProps<T, U>): React_2.JSX.Element;

// @public (undocumented)
export type FormProps<TFieldValues extends FieldValues, TTransformedValues extends FieldValues | undefined = undefined> = Omit<React_2.FormHTMLAttributes<HTMLFormElement>, 'onError' | 'onSubmit'> & Partial<{
    control: Control<TFieldValues>;
    headers: Record<string, string>;
    validateStatus: (status: number) => boolean;
    onError: ({ response, error, }: {
        response: Response;
        error?: undefined;
    } | {
        response?: undefined;
        error: unknown;
    }) => void;
    onSuccess: ({ response }: {
        response: Response;
    }) => void;
    onSubmit: TTransformedValues extends FieldValues ? FormSubmitHandler<TTransformedValues> : FormSubmitHandler<TFieldValues>;
    method: 'post' | 'put' | 'delete';
    children: React_2.ReactNode | React_2.ReactNode[];
    render: (props: {
        submit: (e?: React_2.FormEvent) => void;
    }) => React_2.ReactNode | React_2.ReactNode[];
    encType: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'text/plain' | 'application/json';
}>;

// @public
export const FormProvider: <TFieldValues extends FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined>(props: FormProviderProps<TFieldValues, TContext, TTransformedValues>) => React_2.JSX.Element;

// @public (undocumented)
export type FormProviderProps<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined> = {
    children: React_2.ReactNode | React_2.ReactNode[];
} & UseFormReturn<TFieldValues, TContext, TTransformedValues>;

// @public (undocumented)
export type FormState<TFieldValues extends FieldValues> = {
    isDirty: boolean;
    isLoading: boolean;
    isSubmitted: boolean;
    isSubmitSuccessful: boolean;
    isSubmitting: boolean;
    isValidating: boolean;
    isValid: boolean;
    disabled: boolean;
    submitCount: number;
    defaultValues?: undefined | Readonly<DeepPartial<TFieldValues>>;
    dirtyFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    touchedFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    validatingFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    errors: FieldErrors<TFieldValues>;
};

// @public (undocumented)
export type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {
    isDirty: boolean;
    isValidating: boolean;
    dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;
    touchedFields: FieldNamesMarkedBoolean<TFieldValues>;
    validatingFields: FieldNamesMarkedBoolean<TFieldValues>;
    errors: boolean;
    isValid: boolean;
};

// Warning: (ae-forgotten-export) The symbol "Subject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type FormStateSubjectRef<TFieldValues extends FieldValues> = Subject<Partial<FormState<TFieldValues>> & {
    name?: InternalFieldName;
}>;

// @public (undocumented)
export type FormSubmitHandler<TFieldValues extends FieldValues> = (payload: {
    data: TFieldValues;
    event?: React_2.BaseSyntheticEvent;
    formData: FormData;
    formDataJson: string;
    method?: 'post' | 'put' | 'delete';
}) => unknown | Promise<unknown>;

// @public (undocumented)
export const get: <T>(object: T, path?: string | null, defaultValue?: unknown) => any;

// @public (undocumented)
export type GetIsDirty = <TName extends InternalFieldName, TData>(name?: TName, data?: TData) => boolean;

// @public (undocumented)
export type GlobalError = Partial<{
    type: string | number;
    message: Message;
}>;

// Warning: (ae-forgotten-export) The symbol "INPUT_VALIDATION_RULES" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InputValidationRules = typeof INPUT_VALIDATION_RULES;

// @public (undocumented)
export type InternalFieldErrors = Partial<Record<InternalFieldName, FieldError>>;

// @public (undocumented)
export type InternalFieldName = string;

// @public (undocumented)
export type InternalNameSet = Set<InternalFieldName>;

// @public
export type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export type IsEqual<T1, T2> = T1 extends T2 ? (<G>() => G extends T1 ? 1 : 2) extends <G>() => G extends T2 ? 1 : 2 ? true : false : false;

// @public (undocumented)
export type IsFlatObject<T extends object> = Extract<Exclude<T[keyof T], NestedValue | Date | FileList_2>, any[] | object> extends never ? true : false;

// @public
export type IsNever<T> = [T] extends [never] ? true : false;

// @public (undocumented)
export type KeepStateOptions = Partial<{
    keepDirtyValues: boolean;
    keepErrors: boolean;
    keepDirty: boolean;
    keepValues: boolean;
    keepDefaultValues: boolean;
    keepIsSubmitted: boolean;
    keepIsSubmitSuccessful: boolean;
    keepTouched: boolean;
    keepIsValidating: boolean;
    keepIsValid: boolean;
    keepSubmitCount: boolean;
}>;

// @public (undocumented)
export type LiteralUnion<T extends U, U extends Primitive> = T | (U & {
    _?: never;
});

// @public (undocumented)
export type MaxType = InputValidationRules['max'] | InputValidationRules['maxLength'];

// @public (undocumented)
export type Merge<A, B> = {
    [K in keyof A | keyof B]?: K extends keyof A & keyof B ? [A[K], B[K]] extends [object, object] ? Merge<A[K], B[K]> : A[K] | B[K] : K extends keyof A ? A[K] : K extends keyof B ? B[K] : never;
};

// @public (undocumented)
export type Message = string;

// @public (undocumented)
export type MinType = InputValidationRules['min'] | InputValidationRules['minLength'];

// @public (undocumented)
export type Mode = keyof ValidationMode;

// @public (undocumented)
export type MultipleFieldErrors = {
    [K in keyof RegisterOptions]?: ValidateResult;
} & {
    [key: string]: ValidateResult;
};

// @public (undocumented)
export type Names = {
    mount: InternalNameSet;
    unMount: InternalNameSet;
    array: InternalNameSet;
    watch: InternalNameSet;
    focus?: InternalFieldName;
    watchAll?: boolean;
};

// @public (undocumented)
export type NativeFieldValue = string | number | boolean | null | undefined | unknown[];

// @public @deprecated (undocumented)
export type NestedValue<TValue extends object = object> = {
    [$NestedValue]: never;
} & TValue;

// @public (undocumented)
export type NonUndefined<T> = T extends undefined ? never : T;

// @public (undocumented)
export type Noop = () => void;

// Warning: (ae-forgotten-export) The symbol "PathInternal" needs to be exported by the entry point index.d.ts
//
// @public
export type Path<T> = T extends any ? PathInternal<T> : never;

// @public
export type PathString = string;

// Warning: (ae-forgotten-export) The symbol "ArrayKey" needs to be exported by the entry point index.d.ts
//
// @public
export type PathValue<T, P extends Path<T> | ArrayPath<T>> = T extends any ? P extends `${infer K}.${infer R}` ? K extends keyof T ? R extends Path<T[K]> ? PathValue<T[K], R> : never : K extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? PathValue<V, R & Path<V>> : never : never : P extends keyof T ? T[P] : P extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? V : never : never : never;

// @public (undocumented)
export type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
export type ReadFormState = {
    [K in keyof FormStateProxy]: boolean | 'all';
};

// @public (undocumented)
export type Ref = FieldElement;

// @public (undocumented)
export type RefCallBack = (instance: any) => void;

// @public (undocumented)
export type RegisterOptions<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = Partial<{
    required: Message | ValidationRule<boolean>;
    min: ValidationRule<number | string>;
    max: ValidationRule<number | string>;
    maxLength: ValidationRule<number>;
    minLength: ValidationRule<number>;
    validate: Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues> | Record<string, Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues>>;
    value: FieldPathValue<TFieldValues, TFieldName>;
    setValueAs: (value: any) => any;
    shouldUnregister?: boolean;
    onChange?: (event: any) => void;
    onBlur?: (event: any) => void;
    disabled: boolean;
    deps: FieldPath<TFieldValues> | FieldPath<TFieldValues>[];
}> & ({
    pattern?: ValidationRule<RegExp>;
    valueAsNumber?: false;
    valueAsDate?: false;
} | {
    pattern?: undefined;
    valueAsNumber?: false;
    valueAsDate?: true;
} | {
    pattern?: undefined;
    valueAsNumber?: true;
    valueAsDate?: false;
});

// @public (undocumented)
export type Resolver<TFieldValues extends FieldValues = FieldValues, TContext = any> = (values: TFieldValues, context: TContext | undefined, options: ResolverOptions<TFieldValues>) => Promise<ResolverResult<TFieldValues>> | ResolverResult<TFieldValues>;

// @public (undocumented)
export type ResolverError<TFieldValues extends FieldValues = FieldValues> = {
    values: {};
    errors: FieldErrors<TFieldValues>;
};

// @public (undocumented)
export interface ResolverOptions<TFieldValues extends FieldValues> {
    // (undocumented)
    criteriaMode?: CriteriaMode;
    // (undocumented)
    fields: Record<InternalFieldName, Field['_f']>;
    // (undocumented)
    names?: FieldName<TFieldValues>[];
    // (undocumented)
    shouldUseNativeValidation: boolean | undefined;
}

// @public (undocumented)
export type ResolverResult<TFieldValues extends FieldValues = FieldValues> = ResolverSuccess<TFieldValues> | ResolverError<TFieldValues>;

// @public (undocumented)
export type ResolverSuccess<TFieldValues extends FieldValues = FieldValues> = {
    values: TFieldValues;
    errors: {};
};

// @public (undocumented)
export const set: (object: FieldValues, path: FieldPath<FieldValues>, value?: unknown) => FieldValues | undefined;

// @public (undocumented)
export type SetFieldValue<TFieldValues extends FieldValues> = FieldValue<TFieldValues>;

// @public (undocumented)
export type SetFocusOptions = Partial<{
    shouldSelect: boolean;
}>;

// @public (undocumented)
export type SetValueConfig = Partial<{
    shouldValidate: boolean;
    shouldDirty: boolean;
    shouldTouch: boolean;
}>;

// @public (undocumented)
export type Subjects<TFieldValues extends FieldValues = FieldValues> = {
    values: Subject<{
        name?: InternalFieldName;
        type?: EventType;
        values: FieldValues;
    }>;
    array: Subject<{
        name?: InternalFieldName;
        values?: FieldValues;
    }>;
    state: FormStateSubjectRef<TFieldValues>;
};

// @public (undocumented)
export type SubmitErrorHandler<TFieldValues extends FieldValues> = (errors: FieldErrors<TFieldValues>, event?: React_2.BaseSyntheticEvent) => unknown | Promise<unknown>;

// @public (undocumented)
export type SubmitHandler<TFieldValues extends FieldValues> = (data: TFieldValues, event?: React_2.BaseSyntheticEvent) => unknown | Promise<unknown>;

// @public (undocumented)
export type TriggerConfig = Partial<{
    shouldFocus: boolean;
}>;

// @public @deprecated (undocumented)
export type UnpackNestedValue<T> = T extends NestedValue<infer U> ? U : T extends Date | FileList | File | Blob ? T : T extends object ? {
    [K in keyof T]: UnpackNestedValue<T[K]>;
} : T;

// @public
export function useController<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: UseControllerProps<TFieldValues, TName>): UseControllerReturn<TFieldValues, TName>;

// @public (undocumented)
export type UseControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    name: TName;
    rules?: Omit<RegisterOptions<TFieldValues, TName>, 'valueAsNumber' | 'valueAsDate' | 'setValueAs' | 'disabled'>;
    shouldUnregister?: boolean;
    defaultValue?: FieldPathValue<TFieldValues, TName>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
};

// @public (undocumented)
export type UseControllerReturn<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    field: ControllerRenderProps<TFieldValues, TName>;
    formState: UseFormStateReturn<TFieldValues>;
    fieldState: ControllerFieldState;
};

// @public
export function useFieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'>(props: UseFieldArrayProps<TFieldValues, TFieldArrayName, TKeyName>): UseFieldArrayReturn<TFieldValues, TFieldArrayName, TKeyName>;

// @public
export type UseFieldArrayAppend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public
export type UseFieldArrayInsert<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public
export type UseFieldArrayMove = (indexA: number, indexB: number) => void;

// @public
export type UseFieldArrayPrepend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public (undocumented)
export type UseFieldArrayProps<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
    name: TFieldArrayName;
    keyName?: TKeyName;
    control?: Control<TFieldValues>;
    rules?: {
        validate?: Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues> | Record<string, Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues>>;
    } & Pick<RegisterOptions<TFieldValues>, 'maxLength' | 'minLength' | 'required'>;
    shouldUnregister?: boolean;
};

// @public
export type UseFieldArrayRemove = (index?: number | number[]) => void;

// @public
export type UseFieldArrayReplace<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[]) => void;

// @public (undocumented)
export type UseFieldArrayReturn<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
    swap: UseFieldArraySwap;
    move: UseFieldArrayMove;
    prepend: UseFieldArrayPrepend<TFieldValues, TFieldArrayName>;
    append: UseFieldArrayAppend<TFieldValues, TFieldArrayName>;
    remove: UseFieldArrayRemove;
    insert: UseFieldArrayInsert<TFieldValues, TFieldArrayName>;
    update: UseFieldArrayUpdate<TFieldValues, TFieldArrayName>;
    replace: UseFieldArrayReplace<TFieldValues, TFieldArrayName>;
    fields: FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>[];
};

// @public
export type UseFieldArraySwap = (indexA: number, indexB: number) => void;

// @public
export type UseFieldArrayUpdate<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName>) => void;

// @public
export function useForm<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined>(props?: UseFormProps<TFieldValues, TContext>): UseFormReturn<TFieldValues, TContext, TTransformedValues>;

// @public
export type UseFormClearErrors<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[] | `root.${string}` | 'root') => void;

// @public
export const useFormContext: <TFieldValues extends FieldValues, TContext = any, TransformedValues extends FieldValues | undefined = undefined>() => UseFormReturn<TFieldValues, TContext, TransformedValues>;

// @public
export type UseFormGetFieldState<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, formState?: FormState<TFieldValues>) => {
    invalid: boolean;
    isDirty: boolean;
    isTouched: boolean;
    isValidating: boolean;
    error?: FieldError;
};

// @public (undocumented)
export type UseFormGetValues<TFieldValues extends FieldValues> = {
    (): TFieldValues;
    <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName): FieldPathValue<TFieldValues, TFieldName>;
    <TFieldNames extends FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames]): [...FieldPathValues<TFieldValues, TFieldNames>];
};

// @public
export type UseFormHandleSubmit<TFieldValues extends FieldValues, TTransformedValues extends FieldValues | undefined = undefined> = (onValid: TTransformedValues extends undefined ? SubmitHandler<TFieldValues> : TTransformedValues extends FieldValues ? SubmitHandler<TTransformedValues> : never, onInvalid?: SubmitErrorHandler<TFieldValues>) => (e?: React_2.BaseSyntheticEvent) => Promise<void>;

// @public (undocumented)
export type UseFormProps<TFieldValues extends FieldValues = FieldValues, TContext = any> = Partial<{
    mode: Mode;
    disabled: boolean;
    reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
    defaultValues: DefaultValues<TFieldValues> | AsyncDefaultValues<TFieldValues>;
    values: TFieldValues;
    errors: FieldErrors<TFieldValues>;
    resetOptions: Parameters<UseFormReset<TFieldValues>>[1];
    resolver: Resolver<TFieldValues, TContext>;
    context: TContext;
    shouldFocusError: boolean;
    shouldUnregister: boolean;
    shouldUseNativeValidation: boolean;
    progressive: boolean;
    criteriaMode: CriteriaMode;
    delayError: number;
}>;

// @public
export type UseFormRegister<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: RegisterOptions<TFieldValues, TFieldName>) => UseFormRegisterReturn<TFieldName>;

// @public (undocumented)
export type UseFormRegisterReturn<TFieldName extends InternalFieldName = InternalFieldName> = {
    onChange: ChangeHandler;
    onBlur: ChangeHandler;
    ref: RefCallBack;
    name: TFieldName;
    min?: string | number;
    max?: string | number;
    maxLength?: number;
    minLength?: number;
    pattern?: string;
    required?: boolean;
    disabled?: boolean;
};

// Warning: (ae-forgotten-export) The symbol "ResetAction" needs to be exported by the entry point index.d.ts
//
// @public
export type UseFormReset<TFieldValues extends FieldValues> = (values?: DefaultValues<TFieldValues> | TFieldValues | ResetAction<TFieldValues>, keepStateOptions?: KeepStateOptions) => void;

// @public
export type UseFormResetField<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: Partial<{
    keepDirty: boolean;
    keepTouched: boolean;
    keepError: boolean;
    defaultValue: FieldPathValue<TFieldValues, TFieldName>;
}>) => void;

// @public (undocumented)
export type UseFormReturn<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined> = {
    watch: UseFormWatch<TFieldValues>;
    getValues: UseFormGetValues<TFieldValues>;
    getFieldState: UseFormGetFieldState<TFieldValues>;
    setError: UseFormSetError<TFieldValues>;
    clearErrors: UseFormClearErrors<TFieldValues>;
    setValue: UseFormSetValue<TFieldValues>;
    trigger: UseFormTrigger<TFieldValues>;
    formState: FormState<TFieldValues>;
    resetField: UseFormResetField<TFieldValues>;
    reset: UseFormReset<TFieldValues>;
    handleSubmit: UseFormHandleSubmit<TFieldValues, TTransformedValues>;
    unregister: UseFormUnregister<TFieldValues>;
    control: Control<TFieldValues, TContext>;
    register: UseFormRegister<TFieldValues>;
    setFocus: UseFormSetFocus<TFieldValues>;
};

// @public
export type UseFormSetError<TFieldValues extends FieldValues> = (name: FieldPath<TFieldValues> | `root.${string}` | 'root', error: ErrorOption, options?: {
    shouldFocus: boolean;
}) => void;

// @public
export type UseFormSetFocus<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: SetFocusOptions) => void;

// @public
export type UseFormSetValue<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, value: FieldPathValue<TFieldValues, TFieldName>, options?: SetValueConfig) => void;

// @public
export function useFormState<TFieldValues extends FieldValues = FieldValues>(props?: UseFormStateProps<TFieldValues>): UseFormStateReturn<TFieldValues>;

// @public (undocumented)
export type UseFormStateProps<TFieldValues extends FieldValues> = Partial<{
    control?: Control<TFieldValues>;
    disabled?: boolean;
    name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
    exact?: boolean;
}>;

// @public (undocumented)
export type UseFormStateReturn<TFieldValues extends FieldValues> = FormState<TFieldValues>;

// @public
export type UseFormTrigger<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: TriggerConfig) => Promise<boolean>;

// @public
export type UseFormUnregister<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: Omit<KeepStateOptions, 'keepIsSubmitted' | 'keepSubmitCount' | 'keepValues' | 'keepDefaultValues' | 'keepErrors'> & {
    keepValue?: boolean;
    keepDefaultValue?: boolean;
    keepError?: boolean;
}) => void;

// @public (undocumented)
export type UseFormWatch<TFieldValues extends FieldValues> = {
    (): TFieldValues;
    <TFieldNames extends readonly FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames], defaultValue?: DeepPartial<TFieldValues>): FieldPathValues<TFieldValues, TFieldNames>;
    <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, defaultValue?: FieldPathValue<TFieldValues, TFieldName>): FieldPathValue<TFieldValues, TFieldName>;
    (callback: WatchObserver<TFieldValues>, defaultValues?: DeepPartial<TFieldValues>): Subscription;
};

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues>(props: {
    defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): DeepPartialSkipArrayKey<TFieldValues>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: {
    name: TFieldName;
    defaultValue?: FieldPathValue<TFieldValues, TFieldName>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): FieldPathValue<TFieldValues, TFieldName>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldNames extends readonly FieldPath<TFieldValues>[] = readonly FieldPath<TFieldValues>[]>(props: {
    name: readonly [...TFieldNames];
    defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): FieldPathValues<TFieldValues, TFieldNames>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues>(): DeepPartialSkipArrayKey<TFieldValues>;

// @public (undocumented)
export type UseWatchProps<TFieldValues extends FieldValues = FieldValues> = {
    defaultValue?: unknown;
    disabled?: boolean;
    name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
    control?: Control<TFieldValues>;
    exact?: boolean;
};

// @public (undocumented)
export type Validate<TFieldValue, TFormValues> = (value: TFieldValue, formValues: TFormValues) => ValidateResult | Promise<ValidateResult>;

// @public (undocumented)
export type ValidateResult = Message | Message[] | boolean | undefined;

// Warning: (ae-forgotten-export) The symbol "VALIDATION_MODE" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ValidationMode = typeof VALIDATION_MODE;

// @public (undocumented)
export type ValidationModeFlags = {
    isOnSubmit: boolean;
    isOnBlur: boolean;
    isOnChange: boolean;
    isOnAll: boolean;
    isOnTouch: boolean;
};

// @public (undocumented)
export type ValidationRule<TValidationValue extends ValidationValue = ValidationValue> = TValidationValue | ValidationValueMessage<TValidationValue>;

// @public (undocumented)
export type ValidationValue = boolean | number | string | RegExp;

// @public (undocumented)
export type ValidationValueMessage<TValidationValue extends ValidationValue = ValidationValue> = {
    value: TValidationValue;
    message: Message;
};

// @public (undocumented)
export type WatchInternal<TFieldValues> = (fieldNames?: InternalFieldName | InternalFieldName[], defaultValue?: DeepPartial<TFieldValues>, isMounted?: boolean, isGlobal?: boolean) => FieldPathValue<FieldValues, InternalFieldName> | FieldPathValues<FieldValues, InternalFieldName[]>;

// @public (undocumented)
export type WatchObserver<TFieldValues extends FieldValues> = (value: DeepPartial<TFieldValues>, info: {
    name?: FieldPath<TFieldValues>;
    type?: EventType;
    values?: unknown;
}) => void;

// Warnings were encountered during analysis:
//
// src/types/form.ts:445:3 - (ae-forgotten-export) The symbol "Subscription" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```


================================================
File: /reports/api-extractor.md
================================================
## API Report File for "react-hook-form"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { JSXElementConstructor } from 'react';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';

// @public (undocumented)
export const appendErrors: (name: InternalFieldName, validateAllFieldCriteria: boolean, errors: InternalFieldErrors, type: string, message: ValidateResult) => {};

// Warning: (ae-forgotten-export) The symbol "ArrayPathInternal" needs to be exported by the entry point index.d.ts
//
// @public
export type ArrayPath<T> = T extends any ? ArrayPathInternal<T> : never;

// @public (undocumented)
export type BatchFieldArrayUpdate = <T extends Function, TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>>(name: InternalFieldName, updatedFieldArrayValues?: Partial<FieldArray<TFieldValues, TFieldArrayName>>[], method?: T, args?: Partial<{
    argA: unknown;
    argB: unknown;
}>, shouldSetValue?: boolean, shouldUpdateFieldsAndErrors?: boolean) => void;

// Warning: (ae-forgotten-export) The symbol "FileList_2" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "File_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type BrowserNativeObject = Date | FileList_2 | File_2;

// @public (undocumented)
export type ChangeHandler = (event: {
    target: any;
    type?: any;
}) => Promise<void | boolean>;

// @public (undocumented)
export type Control<TFieldValues extends FieldValues = FieldValues, TContext = any> = {
    _subjects: Subjects<TFieldValues>;
    _removeUnmounted: Noop;
    _names: Names;
    _state: {
        mount: boolean;
        action: boolean;
        watch: boolean;
    };
    _reset: UseFormReset<TFieldValues>;
    _options: UseFormProps<TFieldValues, TContext>;
    _getDirty: GetIsDirty;
    _resetDefaultValues: Noop;
    _formState: FormState<TFieldValues>;
    _updateValid: (shouldUpdateValid?: boolean) => void;
    _updateFormState: (formState: Partial<FormState<TFieldValues>>) => void;
    _fields: FieldRefs;
    _formValues: FieldValues;
    _proxyFormState: ReadFormState;
    _defaultValues: Partial<DefaultValues<TFieldValues>>;
    _getWatch: WatchInternal<TFieldValues>;
    _updateFieldArray: BatchFieldArrayUpdate;
    _getFieldArray: <TFieldArrayValues>(name: InternalFieldName) => Partial<TFieldArrayValues>[];
    _setErrors: (errors: FieldErrors<TFieldValues>) => void;
    _updateDisabledField: (props: {
        disabled?: boolean;
        name: FieldName<any>;
        value?: unknown;
    } & ({
        field?: Field;
        fields?: undefined;
    } | {
        field?: undefined;
        fields?: FieldRefs;
    })) => void;
    _executeSchema: (names: InternalFieldName[]) => Promise<{
        errors: FieldErrors;
    }>;
    register: UseFormRegister<TFieldValues>;
    handleSubmit: UseFormHandleSubmit<TFieldValues>;
    _disableForm: (disabled?: boolean) => void;
    unregister: UseFormUnregister<TFieldValues>;
    getFieldState: UseFormGetFieldState<TFieldValues>;
    setError: UseFormSetError<TFieldValues>;
};

// @public
export const Controller: <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: ControllerProps<TFieldValues, TName>) => ReactElement<any, string | JSXElementConstructor<any>>;

// @public (undocumented)
export type ControllerFieldState = {
    invalid: boolean;
    isTouched: boolean;
    isDirty: boolean;
    isValidating: boolean;
    error?: FieldError;
};

// @public
export type ControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    render: ({ field, fieldState, formState, }: {
        field: ControllerRenderProps<TFieldValues, TName>;
        fieldState: ControllerFieldState;
        formState: UseFormStateReturn<TFieldValues>;
    }) => React_2.ReactElement;
} & UseControllerProps<TFieldValues, TName>;

// @public (undocumented)
export type ControllerRenderProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    onChange: (...event: any[]) => void;
    onBlur: Noop;
    value: FieldPathValue<TFieldValues, TName>;
    disabled?: boolean;
    name: TName;
    ref: RefCallBack;
};

// @public (undocumented)
export type CriteriaMode = 'firstError' | 'all';

// @public (undocumented)
export type CustomElement<TFieldValues extends FieldValues> = Partial<HTMLElement> & {
    name: FieldName<TFieldValues>;
    type?: string;
    value?: any;
    disabled?: boolean;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: Noop;
};

// @public (undocumented)
export type DeepMap<T, TValue> = IsAny<T> extends true ? any : T extends BrowserNativeObject | NestedValue ? TValue : T extends object ? {
    [K in keyof T]: DeepMap<NonUndefined<T[K]>, TValue>;
} : TValue;

// @public (undocumented)
export type DeepPartial<T> = T extends BrowserNativeObject | NestedValue ? T : {
    [K in keyof T]?: ExtractObjects<T[K]> extends never ? T[K] : DeepPartial<T[K]>;
};

// @public (undocumented)
export type DeepPartialSkipArrayKey<T> = T extends BrowserNativeObject | NestedValue ? T : T extends ReadonlyArray<any> ? {
    [K in keyof T]: DeepPartialSkipArrayKey<T[K]>;
} : {
    [K in keyof T]?: DeepPartialSkipArrayKey<T[K]>;
};

// @public (undocumented)
export type DeepRequired<T> = T extends BrowserNativeObject | Blob ? T : {
    [K in keyof T]-?: NonNullable<DeepRequired<T[K]>>;
};

// Warning: (ae-forgotten-export) The symbol "AsyncDefaultValues" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DefaultValues<TFieldValues> = TFieldValues extends AsyncDefaultValues<TFieldValues> ? DeepPartial<Awaited<TFieldValues>> : DeepPartial<TFieldValues>;

// @public (undocumented)
export type DelayCallback = (wait: number) => void;

// @public (undocumented)
export type EmptyObject = {
    [K in string | number]: never;
};

// @public (undocumented)
export type ErrorOption = {
    message?: Message;
    type?: LiteralUnion<keyof RegisterOptions, string>;
    types?: MultipleFieldErrors;
};

// @public (undocumented)
export type EventType = 'focus' | 'blur' | 'change' | 'changeText' | 'valueChange' | 'contentSizeChange' | 'endEditing' | 'keyPress' | 'submitEditing' | 'layout' | 'selectionChange' | 'longPress' | 'press' | 'pressIn' | 'pressOut' | 'momentumScrollBegin' | 'momentumScrollEnd' | 'scroll' | 'scrollBeginDrag' | 'scrollEndDrag' | 'load' | 'error' | 'progress' | 'custom';

// @public (undocumented)
export type ExtractObjects<T> = T extends infer U ? U extends object ? U : never : never;

// @public (undocumented)
export type Field = {
    _f: {
        ref: Ref;
        name: InternalFieldName;
        refs?: HTMLInputElement[];
        mount?: boolean;
    } & RegisterOptions;
};

// @public (undocumented)
export type FieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = FieldArrayPathValue<TFieldValues, TFieldArrayName> extends ReadonlyArray<infer U> | null | undefined ? U : never;

// @public
export type FieldArrayMethodProps = {
    shouldFocus?: boolean;
    focusIndex?: number;
    focusName?: string;
};

// @public
export type FieldArrayPath<TFieldValues extends FieldValues> = ArrayPath<TFieldValues>;

// @public
export type FieldArrayPathValue<TFieldValues extends FieldValues, TFieldArrayPath extends FieldArrayPath<TFieldValues>> = PathValue<TFieldValues, TFieldArrayPath>;

// @public
export type FieldArrayWithId<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = FieldArray<TFieldValues, TFieldArrayName> & Record<TKeyName, string>;

// @public (undocumented)
export type FieldElement<TFieldValues extends FieldValues = FieldValues> = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | CustomElement<TFieldValues>;

// @public (undocumented)
export type FieldError = {
    type: LiteralUnion<keyof RegisterOptions, string>;
    root?: FieldError;
    ref?: Ref;
    types?: MultipleFieldErrors;
    message?: Message;
};

// @public (undocumented)
export type FieldErrors<T extends FieldValues = FieldValues> = Partial<FieldValues extends IsAny<FieldValues> ? any : FieldErrorsImpl<DeepRequired<T>>> & {
    root?: Record<string, GlobalError> & GlobalError;
};

// @public (undocumented)
export type FieldErrorsImpl<T extends FieldValues = FieldValues> = {
    [K in keyof T]?: T[K] extends BrowserNativeObject | Blob ? FieldError : K extends 'root' | `root.${string}` ? GlobalError : T[K] extends object ? Merge<FieldError, FieldErrorsImpl<T[K]>> : FieldError;
};

// @public (undocumented)
export type FieldName<TFieldValues extends FieldValues> = IsFlatObject<TFieldValues> extends true ? Extract<keyof TFieldValues, string> : string;

// @public (undocumented)
export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<DeepPartial<TFieldValues>, boolean>;

// @public
export type FieldPath<TFieldValues extends FieldValues> = Path<TFieldValues>;

// @public
export type FieldPathByValue<TFieldValues extends FieldValues, TValue> = {
    [Key in FieldPath<TFieldValues>]: FieldPathValue<TFieldValues, Key> extends TValue ? Key : never;
}[FieldPath<TFieldValues>];

// @public
export type FieldPathValue<TFieldValues extends FieldValues, TFieldPath extends FieldPath<TFieldValues>> = PathValue<TFieldValues, TFieldPath>;

// @public
export type FieldPathValues<TFieldValues extends FieldValues, TPath extends FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[]> = {} & {
    [K in keyof TPath]: FieldPathValue<TFieldValues, TPath[K] & FieldPath<TFieldValues>>;
};

// @public (undocumented)
export type FieldRefs = Partial<Record<InternalFieldName, Field>>;

// @public (undocumented)
export type FieldValue<TFieldValues extends FieldValues> = TFieldValues[InternalFieldName];

// @public (undocumented)
export type FieldValues = Record<string, any>;

// @public
export function Form<T extends FieldValues, U extends FieldValues | undefined = undefined>(props: FormProps<T, U>): React_2.JSX.Element;

// @public (undocumented)
export type FormProps<TFieldValues extends FieldValues, TTransformedValues extends FieldValues | undefined = undefined> = Omit<React_2.FormHTMLAttributes<HTMLFormElement>, 'onError' | 'onSubmit'> & Partial<{
    control: Control<TFieldValues>;
    headers: Record<string, string>;
    validateStatus: (status: number) => boolean;
    onError: ({ response, error, }: {
        response: Response;
        error?: undefined;
    } | {
        response?: undefined;
        error: unknown;
    }) => void;
    onSuccess: ({ response }: {
        response: Response;
    }) => void;
    onSubmit: TTransformedValues extends FieldValues ? FormSubmitHandler<TTransformedValues> : FormSubmitHandler<TFieldValues>;
    method: 'post' | 'put' | 'delete';
    children: React_2.ReactNode | React_2.ReactNode[];
    render: (props: {
        submit: (e?: React_2.FormEvent) => void;
    }) => React_2.ReactNode | React_2.ReactNode[];
    encType: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'text/plain' | 'application/json';
}>;

// @public
export const FormProvider: <TFieldValues extends FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined>(props: FormProviderProps<TFieldValues, TContext, TTransformedValues>) => React_2.JSX.Element;

// @public (undocumented)
export type FormProviderProps<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined> = {
    children: React_2.ReactNode | React_2.ReactNode[];
} & UseFormReturn<TFieldValues, TContext, TTransformedValues>;

// @public (undocumented)
export type FormState<TFieldValues extends FieldValues> = {
    isDirty: boolean;
    isLoading: boolean;
    isSubmitted: boolean;
    isSubmitSuccessful: boolean;
    isSubmitting: boolean;
    isValidating: boolean;
    isValid: boolean;
    disabled: boolean;
    submitCount: number;
    defaultValues?: undefined | Readonly<DeepPartial<TFieldValues>>;
    dirtyFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    touchedFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    validatingFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
    errors: FieldErrors<TFieldValues>;
};

// @public (undocumented)
export type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {
    isDirty: boolean;
    isValidating: boolean;
    dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;
    touchedFields: FieldNamesMarkedBoolean<TFieldValues>;
    validatingFields: FieldNamesMarkedBoolean<TFieldValues>;
    errors: boolean;
    isValid: boolean;
};

// Warning: (ae-forgotten-export) The symbol "Subject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type FormStateSubjectRef<TFieldValues extends FieldValues> = Subject<Partial<FormState<TFieldValues>> & {
    name?: InternalFieldName;
}>;

// @public (undocumented)
export type FormSubmitHandler<TFieldValues extends FieldValues> = (payload: {
    data: TFieldValues;
    event?: React_2.BaseSyntheticEvent;
    formData: FormData;
    formDataJson: string;
    method?: 'post' | 'put' | 'delete';
}) => unknown | Promise<unknown>;

// @public (undocumented)
export const get: <T>(object: T, path?: string, defaultValue?: unknown) => any;

// @public (undocumented)
export type GetIsDirty = <TName extends InternalFieldName, TData>(name?: TName, data?: TData) => boolean;

// @public (undocumented)
export type GlobalError = Partial<{
    type: string | number;
    message: Message;
}>;

// Warning: (ae-forgotten-export) The symbol "INPUT_VALIDATION_RULES" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InputValidationRules = typeof INPUT_VALIDATION_RULES;

// @public (undocumented)
export type InternalFieldErrors = Partial<Record<InternalFieldName, FieldError>>;

// @public (undocumented)
export type InternalFieldName = string;

// @public (undocumented)
export type InternalNameSet = Set<InternalFieldName>;

// @public
export type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export type IsEqual<T1, T2> = T1 extends T2 ? (<G>() => G extends T1 ? 1 : 2) extends <G>() => G extends T2 ? 1 : 2 ? true : false : false;

// @public (undocumented)
export type IsFlatObject<T extends object> = Extract<Exclude<T[keyof T], NestedValue | Date | FileList_2>, any[] | object> extends never ? true : false;

// @public
export type IsNever<T> = [T] extends [never] ? true : false;

// @public (undocumented)
export type KeepStateOptions = Partial<{
    keepDirtyValues: boolean;
    keepErrors: boolean;
    keepDirty: boolean;
    keepValues: boolean;
    keepDefaultValues: boolean;
    keepIsSubmitted: boolean;
    keepIsSubmitSuccessful: boolean;
    keepTouched: boolean;
    keepIsValidating: boolean;
    keepIsValid: boolean;
    keepSubmitCount: boolean;
}>;

// @public (undocumented)
export type LiteralUnion<T extends U, U extends Primitive> = T | (U & {
    _?: never;
});

// @public (undocumented)
export type MaxType = InputValidationRules['max'] | InputValidationRules['maxLength'];

// @public (undocumented)
export type Merge<A, B> = {
    [K in keyof A | keyof B]?: K extends keyof A & keyof B ? [A[K], B[K]] extends [object, object] ? Merge<A[K], B[K]> : A[K] | B[K] : K extends keyof A ? A[K] : K extends keyof B ? B[K] : never;
};

// @public (undocumented)
export type Message = string;

// @public (undocumented)
export type MinType = InputValidationRules['min'] | InputValidationRules['minLength'];

// @public (undocumented)
export type Mode = keyof ValidationMode;

// @public (undocumented)
export type MultipleFieldErrors = {
    [K in keyof RegisterOptions]?: ValidateResult;
} & {
    [key: string]: ValidateResult;
};

// @public (undocumented)
export type Names = {
    mount: InternalNameSet;
    unMount: InternalNameSet;
    array: InternalNameSet;
    watch: InternalNameSet;
    focus?: InternalFieldName;
    watchAll?: boolean;
};

// @public (undocumented)
export type NativeFieldValue = string | number | boolean | null | undefined | unknown[];

// @public @deprecated (undocumented)
export type NestedValue<TValue extends object = object> = {
    [$NestedValue]: never;
} & TValue;

// @public (undocumented)
export type NonUndefined<T> = T extends undefined ? never : T;

// @public (undocumented)
export type Noop = () => void;

// Warning: (ae-forgotten-export) The symbol "PathInternal" needs to be exported by the entry point index.d.ts
//
// @public
export type Path<T> = T extends any ? PathInternal<T> : never;

// @public
export type PathString = string;

// Warning: (ae-forgotten-export) The symbol "ArrayKey" needs to be exported by the entry point index.d.ts
//
// @public
export type PathValue<T, P extends Path<T> | ArrayPath<T>> = T extends any ? P extends `${infer K}.${infer R}` ? K extends keyof T ? R extends Path<T[K]> ? PathValue<T[K], R> : never : K extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? PathValue<V, R & Path<V>> : never : never : P extends keyof T ? T[P] : P extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? V : never : never : never;

// @public (undocumented)
export type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
export type ReadFormState = {
    [K in keyof FormStateProxy]: boolean | 'all';
};

// @public (undocumented)
export type Ref = FieldElement;

// @public (undocumented)
export type RefCallBack = (instance: any) => void;

// @public (undocumented)
export type RegisterOptions<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = Partial<{
    required: Message | ValidationRule<boolean>;
    min: ValidationRule<number | string>;
    max: ValidationRule<number | string>;
    maxLength: ValidationRule<number>;
    minLength: ValidationRule<number>;
    validate: Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues> | Record<string, Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues>>;
    value: FieldPathValue<TFieldValues, TFieldName>;
    setValueAs: (value: any) => any;
    shouldUnregister?: boolean;
    onChange?: (event: any) => void;
    onBlur?: (event: any) => void;
    disabled: boolean;
    deps: FieldPath<TFieldValues> | FieldPath<TFieldValues>[];
}> & ({
    pattern?: ValidationRule<RegExp>;
    valueAsNumber?: false;
    valueAsDate?: false;
} | {
    pattern?: undefined;
    valueAsNumber?: false;
    valueAsDate?: true;
} | {
    pattern?: undefined;
    valueAsNumber?: true;
    valueAsDate?: false;
});

// @public (undocumented)
export type Resolver<TFieldValues extends FieldValues = FieldValues, TContext = any> = (values: TFieldValues, context: TContext | undefined, options: ResolverOptions<TFieldValues>) => Promise<ResolverResult<TFieldValues>> | ResolverResult<TFieldValues>;

// @public (undocumented)
export type ResolverError<TFieldValues extends FieldValues = FieldValues> = {
    values: {};
    errors: FieldErrors<TFieldValues>;
};

// @public (undocumented)
export interface ResolverOptions<TFieldValues extends FieldValues> {
    // (undocumented)
    criteriaMode?: CriteriaMode;
    // (undocumented)
    fields: Record<InternalFieldName, Field['_f']>;
    // (undocumented)
    names?: FieldName<TFieldValues>[];
    // (undocumented)
    shouldUseNativeValidation: boolean | undefined;
}

// @public (undocumented)
export type ResolverResult<TFieldValues extends FieldValues = FieldValues> = ResolverSuccess<TFieldValues> | ResolverError<TFieldValues>;

// @public (undocumented)
export type ResolverSuccess<TFieldValues extends FieldValues = FieldValues> = {
    values: TFieldValues;
    errors: {};
};

// @public (undocumented)
export const set: (object: FieldValues, path: string, value?: unknown) => FieldValues | undefined;

// @public (undocumented)
export type SetFieldValue<TFieldValues extends FieldValues> = FieldValue<TFieldValues>;

// @public (undocumented)
export type SetFocusOptions = Partial<{
    shouldSelect: boolean;
}>;

// @public (undocumented)
export type SetValueConfig = Partial<{
    shouldValidate: boolean;
    shouldDirty: boolean;
    shouldTouch: boolean;
}>;

// @public (undocumented)
export type Subjects<TFieldValues extends FieldValues = FieldValues> = {
    values: Subject<{
        name?: InternalFieldName;
        type?: EventType;
        values: FieldValues;
    }>;
    array: Subject<{
        name?: InternalFieldName;
        values?: FieldValues;
    }>;
    state: FormStateSubjectRef<TFieldValues>;
};

// @public (undocumented)
export type SubmitErrorHandler<TFieldValues extends FieldValues> = (errors: FieldErrors<TFieldValues>, event?: React_2.BaseSyntheticEvent) => unknown | Promise<unknown>;

// @public (undocumented)
export type SubmitHandler<TFieldValues extends FieldValues> = (data: TFieldValues, event?: React_2.BaseSyntheticEvent) => unknown | Promise<unknown>;

// @public (undocumented)
export type TriggerConfig = Partial<{
    shouldFocus: boolean;
}>;

// @public @deprecated (undocumented)
export type UnpackNestedValue<T> = T extends NestedValue<infer U> ? U : T extends Date | FileList | File | Blob ? T : T extends object ? {
    [K in keyof T]: UnpackNestedValue<T[K]>;
} : T;

// @public
export function useController<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: UseControllerProps<TFieldValues, TName>): UseControllerReturn<TFieldValues, TName>;

// @public (undocumented)
export type UseControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    name: TName;
    rules?: Omit<RegisterOptions<TFieldValues, TName>, 'valueAsNumber' | 'valueAsDate' | 'setValueAs' | 'disabled'>;
    shouldUnregister?: boolean;
    defaultValue?: FieldPathValue<TFieldValues, TName>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
};

// @public (undocumented)
export type UseControllerReturn<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    field: ControllerRenderProps<TFieldValues, TName>;
    formState: UseFormStateReturn<TFieldValues>;
    fieldState: ControllerFieldState;
};

// @public
export function useFieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'>(props: UseFieldArrayProps<TFieldValues, TFieldArrayName, TKeyName>): UseFieldArrayReturn<TFieldValues, TFieldArrayName, TKeyName>;

// @public
export type UseFieldArrayAppend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public
export type UseFieldArrayInsert<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public
export type UseFieldArrayMove = (indexA: number, indexB: number) => void;

// @public
export type UseFieldArrayPrepend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;

// @public (undocumented)
export type UseFieldArrayProps<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
    name: TFieldArrayName;
    keyName?: TKeyName;
    control?: Control<TFieldValues>;
    rules?: {
        validate?: Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues> | Record<string, Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues>>;
    } & Pick<RegisterOptions<TFieldValues>, 'maxLength' | 'minLength' | 'required'>;
    shouldUnregister?: boolean;
};

// @public
export type UseFieldArrayRemove = (index?: number | number[]) => void;

// @public
export type UseFieldArrayReplace<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[]) => void;

// @public (undocumented)
export type UseFieldArrayReturn<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
    swap: UseFieldArraySwap;
    move: UseFieldArrayMove;
    prepend: UseFieldArrayPrepend<TFieldValues, TFieldArrayName>;
    append: UseFieldArrayAppend<TFieldValues, TFieldArrayName>;
    remove: UseFieldArrayRemove;
    insert: UseFieldArrayInsert<TFieldValues, TFieldArrayName>;
    update: UseFieldArrayUpdate<TFieldValues, TFieldArrayName>;
    replace: UseFieldArrayReplace<TFieldValues, TFieldArrayName>;
    fields: FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>[];
};

// @public
export type UseFieldArraySwap = (indexA: number, indexB: number) => void;

// @public
export type UseFieldArrayUpdate<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName>) => void;

// @public
export function useForm<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined>(props?: UseFormProps<TFieldValues, TContext>): UseFormReturn<TFieldValues, TContext, TTransformedValues>;

// @public
export type UseFormClearErrors<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[] | `root.${string}` | 'root') => void;

// @public
export const useFormContext: <TFieldValues extends FieldValues, TContext = any, TransformedValues extends FieldValues | undefined = undefined>() => UseFormReturn<TFieldValues, TContext, TransformedValues>;

// @public
export type UseFormGetFieldState<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, formState?: FormState<TFieldValues>) => {
    invalid: boolean;
    isDirty: boolean;
    isTouched: boolean;
    isValidating: boolean;
    error?: FieldError;
};

// @public (undocumented)
export type UseFormGetValues<TFieldValues extends FieldValues> = {
    (): TFieldValues;
    <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName): FieldPathValue<TFieldValues, TFieldName>;
    <TFieldNames extends FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames]): [...FieldPathValues<TFieldValues, TFieldNames>];
};

// @public
export type UseFormHandleSubmit<TFieldValues extends FieldValues, TTransformedValues extends FieldValues | undefined = undefined> = (onValid: TTransformedValues extends undefined ? SubmitHandler<TFieldValues> : TTransformedValues extends FieldValues ? SubmitHandler<TTransformedValues> : never, onInvalid?: SubmitErrorHandler<TFieldValues>) => (e?: React_2.BaseSyntheticEvent) => Promise<void>;

// @public (undocumented)
export type UseFormProps<TFieldValues extends FieldValues = FieldValues, TContext = any> = Partial<{
    mode: Mode;
    disabled: boolean;
    reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
    defaultValues: DefaultValues<TFieldValues> | AsyncDefaultValues<TFieldValues>;
    values: TFieldValues;
    errors: FieldErrors<TFieldValues>;
    resetOptions: Parameters<UseFormReset<TFieldValues>>[1];
    resolver: Resolver<TFieldValues, TContext>;
    context: TContext;
    shouldFocusError: boolean;
    shouldUnregister: boolean;
    shouldUseNativeValidation: boolean;
    progressive: boolean;
    criteriaMode: CriteriaMode;
    delayError: number;
}>;

// @public
export type UseFormRegister<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: RegisterOptions<TFieldValues, TFieldName>) => UseFormRegisterReturn<TFieldName>;

// @public (undocumented)
export type UseFormRegisterReturn<TFieldName extends InternalFieldName = InternalFieldName> = {
    onChange: ChangeHandler;
    onBlur: ChangeHandler;
    ref: RefCallBack;
    name: TFieldName;
    min?: string | number;
    max?: string | number;
    maxLength?: number;
    minLength?: number;
    pattern?: string;
    required?: boolean;
    disabled?: boolean;
};

// Warning: (ae-forgotten-export) The symbol "ResetAction" needs to be exported by the entry point index.d.ts
//
// @public
export type UseFormReset<TFieldValues extends FieldValues> = (values?: DefaultValues<TFieldValues> | TFieldValues | ResetAction<TFieldValues>, keepStateOptions?: KeepStateOptions) => void;

// @public
export type UseFormResetField<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: Partial<{
    keepDirty: boolean;
    keepTouched: boolean;
    keepError: boolean;
    defaultValue: FieldPathValue<TFieldValues, TFieldName>;
}>) => void;

// @public (undocumented)
export type UseFormReturn<TFieldValues extends FieldValues = FieldValues, TContext = any, TTransformedValues extends FieldValues | undefined = undefined> = {
    watch: UseFormWatch<TFieldValues>;
    getValues: UseFormGetValues<TFieldValues>;
    getFieldState: UseFormGetFieldState<TFieldValues>;
    setError: UseFormSetError<TFieldValues>;
    clearErrors: UseFormClearErrors<TFieldValues>;
    setValue: UseFormSetValue<TFieldValues>;
    trigger: UseFormTrigger<TFieldValues>;
    formState: FormState<TFieldValues>;
    resetField: UseFormResetField<TFieldValues>;
    reset: UseFormReset<TFieldValues>;
    handleSubmit: UseFormHandleSubmit<TFieldValues, TTransformedValues>;
    unregister: UseFormUnregister<TFieldValues>;
    control: Control<TFieldValues, TContext>;
    register: UseFormRegister<TFieldValues>;
    setFocus: UseFormSetFocus<TFieldValues>;
};

// @public
export type UseFormSetError<TFieldValues extends FieldValues> = (name: FieldPath<TFieldValues> | `root.${string}` | 'root', error: ErrorOption, options?: {
    shouldFocus: boolean;
}) => void;

// @public
export type UseFormSetFocus<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: SetFocusOptions) => void;

// @public
export type UseFormSetValue<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, value: FieldPathValue<TFieldValues, TFieldName>, options?: SetValueConfig) => void;

// @public
export function useFormState<TFieldValues extends FieldValues = FieldValues>(props?: UseFormStateProps<TFieldValues>): UseFormStateReturn<TFieldValues>;

// @public (undocumented)
export type UseFormStateProps<TFieldValues extends FieldValues> = Partial<{
    control?: Control<TFieldValues>;
    disabled?: boolean;
    name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
    exact?: boolean;
}>;

// @public (undocumented)
export type UseFormStateReturn<TFieldValues extends FieldValues> = FormState<TFieldValues>;

// @public
export type UseFormTrigger<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: TriggerConfig) => Promise<boolean>;

// @public
export type UseFormUnregister<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: Omit<KeepStateOptions, 'keepIsSubmitted' | 'keepSubmitCount' | 'keepValues' | 'keepDefaultValues' | 'keepErrors'> & {
    keepValue?: boolean;
    keepDefaultValue?: boolean;
    keepError?: boolean;
}) => void;

// @public (undocumented)
export type UseFormWatch<TFieldValues extends FieldValues> = {
    (): TFieldValues;
    <TFieldNames extends readonly FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames], defaultValue?: DeepPartial<TFieldValues>): FieldPathValues<TFieldValues, TFieldNames>;
    <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, defaultValue?: FieldPathValue<TFieldValues, TFieldName>): FieldPathValue<TFieldValues, TFieldName>;
    (callback: WatchObserver<TFieldValues>, defaultValues?: DeepPartial<TFieldValues>): Subscription;
};

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues>(props: {
    defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): DeepPartialSkipArrayKey<TFieldValues>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: {
    name: TFieldName;
    defaultValue?: FieldPathValue<TFieldValues, TFieldName>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): FieldPathValue<TFieldValues, TFieldName>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldNames extends readonly FieldPath<TFieldValues>[] = readonly FieldPath<TFieldValues>[]>(props: {
    name: readonly [...TFieldNames];
    defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
    control?: Control<TFieldValues>;
    disabled?: boolean;
    exact?: boolean;
}): FieldPathValues<TFieldValues, TFieldNames>;

// @public
export function useWatch<TFieldValues extends FieldValues = FieldValues>(): DeepPartialSkipArrayKey<TFieldValues>;

// @public (undocumented)
export type UseWatchProps<TFieldValues extends FieldValues = FieldValues> = {
    defaultValue?: unknown;
    disabled?: boolean;
    name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
    control?: Control<TFieldValues>;
    exact?: boolean;
};

// @public (undocumented)
export type Validate<TFieldValue, TFormValues> = (value: TFieldValue, formValues: TFormValues) => ValidateResult | Promise<ValidateResult>;

// @public (undocumented)
export type ValidateResult = Message | Message[] | boolean | undefined;

// Warning: (ae-forgotten-export) The symbol "VALIDATION_MODE" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ValidationMode = typeof VALIDATION_MODE;

// @public (undocumented)
export type ValidationModeFlags = {
    isOnSubmit: boolean;
    isOnBlur: boolean;
    isOnChange: boolean;
    isOnAll: boolean;
    isOnTouch: boolean;
};

// @public (undocumented)
export type ValidationRule<TValidationValue extends ValidationValue = ValidationValue> = TValidationValue | ValidationValueMessage<TValidationValue>;

// @public (undocumented)
export type ValidationValue = boolean | number | string | RegExp;

// @public (undocumented)
export type ValidationValueMessage<TValidationValue extends ValidationValue = ValidationValue> = {
    value: TValidationValue;
    message: Message;
};

// @public (undocumented)
export type WatchInternal<TFieldValues> = (fieldNames?: InternalFieldName | InternalFieldName[], defaultValue?: DeepPartial<TFieldValues>, isMounted?: boolean, isGlobal?: boolean) => FieldPathValue<FieldValues, InternalFieldName> | FieldPathValues<FieldValues, InternalFieldName[]>;

// @public (undocumented)
export type WatchObserver<TFieldValues extends FieldValues> = (value: DeepPartial<TFieldValues>, info: {
    name?: FieldPath<TFieldValues>;
    type?: EventType;
    values?: unknown;
}) => void;

// Warnings were encountered during analysis:
//
// src/types/form.ts:444:3 - (ae-forgotten-export) The symbol "Subscription" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```


================================================
File: /tsconfig.json
================================================
{
  "compilerOptions": {
    "sourceMap": true,
    "module": "es2015",
    "target": "es2018",
    "moduleResolution": "node",
    "outDir": "./dist",
    "jsx": "react",
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "noEmit": true,
    "esModuleInterop": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": [
    "node_modules",
    "app",
    "examples",
    "cypress",
    "src/*.test.ts",
    "src/*.test.tsx",
    "src/*.test-d.ts",
    "src/*.test-d.tsx",
    "src/__mocks__"
  ]
}


================================================
File: /README.md
================================================
<div align="center">
        <a href="https://react-hook-form.com" title="React Hook Form - Simple React forms validation">
            <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/logo.png" alt="React Hook Form Logo - React hook custom hook for form validation" />
        </a>
</div>

<div align="center">

[![npm downloads](https://img.shields.io/npm/dm/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/dt/react-hook-form.svg?style=for-the-badge)](https://www.npmjs.com/package/react-hook-form)
[![npm](https://img.shields.io/npm/l/react-hook-form?style=for-the-badge)](https://github.com/react-hook-form/react-hook-form/blob/master/LICENSE)
[![Discord](https://img.shields.io/discord/754891658327359538.svg?style=for-the-badge&label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/yYv7GZ8)

</div>

<p align="center">
  <a href="https://react-hook-form.com/get-started">Get started</a> | 
  <a href="https://react-hook-form.com/docs">API</a> |
  <a href="https://react-hook-form.com/form-builder">Form Builder</a> |
  <a href="https://react-hook-form.com/faqs">FAQs</a> |
  <a href="https://github.com/react-hook-form/react-hook-form/tree/master/examples">Examples</a>
</p>

### Features

- Built with performance, UX and DX in mind
- Embraces native HTML form [validation](https://react-hook-form.com/get-started#Applyvalidation)
- Out of the box integration with [UI libraries](https://codesandbox.io/s/react-hook-form-v7-controller-5h1q5)
- [Small size](https://bundlephobia.com/result?p=react-hook-form@latest) and no [dependencies](./package.json)
- Support [Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod), [AJV](https://github.com/ajv-validator/ajv), [Superstruct](https://github.com/ianstormtaylor/superstruct), [Joi](https://github.com/hapijs/joi) and [others](https://github.com/react-hook-form/resolvers)

### Install

    npm install react-hook-form

### Quickstart

```jsx
import { useForm } from 'react-hook-form';

function App() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  return (
    <form onSubmit={handleSubmit((data) => console.log(data))}>
      <input {...register('firstName')} />
      <input {...register('lastName', { required: true })} />
      {errors.lastName && <p>Last name is required.</p>}
      <input {...register('age', { pattern: /\d+/ })} />
      {errors.age && <p>Please enter number for age.</p>}
      <input type="submit" />
    </form>
  );
}
```

<a href="https://ui.dev/bytes/?r=bill">
  <img src="https://raw.githubusercontent.com/react-hook-form/react-hook-form/master/docs/ads-1.jpeg" />
</a>

### Sponsors

Thanks go to these kind and lovely sponsors!

<a target="_blank" href='https://workleap.com/'>
    <img width="94" src="https://images.opencollective.com/workleap/db82f38/logo/256.png?height=256" />
</a>
<a target="_blank" href='https://www.sgkb.ch/'>
    <img width="94" src="https://images.opencollective.com/st-galler-kantonalbank-ag/bfdd17f/logo/256.png?height=256" />
</a>
<a target="_blank" href='https://www.sanity.io/'>
    <img width="94" src="https://images.opencollective.com/sanity_io/558f87f/logo/256.png?height=256" />
</a>
<a target="_blank" href='https://route4me.com/'>
    <img width="94" src="https://images.opencollective.com/route4me/71fb6fa/avatar/256.png?height=256" />
</a>
<a target="_blank" href='https://twicsy.com/'>
    <img width="94" src="https://images.opencollective.com/buy-instagram-followers-twicsy/b4c5d7f/logo/256.png?height=256" />
</a>
<a target="_blank" href='https://toss.im'>
    <img width="94" src="https://images.opencollective.com/toss/3ed69b3/logo/256.png" />
</a>
<a target="_blank" href='https://principal.com/about-us'>
    <img width="94" src="https://images.opencollective.com/principal/431e690/logo/256.png?height=256" />
</a>
<a target="_blank" href="https://graphcms.com">
    <img width="94" src="https://avatars.githubusercontent.com/u/31031438" />
</a>
<a target="_blank" href="https://www.beekai.com/">
    <img width="94" src="https://www.beekai.com/marketing/logo/logo.svg" />
</a>
<a target="_blank" href="https://kanamekey.com">
    <img width="94" src="https://images.opencollective.com/kaname/d15fd98/logo/256.png" />
</a>
<a target="_blank" href="https://www.casinoreviews.net/">
    <img width="94" src="https://images.opencollective.com/casinoreviews/f0877d1/logo/256.png" />
</a>

### Past sponsors

<a href="https://www.leniolabs.com/" target="_blank">
  <img src="https://images.opencollective.com/leniolabs_/63e9b6e/logo/256.png" width="48" height="48" />
</a>
<a target="_blank" href="https://underbelly.is">
    <img width="48" src="https://images.opencollective.com/underbelly/989a4a6/logo/256.png" />
</a>
<a target="_blank" href="https://feathery.io">
    <img width="48" src="https://images.opencollective.com/feathery1/c29b0a1/logo/256.png" />
</a>
<a target="_blank" href="https://getform.io">
    <img width="48" src="https://images.opencollective.com/getformio2/3c978c8/avatar/256.png" />
</a>
<a href="https://marmelab.com/" target="_blank">
  <img src="https://images.opencollective.com/marmelab/d7fd82f/logo/256.png" width="48" height="48" />
</a>
<a target="_blank" href="https://formcarry.com/">
    <img width="48" src="https://images.opencollective.com/formcarry/a40a4ea/logo/256.png" />
</a>
<a target="_blank" href="https://fabform.io">
    <img width="48" src="https://images.opencollective.com/fabform/2834037/logo/256.png" />
</a>
<a target="_blank" href="https://www.thinkmill.com.au/">
    <img width="48" src="https://images.opencollective.com/thinkmill/28910ec/logo/256.png" />
</a>
<a target="_blank" href="https://kwork.studio/">
    <img width="48" src="https://images.opencollective.com/knowledge-work/f91b72d/logo/256.png" />
</a>
<a target="_blank" href="https://fiberplane.com/">
    <img width="48" src="https://avatars.githubusercontent.com/u/61152955?s=200&v=4" />
</a>
<a target="_blank" href="https://www.jetbrains.com/">
    <img width="48" src="https://resources.jetbrains.com/storage/products/company/brand/logos/jb_beam.png" />
</a>
<a target="_blank" href="https://www.mirakl.com/">
    <img width="48" src="https://images.opencollective.com/mirakl/0b191f0/logo/256.png" />
</a>
<a target="_blank" href='https://wantedlyinc.com'>
    <img width="48" src="https://images.opencollective.com/wantedly/d94e44e/logo/256.png" />
</a>

### Backers

Thanks go to all our backers! [[Become a backer](https://opencollective.com/react-hook-form#backer)].

<a href="https://opencollective.com/react-hook-form#backers">
    <img src="https://opencollective.com/react-hook-form/backers.svg?width=950" />
</a>

### Contributors

Thanks go to these wonderful people! [[Become a contributor](CONTRIBUTING.md)].

<a href="https://github.com/react-hook-form/react-hook-form/graphs/contributors">
  <img src="https://opencollective.com/react-hook-form/contributors.svg?width=890&button=false" />
</a>


================================================
File: /app/.env
================================================
SKIP_PREFLIGHT_CHECK=true


================================================
File: /app/.npmrc
================================================
auto-install-peers=true


================================================
File: /app/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Hook Form Automation App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================
File: /app/vite.config.ts
================================================
import reactPlugin from '@vitejs/plugin-react';
import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [reactPlugin()],
  // TODO: For now, `pnpm dev` does not do the HMR when we update RHF source code.
  // It requires to restart the dev server (with --force flag).
  // This related to an open issue from Vite https://github.com/vitejs/vite/issues/4533
  // In Vite docs, they mention a workaround but it might not work.
  // https://vitejs.dev/guide/dep-pre-bundling.html#monorepos-and-linked-dependencies
  // So, for now, after updating RHF source code, please restart the `pnpm dev` for the update to take effect.
  server: {
    port: 3000,
  },
});


================================================
File: /app/package.json
================================================
{
  "name": "react-hook-form",
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --force",
    "build": "tsc && vite build",
    "serve": "vite preview"
  },
  "license": "MIT",
  "dependencies": {
    "@emotion/react": "^11.11.4",
    "@emotion/styled": "^11.11.5",
    "@hookform/resolvers": "3.9.0",
    "@mui/material": "^5.16.0",
    "joi": "^17.13.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "file:..",
    "react-router-dom": "^6.24.1",
    "react-select": "^5.8.0",
    "yup": "^1.4.0"
  },
  "devDependencies": {
    "@types/react": "^17.0.38",
    "@types/react-dom": "^17.0.9",
    "@types/yup": "^0.29.14",
    "@vitejs/plugin-react": "^4.3.1",
    "typescript": "^5.5.3",
    "vite": "^5.3.3"
  }
}


================================================
File: /app/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "types": ["vite/client"],
    "allowJs": false,
    "skipLibCheck": false,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": ["./src"]
}


================================================
File: /app/README.md
================================================
# App for cypress automation
## What?
This app is used by cypress for e2e testing purpose

## Why?
We simply want to test each react-hook-form functionality in a separated environment.
The current app folder is used for this purpose.

## How?
Each react-hook-form functionality (ex. formState, reset, useFieldArray) that we want to test is rendered at specific route (see app.tsx)
Cypress uses those routes for testing (you could navigate those routes for manual testing: http://localhost:3000/).
## How can be used:

```
  1. npm i && npm run dev
``` 



================================================
File: /app/pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      '@emotion/react':
        specifier: ^11.11.4
        version: 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@emotion/styled':
        specifier: ^11.11.5
        version: 11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)
      '@hookform/resolvers':
        specifier: 3.9.0
        version: 3.9.0(react-hook-form@file:..(react@19.0.0))
      '@mui/material':
        specifier: ^5.16.0
        version: 5.16.0(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      joi:
        specifier: ^17.13.3
        version: 17.13.3
      react:
        specifier: ^19.0.0
        version: 19.0.0
      react-dom:
        specifier: ^19.0.0
        version: 19.0.0(react@19.0.0)
      react-hook-form:
        specifier: file:..
        version: file:..(react@19.0.0)
      react-router-dom:
        specifier: ^6.24.1
        version: 6.24.1(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      react-select:
        specifier: ^5.8.0
        version: 5.8.0(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      yup:
        specifier: ^1.4.0
        version: 1.4.0
    devDependencies:
      '@types/react':
        specifier: ^17.0.38
        version: 17.0.52
      '@types/react-dom':
        specifier: ^17.0.9
        version: 17.0.18
      '@types/yup':
        specifier: ^0.29.14
        version: 0.29.14
      '@vitejs/plugin-react':
        specifier: ^4.3.1
        version: 4.3.1(vite@5.3.3)
      typescript:
        specifier: ^5.5.3
        version: 5.5.3
      vite:
        specifier: ^5.3.3
        version: 5.3.3

packages:

  '@ampproject/remapping@2.2.0':
    resolution: {integrity: sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==}
    engines: {node: '>=6.0.0'}

  '@babel/code-frame@7.24.7':
    resolution: {integrity: sha512-BcYH1CVJBO9tvyIZ2jVeXgSIMvGZ2FDRvDdOIVQyuklNKSsx+eppDEBq/g47Ayw+RqNFE+URvOShmf+f/qwAlA==}
    engines: {node: '>=6.9.0'}

  '@babel/compat-data@7.24.7':
    resolution: {integrity: sha512-qJzAIcv03PyaWqxRgO4mSU3lihncDT296vnyuE2O8uA4w3UHWI4S3hgeZd1L8W1Bft40w9JxJ2b412iDUFFRhw==}
    engines: {node: '>=6.9.0'}

  '@babel/core@7.24.7':
    resolution: {integrity: sha512-nykK+LEK86ahTkX/3TgauT0ikKoNCfKHEaZYTUVupJdTLzGNvrblu4u6fa7DhZONAltdf8e662t/abY8idrd/g==}
    engines: {node: '>=6.9.0'}

  '@babel/generator@7.24.7':
    resolution: {integrity: sha512-oipXieGC3i45Y1A41t4tAqpnEZWgB/lC6Ehh6+rOviR5XWpTtMmLN+fGjz9vOiNRt0p6RtO6DtD0pdU3vpqdSA==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-compilation-targets@7.24.7':
    resolution: {integrity: sha512-ctSdRHBi20qWOfy27RUb4Fhp07KSJ3sXcuSvTrXrc4aG8NSYDo1ici3Vhg9bg69y5bj0Mr1lh0aeEgTvc12rMg==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-environment-visitor@7.24.7':
    resolution: {integrity: sha512-DoiN84+4Gnd0ncbBOM9AZENV4a5ZiL39HYMyZJGZ/AZEykHYdJw0wW3kdcsh9/Kn+BRXHLkkklZ51ecPKmI1CQ==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-function-name@7.24.7':
    resolution: {integrity: sha512-FyoJTsj/PEUWu1/TYRiXTIHc8lbw+TDYkZuoE43opPS5TrI7MyONBE1oNvfguEXAD9yhQRrVBnXdXzSLQl9XnA==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-hoist-variables@7.24.7':
    resolution: {integrity: sha512-MJJwhkoGy5c4ehfoRyrJ/owKeMl19U54h27YYftT0o2teQ3FJ3nQUf/I3LlJsX4l3qlw7WRXUmiyajvHXoTubQ==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-module-imports@7.24.7':
    resolution: {integrity: sha512-8AyH3C+74cgCVVXow/myrynrAGv+nTVg5vKu2nZph9x7RcRwzmh0VFallJuFTZ9mx6u4eSdXZfcOzSqTUm0HCA==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-module-transforms@7.24.7':
    resolution: {integrity: sha512-1fuJEwIrp+97rM4RWdO+qrRsZlAeL1lQJoPqtCYWv0NL115XM93hIH4CSRln2w52SqvmY5hqdtauB6QFCDiZNQ==}
    engines: {node: '>=6.9.0'}
    peerDependencies:
      '@babel/core': ^7.0.0

  '@babel/helper-plugin-utils@7.24.7':
    resolution: {integrity: sha512-Rq76wjt7yz9AAc1KnlRKNAi/dMSVWgDRx43FHoJEbcYU6xOWaE2dVPwcdTukJrjxS65GITyfbvEYHvkirZ6uEg==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-simple-access@7.24.7':
    resolution: {integrity: sha512-zBAIvbCMh5Ts+b86r/CjU+4XGYIs+R1j951gxI3KmmxBMhCg4oQMsv6ZXQ64XOm/cvzfU1FmoCyt6+owc5QMYg==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-split-export-declaration@7.24.7':
    resolution: {integrity: sha512-oy5V7pD+UvfkEATUKvIjvIAH/xCzfsFVw7ygW2SI6NClZzquT+mwdTfgfdbUiceh6iQO0CHtCPsyze/MZ2YbAA==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-string-parser@7.24.7':
    resolution: {integrity: sha512-7MbVt6xrwFQbunH2DNQsAP5sTGxfqQtErvBIvIMi6EQnbgUOuVYanvREcmFrOPhoXBrTtjhhP+lW+o5UfK+tDg==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-validator-identifier@7.24.7':
    resolution: {integrity: sha512-rR+PBcQ1SMQDDyF6X0wxtG8QyLCgUB0eRAGguqRLfkCA87l7yAP7ehq8SNj96OOGTO8OBV70KhuFYcIkHXOg0w==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-validator-option@7.24.7':
    resolution: {integrity: sha512-yy1/KvjhV/ZCL+SM7hBrvnZJ3ZuT9OuZgIJAGpPEToANvc3iM6iDvBnRjtElWibHU6n8/LPR/EjX9EtIEYO3pw==}
    engines: {node: '>=6.9.0'}

  '@babel/helpers@7.24.7':
    resolution: {integrity: sha512-NlmJJtvcw72yRJRcnCmGvSi+3jDEg8qFu3z0AFoymmzLx5ERVWyzd9kVXr7Th9/8yIJi2Zc6av4Tqz3wFs8QWg==}
    engines: {node: '>=6.9.0'}

  '@babel/highlight@7.24.7':
    resolution: {integrity: sha512-EStJpq4OuY8xYfhGVXngigBJRWxftKX9ksiGDnmlY3o7B/V7KIAc9X4oiK87uPJSc/vs5L869bem5fhZa8caZw==}
    engines: {node: '>=6.9.0'}

  '@babel/parser@7.24.7':
    resolution: {integrity: sha512-9uUYRm6OqQrCqQdG1iCBwBPZgN8ciDBro2nIOFaiRz1/BCxaI7CNvQbDHvsArAC7Tw9Hda/B3U+6ui9u4HWXPw==}
    engines: {node: '>=6.0.0'}
    hasBin: true

  '@babel/plugin-transform-react-jsx-self@7.24.7':
    resolution: {integrity: sha512-fOPQYbGSgH0HUp4UJO4sMBFjY6DuWq+2i8rixyUMb3CdGixs/gccURvYOAhajBdKDoGajFr3mUq5rH3phtkGzw==}
    engines: {node: '>=6.9.0'}
    peerDependencies:
      '@babel/core': ^7.0.0-0

  '@babel/plugin-transform-react-jsx-source@7.24.7':
    resolution: {integrity: sha512-J2z+MWzZHVOemyLweMqngXrgGC42jQ//R0KdxqkIz/OrbVIIlhFI3WigZ5fO+nwFvBlncr4MGapd8vTyc7RPNQ==}
    engines: {node: '>=6.9.0'}
    peerDependencies:
      '@babel/core': ^7.0.0-0

  '@babel/runtime@7.20.6':
    resolution: {integrity: sha512-Q+8MqP7TiHMWzSfwiJwXCjyf4GYA4Dgw3emg/7xmwsdLJOZUp+nMqcOwOzzYheuM1rhDu8FSj2l0aoMygEuXuA==}
    engines: {node: '>=6.9.0'}

  '@babel/runtime@7.24.7':
    resolution: {integrity: sha512-UwgBRMjJP+xv857DCngvqXI3Iq6J4v0wXmwc6sapg+zyhbwmQX67LUEFrkK5tbyJ30jGuG3ZvWpBiB9LCy1kWw==}
    engines: {node: '>=6.9.0'}

  '@babel/template@7.24.7':
    resolution: {integrity: sha512-jYqfPrU9JTF0PmPy1tLYHW4Mp4KlgxJD9l2nP9fD6yT/ICi554DmrWBAEYpIelzjHf1msDP3PxJIRt/nFNfBig==}
    engines: {node: '>=6.9.0'}

  '@babel/traverse@7.24.7':
    resolution: {integrity: sha512-yb65Ed5S/QAcewNPh0nZczy9JdYXkkAbIsEo+P7BE7yO3txAY30Y/oPa3QkQ5It3xVG2kpKMg9MsdxZaO31uKA==}
    engines: {node: '>=6.9.0'}

  '@babel/types@7.24.7':
    resolution: {integrity: sha512-XEFXSlxiG5td2EJRe8vOmRbaXVgfcBlszKujvVmWIK/UpywWljQCfzAv3RQCGujWQ1RD4YYWEAqDXfuJiy8f5Q==}
    engines: {node: '>=6.9.0'}

  '@emotion/babel-plugin@11.11.0':
    resolution: {integrity: sha512-m4HEDZleaaCH+XgDDsPF15Ht6wTLsgDTeR3WYj9Q/k76JtWhrJjcP4+/XlG8LGT/Rol9qUfOIztXeA84ATpqPQ==}

  '@emotion/cache@11.10.5':
    resolution: {integrity: sha512-dGYHWyzTdmK+f2+EnIGBpkz1lKc4Zbj2KHd4cX3Wi8/OWr5pKslNjc3yABKH4adRGCvSX4VDC0i04mrrq0aiRA==}

  '@emotion/cache@11.11.0':
    resolution: {integrity: sha512-P34z9ssTCBi3e9EI1ZsWpNHcfY1r09ZO0rZbRO2ob3ZQMnFI35jB536qoXbkdesr5EUhYi22anuEJuyxifaqAQ==}

  '@emotion/hash@0.9.1':
    resolution: {integrity: sha512-gJB6HLm5rYwSLI6PQa+X1t5CFGrv1J1TWG+sOyMCeKz2ojaj6Fnl/rZEspogG+cvqbt4AE/2eIyD2QfLKTBNlQ==}

  '@emotion/is-prop-valid@1.2.2':
    resolution: {integrity: sha512-uNsoYd37AFmaCdXlg6EYD1KaPOaRWRByMCYzbKUX4+hhMfrxdVSelShywL4JVaAeM/eHUOSprYBQls+/neX3pw==}

  '@emotion/memoize@0.8.0':
    resolution: {integrity: sha512-G/YwXTkv7Den9mXDO7AhLWkE3q+I92B+VqAE+dYG4NGPaHZGvt3G8Q0p9vmE+sq7rTGphUbAvmQ9YpbfMQGGlA==}

  '@emotion/memoize@0.8.1':
    resolution: {integrity: sha512-W2P2c/VRW1/1tLox0mVUalvnWXxavmv/Oum2aPsRcoDJuob75FC3Y8FbpfLwUegRcxINtGUMPq0tFCvYNTBXNA==}

  '@emotion/react@11.11.4':
    resolution: {integrity: sha512-t8AjMlF0gHpvvxk5mAtCqR4vmxiGHCeJBaQO6gncUSdklELOgtwjerNY2yuJNfwnc6vi16U/+uMF+afIawJ9iw==}
    peerDependencies:
      '@types/react': '*'
      react: '>=16.8.0'
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@emotion/serialize@1.1.4':
    resolution: {integrity: sha512-RIN04MBT8g+FnDwgvIUi8czvr1LU1alUMI05LekWB5DGyTm8cCBMCRpq3GqaiyEDRptEXOyXnvZ58GZYu4kBxQ==}

  '@emotion/sheet@1.2.1':
    resolution: {integrity: sha512-zxRBwl93sHMsOj4zs+OslQKg/uhF38MB+OMKoCrVuS0nyTkqnau+BM3WGEoOptg9Oz45T/aIGs1qbVAsEFo3nA==}

  '@emotion/sheet@1.2.2':
    resolution: {integrity: sha512-0QBtGvaqtWi+nx6doRwDdBIzhNdZrXUppvTM4dtZZWEGTXL/XE/yJxLMGlDT1Gt+UHH5IX1n+jkXyytE/av7OA==}

  '@emotion/styled@11.11.5':
    resolution: {integrity: sha512-/ZjjnaNKvuMPxcIiUkf/9SHoG4Q196DRl1w82hQ3WCsjo1IUR8uaGWrC6a87CrYAW0Kb/pK7hk8BnLgLRi9KoQ==}
    peerDependencies:
      '@emotion/react': ^11.0.0-rc.0
      '@types/react': '*'
      react: '>=16.8.0'
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@emotion/unitless@0.8.1':
    resolution: {integrity: sha512-KOEGMu6dmJZtpadb476IsZBclKvILjopjUii3V+7MnXIQCYh8W3NgNcgwo21n9LXZX6EDIKvqfjYxXebDwxKmQ==}

  '@emotion/use-insertion-effect-with-fallbacks@1.0.1':
    resolution: {integrity: sha512-jT/qyKZ9rzLErtrjGgdkMBn2OP8wl0G3sQlBb3YPryvKHsjvINUhVaPFfP+fpBcOkmrVOVEEHQFJ7nbj2TH2gw==}
    peerDependencies:
      react: '>=16.8.0'

  '@emotion/utils@1.2.0':
    resolution: {integrity: sha512-sn3WH53Kzpw8oQ5mgMmIzzyAaH2ZqFEbozVVBSYp538E06OSE6ytOp7pRAjNQR+Q/orwqdQYJSe2m3hCOeznkw==}

  '@emotion/utils@1.2.1':
    resolution: {integrity: sha512-Y2tGf3I+XVnajdItskUCn6LX+VUDmP6lTL4fcqsXAv43dnlbZiuW4MWQW38rW/BVWSE7Q/7+XQocmpnRYILUmg==}

  '@emotion/weak-memoize@0.3.0':
    resolution: {integrity: sha512-AHPmaAx+RYfZz0eYu6Gviiagpmiyw98ySSlQvCUhVGDRtDFe4DBS0x1bSjdF3gqUDYOczB+yYvBTtEylYSdRhg==}

  '@emotion/weak-memoize@0.3.1':
    resolution: {integrity: sha512-EsBwpc7hBUJWAsNPBmJy4hxWx12v6bshQsldrVmjxJoc3isbxhOrF2IcCpaXxfvq03NwkI7sbsOLXbYuqF/8Ww==}

  '@esbuild/aix-ppc64@0.21.5':
    resolution: {integrity: sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==, tarball: https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/android-arm64@0.21.5':
    resolution: {integrity: sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==, tarball: https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm@0.21.5':
    resolution: {integrity: sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==, tarball: https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-x64@0.21.5':
    resolution: {integrity: sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==, tarball: https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [android]

  '@esbuild/darwin-arm64@0.21.5':
    resolution: {integrity: sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==, tarball: https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-x64@0.21.5':
    resolution: {integrity: sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==, tarball: https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/freebsd-arm64@0.21.5':
    resolution: {integrity: sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==, tarball: https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.21.5':
    resolution: {integrity: sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==, tarball: https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/linux-arm64@0.21.5':
    resolution: {integrity: sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==, tarball: https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm@0.21.5':
    resolution: {integrity: sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==, tarball: https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-ia32@0.21.5':
    resolution: {integrity: sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==, tarball: https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-loong64@0.21.5':
    resolution: {integrity: sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==, tarball: https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.21.5':
    resolution: {integrity: sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==, tarball: https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.21.5':
    resolution: {integrity: sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==, tarball: https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.21.5':
    resolution: {integrity: sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==, tarball: https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.21.5':
    resolution: {integrity: sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==, tarball: https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.21.5':
    resolution: {integrity: sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==, tarball: https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-x64@0.21.5':
    resolution: {integrity: sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==, tarball: https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-x64@0.21.5':
    resolution: {integrity: sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==, tarball: https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/sunos-x64@0.21.5':
    resolution: {integrity: sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==, tarball: https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.21.5':
    resolution: {integrity: sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==, tarball: https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.21.5':
    resolution: {integrity: sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==, tarball: https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.21.5':
    resolution: {integrity: sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==, tarball: https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [win32]

  '@floating-ui/core@1.0.2':
    resolution: {integrity: sha512-Skfy0YS3NJ5nV9us0uuPN0HDk1Q4edljaOhRBJGDWs9EBa7ZVMYBHRFlhLvvmwEoaIM9BlH6QJFn9/uZg0bACg==}

  '@floating-ui/dom@1.0.7':
    resolution: {integrity: sha512-6RsqvCYe0AYWtsGvuWqCm7mZytnXAZCjWtsWu1Kg8dI3INvj/DbKlDsZO+mKSaQdPT12uxIW9W2dAWJkPx4Y5g==}

  '@floating-ui/react-dom@2.1.1':
    resolution: {integrity: sha512-4h84MJt3CHrtG18mGsXuLCHMrug49d7DFkU0RMIyshRveBeyV2hmV/pDaF2Uxtu8kgq5r46llp5E5FQiR0K2Yg==}
    peerDependencies:
      react: '>=16.8.0'
      react-dom: '>=16.8.0'

  '@hapi/hoek@9.3.0':
    resolution: {integrity: sha512-/c6rf4UJlmHlC9b5BaNvzAcFv7HZ2QHaV0D4/HNlBdvFnvQq8RI4kYdhyPCl7Xj+oWvTWQ8ujhqS53LIgAe6KQ==}

  '@hapi/topo@5.1.0':
    resolution: {integrity: sha512-foQZKJig7Ob0BMAYBfcJk8d77QtOe7Wo4ox7ff1lQYoNNAb6jwcY1ncdoy2e9wQZzvNy7ODZCYJkK8kzmcAnAg==}

  '@hookform/resolvers@3.9.0':
    resolution: {integrity: sha512-bU0Gr4EepJ/EQsH/IwEzYLsT/PEj5C0ynLQ4m+GSHS+xKH4TfSelhluTgOaoc4kA5s7eCsQbM4wvZLzELmWzUg==}
    version: 3.9.0
    peerDependencies:
      react-hook-form: ^7.0.0

  '@jridgewell/gen-mapping@0.1.1':
    resolution: {integrity: sha512-sQXCasFk+U8lWYEe66WxRDOE9PjVz4vSM51fTu3Hw+ClTpUSQb718772vH3pyS5pShp6lvQM7SxgIDXXXmOX7w==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/gen-mapping@0.3.5':
    resolution: {integrity: sha512-IzL8ZoEDIBRWEzlCcRhOaCupYyN5gdIK+Q6fbFdPDg6HqX6jpkItn7DFIpW9LQzXG6Df9sA7+OKnq0qlz/GaQg==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/resolve-uri@3.1.0':
    resolution: {integrity: sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/set-array@1.1.2':
    resolution: {integrity: sha512-xnkseuNADM0gt2bs+BvhO0p78Mk762YnZdsuzFV018NoG1Sj1SCQvpSqa7XUaTam5vAGasABV9qXASMKnFMwMw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/set-array@1.2.1':
    resolution: {integrity: sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/sourcemap-codec@1.4.14':
    resolution: {integrity: sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==}

  '@jridgewell/trace-mapping@0.3.17':
    resolution: {integrity: sha512-MCNzAp77qzKca9+W/+I0+sEpaUnZoeasnghNeVc41VZCEKaCH73Vq3BZZ/SzWIgrqE4H4ceI+p+b6C0mHf9T4g==}

  '@jridgewell/trace-mapping@0.3.25':
    resolution: {integrity: sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==}

  '@mui/base@5.0.0-beta.40':
    resolution: {integrity: sha512-I/lGHztkCzvwlXpjD2+SNmvNQvB4227xBXhISPjEaJUXGImOQ9f3D2Yj/T3KasSI/h0MLWy74X0J6clhPmsRbQ==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@types/react': ^17.0.0 || ^18.0.0
      react: ^17.0.0 || ^18.0.0
      react-dom: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@mui/core-downloads-tracker@5.16.0':
    resolution: {integrity: sha512-8SLffXYPRVpcZx5QzxNE8fytTqzp+IuU3deZbQWg/vSaTlDpR5YVrQ4qQtXTi5cRdhOufV5INylmwlKK+//nPw==}

  '@mui/material@5.16.0':
    resolution: {integrity: sha512-DbR1NckTLpjt9Zut9EGQ70th86HfN0BYQgyYro6aXQrNfjzSwe3BJS1AyBQ5mJ7TdL6YVRqohfukxj9JlqZZUg==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@emotion/react': ^11.5.0
      '@emotion/styled': ^11.3.0
      '@types/react': ^17.0.0 || ^18.0.0
      react: ^17.0.0 || ^18.0.0
      react-dom: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@emotion/react':
        optional: true
      '@emotion/styled':
        optional: true
      '@types/react':
        optional: true

  '@mui/private-theming@5.16.0':
    resolution: {integrity: sha512-sYpubkO1MZOnxNyVOClrPNOTs0MfuRVVnAvCeMaOaXt6GimgQbnUcshYv2pSr6PFj+Mqzdff/FYOBceK8u5QgA==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@types/react': ^17.0.0 || ^18.0.0
      react: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@mui/styled-engine@5.15.14':
    resolution: {integrity: sha512-RILkuVD8gY6PvjZjqnWhz8fu68dVkqhM5+jYWfB5yhlSQKg+2rHkmEwm75XIeAqI3qwOndK6zELK5H6Zxn4NHw==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@emotion/react': ^11.4.1
      '@emotion/styled': ^11.3.0
      react: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@emotion/react':
        optional: true
      '@emotion/styled':
        optional: true

  '@mui/system@5.16.0':
    resolution: {integrity: sha512-9YbkC2m3+pNumAvubYv+ijLtog6puJ0fJ6rYfzfLCM47pWrw3m+30nXNM8zMgDaKL6vpfWJcCXm+LPaWBpy7sw==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@emotion/react': ^11.5.0
      '@emotion/styled': ^11.3.0
      '@types/react': ^17.0.0 || ^18.0.0
      react: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@emotion/react':
        optional: true
      '@emotion/styled':
        optional: true
      '@types/react':
        optional: true

  '@mui/types@7.2.14':
    resolution: {integrity: sha512-MZsBZ4q4HfzBsywtXgM1Ksj6HDThtiwmOKUXH1pKYISI9gAVXCNHNpo7TlGoGrBaYWZTdNoirIN7JsQcQUjmQQ==}
    peerDependencies:
      '@types/react': ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@mui/utils@5.16.0':
    resolution: {integrity: sha512-kLLi5J1xY+mwtUlMb8Ubdxf4qFAA1+U7WPBvjM/qQ4CIwLCohNb0sHo1oYPufjSIH/Z9+dhVxD7dJlfGjd1AVA==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      '@types/react': ^17.0.0 || ^18.0.0
      react: ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@types/react':
        optional: true

  '@popperjs/core@2.11.8':
    resolution: {integrity: sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==}

  '@remix-run/router@1.17.1':
    resolution: {integrity: sha512-mCOMec4BKd6BRGBZeSnGiIgwsbLGp3yhVqAD8H+PxiRNEHgDpZb8J1TnrSDlg97t0ySKMQJTHCWBCmBpSmkF6Q==}
    engines: {node: '>=14.0.0'}

  '@rollup/rollup-android-arm-eabi@4.18.0':
    resolution: {integrity: sha512-Tya6xypR10giZV1XzxmH5wr25VcZSncG0pZIjfePT0OVBvqNEurzValetGNarVrGiq66EBVAFn15iYX4w6FKgQ==, tarball: https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.18.0.tgz}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm64@4.18.0':
    resolution: {integrity: sha512-avCea0RAP03lTsDhEyfy+hpfr85KfyTctMADqHVhLAF3MlIkq83CP8UfAHUssgXTYd+6er6PaAhx/QGv4L1EiA==, tarball: https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.18.0.tgz}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-darwin-arm64@4.18.0':
    resolution: {integrity: sha512-IWfdwU7KDSm07Ty0PuA/W2JYoZ4iTj3TUQjkVsO/6U+4I1jN5lcR71ZEvRh52sDOERdnNhhHU57UITXz5jC1/w==, tarball: https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.18.0.tgz}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.18.0':
    resolution: {integrity: sha512-n2LMsUz7Ynu7DoQrSQkBf8iNrjOGyPLrdSg802vk6XT3FtsgX6JbE8IHRvposskFm9SNxzkLYGSq9QdpLYpRNA==, tarball: https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.18.0.tgz}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-linux-arm-gnueabihf@4.18.0':
    resolution: {integrity: sha512-C/zbRYRXFjWvz9Z4haRxcTdnkPt1BtCkz+7RtBSuNmKzMzp3ZxdM28Mpccn6pt28/UWUCTXa+b0Mx1k3g6NOMA==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.18.0.tgz}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.18.0':
    resolution: {integrity: sha512-l3m9ewPgjQSXrUMHg93vt0hYCGnrMOcUpTz6FLtbwljo2HluS4zTXFy2571YQbisTnfTKPZ01u/ukJdQTLGh9A==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.18.0.tgz}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.18.0':
    resolution: {integrity: sha512-rJ5D47d8WD7J+7STKdCUAgmQk49xuFrRi9pZkWoRD1UeSMakbcepWXPF8ycChBoAqs1pb2wzvbY6Q33WmN2ftw==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.18.0.tgz}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.18.0':
    resolution: {integrity: sha512-be6Yx37b24ZwxQ+wOQXXLZqpq4jTckJhtGlWGZs68TgdKXJgw54lUUoFYrg6Zs/kjzAQwEwYbp8JxZVzZLRepQ==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.18.0.tgz}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-powerpc64le-gnu@4.18.0':
    resolution: {integrity: sha512-hNVMQK+qrA9Todu9+wqrXOHxFiD5YmdEi3paj6vP02Kx1hjd2LLYR2eaN7DsEshg09+9uzWi2W18MJDlG0cxJA==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-powerpc64le-gnu/-/rollup-linux-powerpc64le-gnu-4.18.0.tgz}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.18.0':
    resolution: {integrity: sha512-ROCM7i+m1NfdrsmvwSzoxp9HFtmKGHEqu5NNDiZWQtXLA8S5HBCkVvKAxJ8U+CVctHwV2Gb5VUaK7UAkzhDjlg==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.18.0.tgz}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.18.0':
    resolution: {integrity: sha512-0UyyRHyDN42QL+NbqevXIIUnKA47A+45WyasO+y2bGJ1mhQrfrtXUpTxCOrfxCR4esV3/RLYyucGVPiUsO8xjg==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.18.0.tgz}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.18.0':
    resolution: {integrity: sha512-xuglR2rBVHA5UsI8h8UbX4VJ470PtGCf5Vpswh7p2ukaqBGFTnsfzxUBetoWBWymHMxbIG0Cmx7Y9qDZzr648w==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.18.0.tgz}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.18.0':
    resolution: {integrity: sha512-LKaqQL9osY/ir2geuLVvRRs+utWUNilzdE90TpyoX0eNqPzWjRm14oMEE+YLve4k/NAqCdPkGYDaDF5Sw+xBfg==, tarball: https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.18.0.tgz}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-win32-arm64-msvc@4.18.0':
    resolution: {integrity: sha512-7J6TkZQFGo9qBKH0pk2cEVSRhJbL6MtfWxth7Y5YmZs57Pi+4x6c2dStAUvaQkHQLnEQv1jzBUW43GvZW8OFqA==, tarball: https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.18.0.tgz}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.18.0':
    resolution: {integrity: sha512-Txjh+IxBPbkUB9+SXZMpv+b/vnTEtFyfWZgJ6iyCmt2tdx0OF5WhFowLmnh8ENGNpfUlUZkdI//4IEmhwPieNg==, tarball: https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.18.0.tgz}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.18.0':
    resolution: {integrity: sha512-UOo5FdvOL0+eIVTgS4tIdbW+TtnBLWg1YBCcU2KWM7nuNwRz9bksDX1bekJJCpu25N1DVWaCwnT39dVQxzqS8g==, tarball: https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.18.0.tgz}
    cpu: [x64]
    os: [win32]

  '@sideway/address@4.1.5':
    resolution: {integrity: sha512-IqO/DUQHUkPeixNQ8n0JA6102hT9CmaljNTPmQ1u8MEhBo/R4Q8eKLN/vGZxuebwOroDB4cbpjheD4+/sKFK4Q==}

  '@sideway/formula@3.0.1':
    resolution: {integrity: sha512-/poHZJJVjx3L+zVD6g9KgHfYnb443oi7wLu/XKojDviHy6HOEOA6z1Trk5aR1dGcmPenJEgb2sK2I80LeS3MIg==}

  '@sideway/pinpoint@2.0.0':
    resolution: {integrity: sha512-RNiOoTPkptFtSVzQevY/yWtZwf/RxyVnPy/OcA9HBM3MlGDnBEYL5B41H0MTn0Uec8Hi+2qUtTfG2WWZBmMejQ==}

  '@types/babel__core@7.20.5':
    resolution: {integrity: sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==}

  '@types/babel__generator@7.6.8':
    resolution: {integrity: sha512-ASsj+tpEDsEiFr1arWrlN6V3mdfjRMZt6LtK/Vp/kreFLnr5QH5+DhvD5nINYZXzwJvXeGq+05iUXcAzVrqWtw==}

  '@types/babel__template@7.4.4':
    resolution: {integrity: sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==}

  '@types/babel__traverse@7.20.6':
    resolution: {integrity: sha512-r1bzfrm0tomOI8g1SzvCaQHo6Lcv6zu0EA+W2kHrt8dyrHQxGzBBL4kdkzIS+jBMV+EYcMAEAqXqYaLJq5rOZg==}

  '@types/estree@1.0.5':
    resolution: {integrity: sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw==}

  '@types/parse-json@4.0.0':
    resolution: {integrity: sha512-//oorEZjL6sbPcKUaCdIGlIUeH26mgzimjBB77G6XRgnDl/L5wOnpyBGRe/Mmf5CVW3PwEBE1NjiMZ/ssFh4wA==}

  '@types/prop-types@15.7.12':
    resolution: {integrity: sha512-5zvhXYtRNRluoE/jAp4GVsSduVUzNWKkOZrCDBWYtE7biZywwdC2AcEzg+cSMLFRfVgeAFqpfNabiPjxFddV1Q==}

  '@types/prop-types@15.7.5':
    resolution: {integrity: sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==}

  '@types/react-dom@17.0.18':
    resolution: {integrity: sha512-rLVtIfbwyur2iFKykP2w0pl/1unw26b5td16d5xMgp7/yjTHomkyxPYChFoCr/FtEX1lN9wY6lFj1qvKdS5kDw==}

  '@types/react-transition-group@4.4.10':
    resolution: {integrity: sha512-hT/+s0VQs2ojCX823m60m5f0sL5idt9SO6Tj6Dg+rdphGPIeJbJ6CxvBYkgkGKrYeDjvIpKTR38UzmtHJOGW3Q==}

  '@types/react-transition-group@4.4.5':
    resolution: {integrity: sha512-juKD/eiSM3/xZYzjuzH6ZwpP+/lejltmiS3QEzV/vmb/Q8+HfDmxu+Baga8UEMGBqV88Nbg4l2hY/K2DkyaLLA==}

  '@types/react@17.0.52':
    resolution: {integrity: sha512-vwk8QqVODi0VaZZpDXQCmEmiOuyjEFPY7Ttaw5vjM112LOq37yz1CDJGrRJwA1fYEq4Iitd5rnjd1yWAc/bT+A==}

  '@types/scheduler@0.16.2':
    resolution: {integrity: sha512-hppQEBDmlwhFAXKJX2KnWLYu5yMfi91yazPb2l+lbJiwW+wdo1gNeRA+3RgNSO39WYX2euey41KEwnqesU2Jew==}

  '@types/yup@0.29.14':
    resolution: {integrity: sha512-Ynb/CjHhE/Xp/4bhHmQC4U1Ox+I2OpfRYF3dnNgQqn1cHa6LK3H1wJMNPT02tSVZA6FYuXE2ITORfbnb6zBCSA==}

  '@vitejs/plugin-react@4.3.1':
    resolution: {integrity: sha512-m/V2syj5CuVnaxcUJOQRel/Wr31FFXRFlnOoq1TVtkCxsY5veGMTEmpWHndrhB2U8ScHtCQB1e+4hWYExQc6Lg==}
    engines: {node: ^14.18.0 || >=16.0.0}
    peerDependencies:
      vite: ^4.2.0 || ^5.0.0

  ansi-styles@3.2.1:
    resolution: {integrity: sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==}
    engines: {node: '>=4'}

  babel-plugin-macros@3.1.0:
    resolution: {integrity: sha512-Cg7TFGpIr01vOQNODXOOaGz2NpCU5gl8x1qJFbb6hbZxR7XrcE2vtbAsTAbJ7/xwJtUuJEw8K8Zr/AE0LHlesg==}
    engines: {node: '>=10', npm: '>=6'}

  browserslist@4.23.1:
    resolution: {integrity: sha512-TUfofFo/KsK/bWZ9TWQ5O26tsWW4Uhmt8IYklbnUa70udB6P2wA7w7o4PY4muaEPBQaAX+CEnmmIA41NVHtPVw==}
    engines: {node: ^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7}
    hasBin: true

  callsites@3.1.0:
    resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
    engines: {node: '>=6'}

  caniuse-lite@1.0.30001640:
    resolution: {integrity: sha512-lA4VMpW0PSUrFnkmVuEKBUovSWKhj7puyCg8StBChgu298N1AtuF1sKWEvfDuimSEDbhlb/KqPKC3fs1HbuQUA==}

  chalk@2.4.2:
    resolution: {integrity: sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==}
    engines: {node: '>=4'}

  clsx@2.1.1:
    resolution: {integrity: sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==}
    engines: {node: '>=6'}

  color-convert@1.9.3:
    resolution: {integrity: sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==}

  color-name@1.1.3:
    resolution: {integrity: sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==}

  convert-source-map@1.9.0:
    resolution: {integrity: sha512-ASFBup0Mz1uyiIjANan1jzLQami9z1PoYSZCiiYW2FczPbenXc45FZdBZLzOT+r6+iciuEModtmCti+hjaAk0A==}

  convert-source-map@2.0.0:
    resolution: {integrity: sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==}

  cosmiconfig@7.1.0:
    resolution: {integrity: sha512-AdmX6xUzdNASswsFtmwSt7Vj8po9IuqXm0UXz7QKPuEUmPB4XyjGfaAr2PSuELMwkRMVH1EpIkX5bTZGRB3eCA==}
    engines: {node: '>=10'}

  csstype@3.1.1:
    resolution: {integrity: sha512-DJR/VvkAvSZW9bTouZue2sSxDwdTN92uHjqeKVm+0dAqdfNykRzQ95tay8aXMBAAPpUiq4Qcug2L7neoRh2Egw==}

  csstype@3.1.3:
    resolution: {integrity: sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==}

  debug@4.3.4:
    resolution: {integrity: sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  dom-helpers@5.2.1:
    resolution: {integrity: sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==}

  electron-to-chromium@1.4.818:
    resolution: {integrity: sha512-eGvIk2V0dGImV9gWLq8fDfTTsCAeMDwZqEPMr+jMInxZdnp9Us8UpovYpRCf9NQ7VOFgrN2doNSgvISbsbNpxA==}

  error-ex@1.3.2:
    resolution: {integrity: sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==}

  esbuild@0.21.5:
    resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
    engines: {node: '>=12'}
    hasBin: true

  escalade@3.1.2:
    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}
    engines: {node: '>=6'}

  escape-string-regexp@1.0.5:
    resolution: {integrity: sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==}
    engines: {node: '>=0.8.0'}

  escape-string-regexp@4.0.0:
    resolution: {integrity: sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==}
    engines: {node: '>=10'}

  find-root@1.1.0:
    resolution: {integrity: sha512-NKfW6bec6GfKc0SGx1e07QZY9PE99u0Bft/0rzSD5k3sO/vwkVUpDUKVm5Gpp5Ue3YfShPFTX2070tDs5kB9Ng==}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==, tarball: https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.1:
    resolution: {integrity: sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==}

  gensync@1.0.0-beta.2:
    resolution: {integrity: sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==}
    engines: {node: '>=6.9.0'}

  globals@11.12.0:
    resolution: {integrity: sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==}
    engines: {node: '>=4'}

  has-flag@3.0.0:
    resolution: {integrity: sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==}
    engines: {node: '>=4'}

  has@1.0.3:
    resolution: {integrity: sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==}
    engines: {node: '>= 0.4.0'}

  hoist-non-react-statics@3.3.2:
    resolution: {integrity: sha512-/gGivxi8JPKWNm/W0jSmzcMPpfpPLc3dY/6GxhX2hQ9iGj3aDfklV4ET7NjKpSinLpJ5vafa9iiGIEZg10SfBw==}

  import-fresh@3.3.0:
    resolution: {integrity: sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==}
    engines: {node: '>=6'}

  is-arrayish@0.2.1:
    resolution: {integrity: sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==}

  is-core-module@2.11.0:
    resolution: {integrity: sha512-RRjxlvLDkD1YJwDbroBHMb+cukurkDWNyHx7D3oNB5x9rb5ogcksMC5wHCadcXoo67gVr/+3GFySh3134zi6rw==}

  joi@17.13.3:
    resolution: {integrity: sha512-otDA4ldcIx+ZXsKHWmp0YizCweVRZG96J10b0FevjfuncLO1oX59THoAmHkNubYJ+9gWsYsp5k8v4ib6oDv1fA==}

  js-tokens@4.0.0:
    resolution: {integrity: sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==}

  jsesc@2.5.2:
    resolution: {integrity: sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==}
    engines: {node: '>=4'}
    hasBin: true

  json-parse-even-better-errors@2.3.1:
    resolution: {integrity: sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==}

  json5@2.2.3:
    resolution: {integrity: sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==}
    engines: {node: '>=6'}
    hasBin: true

  lines-and-columns@1.2.4:
    resolution: {integrity: sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==}

  loose-envify@1.4.0:
    resolution: {integrity: sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==}
    hasBin: true

  lru-cache@5.1.1:
    resolution: {integrity: sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==}

  memoize-one@6.0.0:
    resolution: {integrity: sha512-rkpe71W0N0c0Xz6QD0eJETuWAJGnJ9afsl1srmwPrI+yBCkge5EycXXbYRyvL29zZVUWQCY7InPRCv3GDXuZNw==}

  ms@2.1.2:
    resolution: {integrity: sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==}

  nanoid@3.3.7:
    resolution: {integrity: sha512-eSRppjcPIatRIMC1U6UngP8XFcz8MQWGQdt1MTBQ7NaAmvXDfvNxbvWV3x2y6CdEUciCSsDHDQZbhYaB8QEo2g==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true

  node-releases@2.0.14:
    resolution: {integrity: sha512-y10wOWt8yZpqXmOgRo77WaHEmhYQYGNA6y421PKsKYWEK8aW+cqAphborZDhqfyKrbZEN92CN1X2KbafY2s7Yw==}

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  parent-module@1.0.1:
    resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
    engines: {node: '>=6'}

  parse-json@5.2.0:
    resolution: {integrity: sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==}
    engines: {node: '>=8'}

  path-parse@1.0.7:
    resolution: {integrity: sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==}

  path-type@4.0.0:
    resolution: {integrity: sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==}
    engines: {node: '>=8'}

  picocolors@1.0.0:
    resolution: {integrity: sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==}

  picocolors@1.0.1:
    resolution: {integrity: sha512-anP1Z8qwhkbmu7MFP5iTt+wQKXgwzf7zTyGlcdzabySa9vd0Xt392U0rVmz9poOaBj0uHJKyyo9/upk0HrEQew==}

  postcss@8.4.39:
    resolution: {integrity: sha512-0vzE+lAiG7hZl1/9I8yzKLx3aR9Xbof3fBHKunvMfOCYAtMhrsnccJY2iTURb9EZd5+pLuiNV9/c/GZJOHsgIw==}
    engines: {node: ^10 || ^12 || >=14}

  prop-types@15.8.1:
    resolution: {integrity: sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==}

  property-expr@2.0.5:
    resolution: {integrity: sha512-IJUkICM5dP5znhCckHSv30Q4b5/JA5enCtkRHYaOVOAocnH/1BQEYTC5NMfT3AVl/iXKdr3aqQbQn9DxyWknwA==}

  react-dom@19.0.0:
    resolution: {integrity: sha512-4GV5sHFG0e/0AD4X+ySy6UJd3jVl1iNsNHdpad0qhABJ11twS3TTBnseqsKurKcsNqCEFeGL3uLpVChpIO3QfQ==}
    peerDependencies:
      react: ^19.0.0

  react-hook-form@file:..:
    resolution: {directory: .., type: directory}
    engines: {node: '>=18.0.0'}
    peerDependencies:
      react: ^16.8.0 || ^17 || ^18 || ^19

  react-is@16.13.1:
    resolution: {integrity: sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==}

  react-is@18.3.1:
    resolution: {integrity: sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==}

  react-refresh@0.14.2:
    resolution: {integrity: sha512-jCvmsr+1IUSMUyzOkRcvnVbX3ZYC6g9TDrDbFuFmRDq7PD4yaGbLKNQL6k2jnArV8hjYxh7hVhAZB6s9HDGpZA==}
    engines: {node: '>=0.10.0'}

  react-router-dom@6.24.1:
    resolution: {integrity: sha512-U19KtXqooqw967Vw0Qcn5cOvrX5Ejo9ORmOtJMzYWtCT4/WOfFLIZGGsVLxcd9UkBO0mSTZtXqhZBsWlHr7+Sg==}
    engines: {node: '>=14.0.0'}
    peerDependencies:
      react: '>=16.8'
      react-dom: '>=16.8'

  react-router@6.24.1:
    resolution: {integrity: sha512-PTXFXGK2pyXpHzVo3rR9H7ip4lSPZZc0bHG5CARmj65fTT6qG7sTngmb6lcYu1gf3y/8KxORoy9yn59pGpCnpg==}
    engines: {node: '>=14.0.0'}
    peerDependencies:
      react: '>=16.8'

  react-select@5.8.0:
    resolution: {integrity: sha512-TfjLDo58XrhP6VG5M/Mi56Us0Yt8X7xD6cDybC7yoRMUNm7BGO7qk8J0TLQOua/prb8vUOtsfnXZwfm30HGsAA==}
    peerDependencies:
      react: ^16.8.0 || ^17.0.0 || ^18.0.0
      react-dom: ^16.8.0 || ^17.0.0 || ^18.0.0

  react-transition-group@4.4.5:
    resolution: {integrity: sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==}
    peerDependencies:
      react: '>=16.6.0'
      react-dom: '>=16.6.0'

  react@19.0.0:
    resolution: {integrity: sha512-V8AVnmPIICiWpGfm6GLzCR/W5FXLchHop40W4nXBmdlEceh16rCN8O8LNWm5bh5XUX91fh7KpA+W0TgMKmgTpQ==}
    engines: {node: '>=0.10.0'}

  regenerator-runtime@0.13.11:
    resolution: {integrity: sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==}

  regenerator-runtime@0.14.1:
    resolution: {integrity: sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==}

  resolve-from@4.0.0:
    resolution: {integrity: sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==}
    engines: {node: '>=4'}

  resolve@1.22.1:
    resolution: {integrity: sha512-nBpuuYuY5jFsli/JIs1oldw6fOQCBioohqWZg/2hiaOybXOft4lonv85uDOKXdf8rhyK159cxU5cDcK/NKk8zw==}
    hasBin: true

  rollup@4.18.0:
    resolution: {integrity: sha512-QmJz14PX3rzbJCN1SG4Xe/bAAX2a6NpCP8ab2vfu2GiUr8AQcr2nCV/oEO3yneFarB67zk8ShlIyWb2LGTb3Sg==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  scheduler@0.25.0:
    resolution: {integrity: sha512-xFVuu11jh+xcO7JOAGJNOXld8/TcEHK/4CituBUeUb5hqxJLj9YuemAEuvm9gQ/+pgXYfbQuqAkiYu+u7YEsNA==}

  semver@6.3.1:
    resolution: {integrity: sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==}
    hasBin: true

  source-map-js@1.2.0:
    resolution: {integrity: sha512-itJW8lvSA0TXEphiRoawsCksnlf8SyvmFzIhltqAHluXd88pkCd+cXJVHTDwdCr0IzwptSm035IHQktUu1QUMg==}
    engines: {node: '>=0.10.0'}

  source-map@0.5.7:
    resolution: {integrity: sha512-LbrmJOMUSdEVxIKvdcJzQC+nQhe8FUZQTXQy6+I75skNgn3OoQ0DZA8YnFa7gp8tqtL3KPf1kmo0R5DoApeSGQ==}
    engines: {node: '>=0.10.0'}

  stylis@4.1.3:
    resolution: {integrity: sha512-GP6WDNWf+o403jrEp9c5jibKavrtLW+/qYGhFxFrG8maXhwTBI7gLLhiBb0o7uFccWN+EOS9aMO6cGHWAO07OA==}

  stylis@4.2.0:
    resolution: {integrity: sha512-Orov6g6BB1sDfYgzWfTHDOxamtX1bE/zo104Dh9e6fqJ3PooipYyfJ0pUmrZO2wAvO8YbEyeFrkV91XTsGMSrw==}

  supports-color@5.5.0:
    resolution: {integrity: sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==}
    engines: {node: '>=4'}

  supports-preserve-symlinks-flag@1.0.0:
    resolution: {integrity: sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==}
    engines: {node: '>= 0.4'}

  tiny-case@1.0.3:
    resolution: {integrity: sha512-Eet/eeMhkO6TX8mnUteS9zgPbUMQa4I6Kkp5ORiBD5476/m+PIRiumP5tmh5ioJpH7k51Kehawy2UDfsnxxY8Q==}

  to-fast-properties@2.0.0:
    resolution: {integrity: sha512-/OaKK0xYrs3DmxRYqL/yDc+FxFUVYhDlXMhRmv3z915w2HF1tnN1omB354j8VUGO/hbRzyD6Y3sA7v7GS/ceog==}
    engines: {node: '>=4'}

  toposort@2.0.2:
    resolution: {integrity: sha512-0a5EOkAUp8D4moMi2W8ZF8jcga7BgZd91O/yabJCFY8az+XSzeGyTKs0Aoo897iV1Nj6guFq8orWDS96z91oGg==}

  type-fest@2.19.0:
    resolution: {integrity: sha512-RAH822pAdBgcNMAfWnCBU3CFZcfZ/i1eZjwFU/dsLKumyuuP3niueg2UAukXYF0E2AAoc82ZSSf9J0WQBinzHA==}
    engines: {node: '>=12.20'}

  typescript@5.5.3:
    resolution: {integrity: sha512-/hreyEujaB0w76zKo6717l3L0o/qEUtRgdvUBvlkhoWeOVMjMuHNHk0BRBzikzuGDqNmPQbg5ifMEqsHLiIUcQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  update-browserslist-db@1.1.0:
    resolution: {integrity: sha512-EdRAaAyk2cUE1wOf2DkEhzxqOQvFOoRJFNS6NeyJ01Gp2beMRpBAINjM2iDXE3KCuKhwnvHIQCJm6ThL2Z+HzQ==}
    hasBin: true
    peerDependencies:
      browserslist: '>= 4.21.0'

  use-isomorphic-layout-effect@1.1.2:
    resolution: {integrity: sha512-49L8yCO3iGT/ZF9QttjwLF/ZD9Iwto5LnH5LmEdk/6cFmXddqi2ulF0edxTwjj+7mqvpVVGQWvbXZdn32wRSHA==}
    peerDependencies:
      '@types/react': '*'
      react: ^16.8.0 || ^17.0.0 || ^18.0.0
    peerDependenciesMeta:
      '@types/react':
        optional: true

  vite@5.3.3:
    resolution: {integrity: sha512-NPQdeCU0Dv2z5fu+ULotpuq5yfCS1BzKUIPhNbP3YBfAMGJXbt2nS+sbTFu+qchaqWTD+H3JK++nRwr6XIcp6A==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^18.0.0 || >=20.0.0
      less: '*'
      lightningcss: ^1.21.0
      sass: '*'
      stylus: '*'
      sugarss: '*'
      terser: ^5.4.0
    peerDependenciesMeta:
      '@types/node':
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true

  yallist@3.1.1:
    resolution: {integrity: sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==}

  yaml@1.10.2:
    resolution: {integrity: sha512-r3vXyErRCYJ7wg28yvBY5VSoAF8ZvlcW9/BwUzEtUsjvX/DKs24dIkuwjtuprwJJHsbyUbLApepYTR1BN4uHrg==}
    engines: {node: '>= 6'}

  yup@1.4.0:
    resolution: {integrity: sha512-wPbgkJRCqIf+OHyiTBQoJiP5PFuAXaWiJK6AmYkzQAh5/c2K9hzSApBZG5wV9KoKSePF7sAxmNSvh/13YHkFDg==}

snapshots:

  '@ampproject/remapping@2.2.0':
    dependencies:
      '@jridgewell/gen-mapping': 0.1.1
      '@jridgewell/trace-mapping': 0.3.17

  '@babel/code-frame@7.24.7':
    dependencies:
      '@babel/highlight': 7.24.7
      picocolors: 1.0.0

  '@babel/compat-data@7.24.7': {}

  '@babel/core@7.24.7':
    dependencies:
      '@ampproject/remapping': 2.2.0
      '@babel/code-frame': 7.24.7
      '@babel/generator': 7.24.7
      '@babel/helper-compilation-targets': 7.24.7
      '@babel/helper-module-transforms': 7.24.7(@babel/core@7.24.7)
      '@babel/helpers': 7.24.7
      '@babel/parser': 7.24.7
      '@babel/template': 7.24.7
      '@babel/traverse': 7.24.7
      '@babel/types': 7.24.7
      convert-source-map: 2.0.0
      debug: 4.3.4
      gensync: 1.0.0-beta.2
      json5: 2.2.3
      semver: 6.3.1
    transitivePeerDependencies:
      - supports-color

  '@babel/generator@7.24.7':
    dependencies:
      '@babel/types': 7.24.7
      '@jridgewell/gen-mapping': 0.3.5
      '@jridgewell/trace-mapping': 0.3.25
      jsesc: 2.5.2

  '@babel/helper-compilation-targets@7.24.7':
    dependencies:
      '@babel/compat-data': 7.24.7
      '@babel/helper-validator-option': 7.24.7
      browserslist: 4.23.1
      lru-cache: 5.1.1
      semver: 6.3.1

  '@babel/helper-environment-visitor@7.24.7':
    dependencies:
      '@babel/types': 7.24.7

  '@babel/helper-function-name@7.24.7':
    dependencies:
      '@babel/template': 7.24.7
      '@babel/types': 7.24.7

  '@babel/helper-hoist-variables@7.24.7':
    dependencies:
      '@babel/types': 7.24.7

  '@babel/helper-module-imports@7.24.7':
    dependencies:
      '@babel/traverse': 7.24.7
      '@babel/types': 7.24.7
    transitivePeerDependencies:
      - supports-color

  '@babel/helper-module-transforms@7.24.7(@babel/core@7.24.7)':
    dependencies:
      '@babel/core': 7.24.7
      '@babel/helper-environment-visitor': 7.24.7
      '@babel/helper-module-imports': 7.24.7
      '@babel/helper-simple-access': 7.24.7
      '@babel/helper-split-export-declaration': 7.24.7
      '@babel/helper-validator-identifier': 7.24.7
    transitivePeerDependencies:
      - supports-color

  '@babel/helper-plugin-utils@7.24.7': {}

  '@babel/helper-simple-access@7.24.7':
    dependencies:
      '@babel/traverse': 7.24.7
      '@babel/types': 7.24.7
    transitivePeerDependencies:
      - supports-color

  '@babel/helper-split-export-declaration@7.24.7':
    dependencies:
      '@babel/types': 7.24.7

  '@babel/helper-string-parser@7.24.7': {}

  '@babel/helper-validator-identifier@7.24.7': {}

  '@babel/helper-validator-option@7.24.7': {}

  '@babel/helpers@7.24.7':
    dependencies:
      '@babel/template': 7.24.7
      '@babel/types': 7.24.7

  '@babel/highlight@7.24.7':
    dependencies:
      '@babel/helper-validator-identifier': 7.24.7
      chalk: 2.4.2
      js-tokens: 4.0.0
      picocolors: 1.0.0

  '@babel/parser@7.24.7':
    dependencies:
      '@babel/types': 7.24.7

  '@babel/plugin-transform-react-jsx-self@7.24.7(@babel/core@7.24.7)':
    dependencies:
      '@babel/core': 7.24.7
      '@babel/helper-plugin-utils': 7.24.7

  '@babel/plugin-transform-react-jsx-source@7.24.7(@babel/core@7.24.7)':
    dependencies:
      '@babel/core': 7.24.7
      '@babel/helper-plugin-utils': 7.24.7

  '@babel/runtime@7.20.6':
    dependencies:
      regenerator-runtime: 0.13.11

  '@babel/runtime@7.24.7':
    dependencies:
      regenerator-runtime: 0.14.1

  '@babel/template@7.24.7':
    dependencies:
      '@babel/code-frame': 7.24.7
      '@babel/parser': 7.24.7
      '@babel/types': 7.24.7

  '@babel/traverse@7.24.7':
    dependencies:
      '@babel/code-frame': 7.24.7
      '@babel/generator': 7.24.7
      '@babel/helper-environment-visitor': 7.24.7
      '@babel/helper-function-name': 7.24.7
      '@babel/helper-hoist-variables': 7.24.7
      '@babel/helper-split-export-declaration': 7.24.7
      '@babel/parser': 7.24.7
      '@babel/types': 7.24.7
      debug: 4.3.4
      globals: 11.12.0
    transitivePeerDependencies:
      - supports-color

  '@babel/types@7.24.7':
    dependencies:
      '@babel/helper-string-parser': 7.24.7
      '@babel/helper-validator-identifier': 7.24.7
      to-fast-properties: 2.0.0

  '@emotion/babel-plugin@11.11.0':
    dependencies:
      '@babel/helper-module-imports': 7.24.7
      '@babel/runtime': 7.20.6
      '@emotion/hash': 0.9.1
      '@emotion/memoize': 0.8.1
      '@emotion/serialize': 1.1.4
      babel-plugin-macros: 3.1.0
      convert-source-map: 1.9.0
      escape-string-regexp: 4.0.0
      find-root: 1.1.0
      source-map: 0.5.7
      stylis: 4.2.0
    transitivePeerDependencies:
      - supports-color

  '@emotion/cache@11.10.5':
    dependencies:
      '@emotion/memoize': 0.8.0
      '@emotion/sheet': 1.2.1
      '@emotion/utils': 1.2.0
      '@emotion/weak-memoize': 0.3.0
      stylis: 4.1.3

  '@emotion/cache@11.11.0':
    dependencies:
      '@emotion/memoize': 0.8.1
      '@emotion/sheet': 1.2.2
      '@emotion/utils': 1.2.1
      '@emotion/weak-memoize': 0.3.1
      stylis: 4.2.0

  '@emotion/hash@0.9.1': {}

  '@emotion/is-prop-valid@1.2.2':
    dependencies:
      '@emotion/memoize': 0.8.1

  '@emotion/memoize@0.8.0': {}

  '@emotion/memoize@0.8.1': {}

  '@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.20.6
      '@emotion/babel-plugin': 11.11.0
      '@emotion/cache': 11.11.0
      '@emotion/serialize': 1.1.4
      '@emotion/use-insertion-effect-with-fallbacks': 1.0.1(react@19.0.0)
      '@emotion/utils': 1.2.1
      '@emotion/weak-memoize': 0.3.1
      hoist-non-react-statics: 3.3.2
      react: 19.0.0
    optionalDependencies:
      '@types/react': 17.0.52
    transitivePeerDependencies:
      - supports-color

  '@emotion/serialize@1.1.4':
    dependencies:
      '@emotion/hash': 0.9.1
      '@emotion/memoize': 0.8.1
      '@emotion/unitless': 0.8.1
      '@emotion/utils': 1.2.1
      csstype: 3.1.1

  '@emotion/sheet@1.2.1': {}

  '@emotion/sheet@1.2.2': {}

  '@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.20.6
      '@emotion/babel-plugin': 11.11.0
      '@emotion/is-prop-valid': 1.2.2
      '@emotion/react': 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@emotion/serialize': 1.1.4
      '@emotion/use-insertion-effect-with-fallbacks': 1.0.1(react@19.0.0)
      '@emotion/utils': 1.2.1
      react: 19.0.0
    optionalDependencies:
      '@types/react': 17.0.52
    transitivePeerDependencies:
      - supports-color

  '@emotion/unitless@0.8.1': {}

  '@emotion/use-insertion-effect-with-fallbacks@1.0.1(react@19.0.0)':
    dependencies:
      react: 19.0.0

  '@emotion/utils@1.2.0': {}

  '@emotion/utils@1.2.1': {}

  '@emotion/weak-memoize@0.3.0': {}

  '@emotion/weak-memoize@0.3.1': {}

  '@esbuild/aix-ppc64@0.21.5':
    optional: true

  '@esbuild/android-arm64@0.21.5':
    optional: true

  '@esbuild/android-arm@0.21.5':
    optional: true

  '@esbuild/android-x64@0.21.5':
    optional: true

  '@esbuild/darwin-arm64@0.21.5':
    optional: true

  '@esbuild/darwin-x64@0.21.5':
    optional: true

  '@esbuild/freebsd-arm64@0.21.5':
    optional: true

  '@esbuild/freebsd-x64@0.21.5':
    optional: true

  '@esbuild/linux-arm64@0.21.5':
    optional: true

  '@esbuild/linux-arm@0.21.5':
    optional: true

  '@esbuild/linux-ia32@0.21.5':
    optional: true

  '@esbuild/linux-loong64@0.21.5':
    optional: true

  '@esbuild/linux-mips64el@0.21.5':
    optional: true

  '@esbuild/linux-ppc64@0.21.5':
    optional: true

  '@esbuild/linux-riscv64@0.21.5':
    optional: true

  '@esbuild/linux-s390x@0.21.5':
    optional: true

  '@esbuild/linux-x64@0.21.5':
    optional: true

  '@esbuild/netbsd-x64@0.21.5':
    optional: true

  '@esbuild/openbsd-x64@0.21.5':
    optional: true

  '@esbuild/sunos-x64@0.21.5':
    optional: true

  '@esbuild/win32-arm64@0.21.5':
    optional: true

  '@esbuild/win32-ia32@0.21.5':
    optional: true

  '@esbuild/win32-x64@0.21.5':
    optional: true

  '@floating-ui/core@1.0.2': {}

  '@floating-ui/dom@1.0.7':
    dependencies:
      '@floating-ui/core': 1.0.2

  '@floating-ui/react-dom@2.1.1(react-dom@19.0.0(react@19.0.0))(react@19.0.0)':
    dependencies:
      '@floating-ui/dom': 1.0.7
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)

  '@hapi/hoek@9.3.0': {}

  '@hapi/topo@5.1.0':
    dependencies:
      '@hapi/hoek': 9.3.0

  '@hookform/resolvers@3.9.0(react-hook-form@file:..(react@19.0.0))':
    dependencies:
      react-hook-form: file:..(react@19.0.0)

  '@jridgewell/gen-mapping@0.1.1':
    dependencies:
      '@jridgewell/set-array': 1.1.2
      '@jridgewell/sourcemap-codec': 1.4.14

  '@jridgewell/gen-mapping@0.3.5':
    dependencies:
      '@jridgewell/set-array': 1.2.1
      '@jridgewell/sourcemap-codec': 1.4.14
      '@jridgewell/trace-mapping': 0.3.25

  '@jridgewell/resolve-uri@3.1.0': {}

  '@jridgewell/set-array@1.1.2': {}

  '@jridgewell/set-array@1.2.1': {}

  '@jridgewell/sourcemap-codec@1.4.14': {}

  '@jridgewell/trace-mapping@0.3.17':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.0
      '@jridgewell/sourcemap-codec': 1.4.14

  '@jridgewell/trace-mapping@0.3.25':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.0
      '@jridgewell/sourcemap-codec': 1.4.14

  '@mui/base@5.0.0-beta.40(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@floating-ui/react-dom': 2.1.1(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      '@mui/types': 7.2.14(@types/react@17.0.52)
      '@mui/utils': 5.16.0(@types/react@17.0.52)(react@19.0.0)
      '@popperjs/core': 2.11.8
      clsx: 2.1.1
      prop-types: 15.8.1
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)
    optionalDependencies:
      '@types/react': 17.0.52

  '@mui/core-downloads-tracker@5.16.0': {}

  '@mui/material@5.16.0(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@mui/base': 5.0.0-beta.40(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      '@mui/core-downloads-tracker': 5.16.0
      '@mui/system': 5.16.0(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)
      '@mui/types': 7.2.14(@types/react@17.0.52)
      '@mui/utils': 5.16.0(@types/react@17.0.52)(react@19.0.0)
      '@types/react-transition-group': 4.4.10
      clsx: 2.1.1
      csstype: 3.1.3
      prop-types: 15.8.1
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)
      react-is: 18.3.1
      react-transition-group: 4.4.5(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
    optionalDependencies:
      '@emotion/react': 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@emotion/styled': 11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)
      '@types/react': 17.0.52

  '@mui/private-theming@5.16.0(@types/react@17.0.52)(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@mui/utils': 5.16.0(@types/react@17.0.52)(react@19.0.0)
      prop-types: 15.8.1
      react: 19.0.0
    optionalDependencies:
      '@types/react': 17.0.52

  '@mui/styled-engine@5.15.14(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@emotion/cache': 11.11.0
      csstype: 3.1.3
      prop-types: 15.8.1
      react: 19.0.0
    optionalDependencies:
      '@emotion/react': 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@emotion/styled': 11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)

  '@mui/system@5.16.0(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@mui/private-theming': 5.16.0(@types/react@17.0.52)(react@19.0.0)
      '@mui/styled-engine': 5.15.14(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@emotion/styled@11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0))(react@19.0.0)
      '@mui/types': 7.2.14(@types/react@17.0.52)
      '@mui/utils': 5.16.0(@types/react@17.0.52)(react@19.0.0)
      clsx: 2.1.1
      csstype: 3.1.3
      prop-types: 15.8.1
      react: 19.0.0
    optionalDependencies:
      '@emotion/react': 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@emotion/styled': 11.11.5(@emotion/react@11.11.4(@types/react@17.0.52)(react@19.0.0))(@types/react@17.0.52)(react@19.0.0)
      '@types/react': 17.0.52

  '@mui/types@7.2.14(@types/react@17.0.52)':
    optionalDependencies:
      '@types/react': 17.0.52

  '@mui/utils@5.16.0(@types/react@17.0.52)(react@19.0.0)':
    dependencies:
      '@babel/runtime': 7.24.7
      '@types/prop-types': 15.7.12
      prop-types: 15.8.1
      react: 19.0.0
      react-is: 18.3.1
    optionalDependencies:
      '@types/react': 17.0.52

  '@popperjs/core@2.11.8': {}

  '@remix-run/router@1.17.1': {}

  '@rollup/rollup-android-arm-eabi@4.18.0':
    optional: true

  '@rollup/rollup-android-arm64@4.18.0':
    optional: true

  '@rollup/rollup-darwin-arm64@4.18.0':
    optional: true

  '@rollup/rollup-darwin-x64@4.18.0':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.18.0':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.18.0':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.18.0':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.18.0':
    optional: true

  '@rollup/rollup-linux-powerpc64le-gnu@4.18.0':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.18.0':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.18.0':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.18.0':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.18.0':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.18.0':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.18.0':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.18.0':
    optional: true

  '@sideway/address@4.1.5':
    dependencies:
      '@hapi/hoek': 9.3.0

  '@sideway/formula@3.0.1': {}

  '@sideway/pinpoint@2.0.0': {}

  '@types/babel__core@7.20.5':
    dependencies:
      '@babel/parser': 7.24.7
      '@babel/types': 7.24.7
      '@types/babel__generator': 7.6.8
      '@types/babel__template': 7.4.4
      '@types/babel__traverse': 7.20.6

  '@types/babel__generator@7.6.8':
    dependencies:
      '@babel/types': 7.24.7

  '@types/babel__template@7.4.4':
    dependencies:
      '@babel/parser': 7.24.7
      '@babel/types': 7.24.7

  '@types/babel__traverse@7.20.6':
    dependencies:
      '@babel/types': 7.24.7

  '@types/estree@1.0.5': {}

  '@types/parse-json@4.0.0': {}

  '@types/prop-types@15.7.12': {}

  '@types/prop-types@15.7.5': {}

  '@types/react-dom@17.0.18':
    dependencies:
      '@types/react': 17.0.52

  '@types/react-transition-group@4.4.10':
    dependencies:
      '@types/react': 17.0.52

  '@types/react-transition-group@4.4.5':
    dependencies:
      '@types/react': 17.0.52

  '@types/react@17.0.52':
    dependencies:
      '@types/prop-types': 15.7.5
      '@types/scheduler': 0.16.2
      csstype: 3.1.1

  '@types/scheduler@0.16.2': {}

  '@types/yup@0.29.14': {}

  '@vitejs/plugin-react@4.3.1(vite@5.3.3)':
    dependencies:
      '@babel/core': 7.24.7
      '@babel/plugin-transform-react-jsx-self': 7.24.7(@babel/core@7.24.7)
      '@babel/plugin-transform-react-jsx-source': 7.24.7(@babel/core@7.24.7)
      '@types/babel__core': 7.20.5
      react-refresh: 0.14.2
      vite: 5.3.3
    transitivePeerDependencies:
      - supports-color

  ansi-styles@3.2.1:
    dependencies:
      color-convert: 1.9.3

  babel-plugin-macros@3.1.0:
    dependencies:
      '@babel/runtime': 7.20.6
      cosmiconfig: 7.1.0
      resolve: 1.22.1

  browserslist@4.23.1:
    dependencies:
      caniuse-lite: 1.0.30001640
      electron-to-chromium: 1.4.818
      node-releases: 2.0.14
      update-browserslist-db: 1.1.0(browserslist@4.23.1)

  callsites@3.1.0: {}

  caniuse-lite@1.0.30001640: {}

  chalk@2.4.2:
    dependencies:
      ansi-styles: 3.2.1
      escape-string-regexp: 1.0.5
      supports-color: 5.5.0

  clsx@2.1.1: {}

  color-convert@1.9.3:
    dependencies:
      color-name: 1.1.3

  color-name@1.1.3: {}

  convert-source-map@1.9.0: {}

  convert-source-map@2.0.0: {}

  cosmiconfig@7.1.0:
    dependencies:
      '@types/parse-json': 4.0.0
      import-fresh: 3.3.0
      parse-json: 5.2.0
      path-type: 4.0.0
      yaml: 1.10.2

  csstype@3.1.1: {}

  csstype@3.1.3: {}

  debug@4.3.4:
    dependencies:
      ms: 2.1.2

  dom-helpers@5.2.1:
    dependencies:
      '@babel/runtime': 7.20.6
      csstype: 3.1.1

  electron-to-chromium@1.4.818: {}

  error-ex@1.3.2:
    dependencies:
      is-arrayish: 0.2.1

  esbuild@0.21.5:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.21.5
      '@esbuild/android-arm': 0.21.5
      '@esbuild/android-arm64': 0.21.5
      '@esbuild/android-x64': 0.21.5
      '@esbuild/darwin-arm64': 0.21.5
      '@esbuild/darwin-x64': 0.21.5
      '@esbuild/freebsd-arm64': 0.21.5
      '@esbuild/freebsd-x64': 0.21.5
      '@esbuild/linux-arm': 0.21.5
      '@esbuild/linux-arm64': 0.21.5
      '@esbuild/linux-ia32': 0.21.5
      '@esbuild/linux-loong64': 0.21.5
      '@esbuild/linux-mips64el': 0.21.5
      '@esbuild/linux-ppc64': 0.21.5
      '@esbuild/linux-riscv64': 0.21.5
      '@esbuild/linux-s390x': 0.21.5
      '@esbuild/linux-x64': 0.21.5
      '@esbuild/netbsd-x64': 0.21.5
      '@esbuild/openbsd-x64': 0.21.5
      '@esbuild/sunos-x64': 0.21.5
      '@esbuild/win32-arm64': 0.21.5
      '@esbuild/win32-ia32': 0.21.5
      '@esbuild/win32-x64': 0.21.5

  escalade@3.1.2: {}

  escape-string-regexp@1.0.5: {}

  escape-string-regexp@4.0.0: {}

  find-root@1.1.0: {}

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.1: {}

  gensync@1.0.0-beta.2: {}

  globals@11.12.0: {}

  has-flag@3.0.0: {}

  has@1.0.3:
    dependencies:
      function-bind: 1.1.1

  hoist-non-react-statics@3.3.2:
    dependencies:
      react-is: 16.13.1

  import-fresh@3.3.0:
    dependencies:
      parent-module: 1.0.1
      resolve-from: 4.0.0

  is-arrayish@0.2.1: {}

  is-core-module@2.11.0:
    dependencies:
      has: 1.0.3

  joi@17.13.3:
    dependencies:
      '@hapi/hoek': 9.3.0
      '@hapi/topo': 5.1.0
      '@sideway/address': 4.1.5
      '@sideway/formula': 3.0.1
      '@sideway/pinpoint': 2.0.0

  js-tokens@4.0.0: {}

  jsesc@2.5.2: {}

  json-parse-even-better-errors@2.3.1: {}

  json5@2.2.3: {}

  lines-and-columns@1.2.4: {}

  loose-envify@1.4.0:
    dependencies:
      js-tokens: 4.0.0

  lru-cache@5.1.1:
    dependencies:
      yallist: 3.1.1

  memoize-one@6.0.0: {}

  ms@2.1.2: {}

  nanoid@3.3.7: {}

  node-releases@2.0.14: {}

  object-assign@4.1.1: {}

  parent-module@1.0.1:
    dependencies:
      callsites: 3.1.0

  parse-json@5.2.0:
    dependencies:
      '@babel/code-frame': 7.24.7
      error-ex: 1.3.2
      json-parse-even-better-errors: 2.3.1
      lines-and-columns: 1.2.4

  path-parse@1.0.7: {}

  path-type@4.0.0: {}

  picocolors@1.0.0: {}

  picocolors@1.0.1: {}

  postcss@8.4.39:
    dependencies:
      nanoid: 3.3.7
      picocolors: 1.0.1
      source-map-js: 1.2.0

  prop-types@15.8.1:
    dependencies:
      loose-envify: 1.4.0
      object-assign: 4.1.1
      react-is: 16.13.1

  property-expr@2.0.5: {}

  react-dom@19.0.0(react@19.0.0):
    dependencies:
      react: 19.0.0
      scheduler: 0.25.0

  react-hook-form@file:..(react@19.0.0):
    dependencies:
      react: 19.0.0

  react-is@16.13.1: {}

  react-is@18.3.1: {}

  react-refresh@0.14.2: {}

  react-router-dom@6.24.1(react-dom@19.0.0(react@19.0.0))(react@19.0.0):
    dependencies:
      '@remix-run/router': 1.17.1
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)
      react-router: 6.24.1(react@19.0.0)

  react-router@6.24.1(react@19.0.0):
    dependencies:
      '@remix-run/router': 1.17.1
      react: 19.0.0

  react-select@5.8.0(@types/react@17.0.52)(react-dom@19.0.0(react@19.0.0))(react@19.0.0):
    dependencies:
      '@babel/runtime': 7.20.6
      '@emotion/cache': 11.10.5
      '@emotion/react': 11.11.4(@types/react@17.0.52)(react@19.0.0)
      '@floating-ui/dom': 1.0.7
      '@types/react-transition-group': 4.4.5
      memoize-one: 6.0.0
      prop-types: 15.8.1
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)
      react-transition-group: 4.4.5(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
      use-isomorphic-layout-effect: 1.1.2(@types/react@17.0.52)(react@19.0.0)
    transitivePeerDependencies:
      - '@types/react'
      - supports-color

  react-transition-group@4.4.5(react-dom@19.0.0(react@19.0.0))(react@19.0.0):
    dependencies:
      '@babel/runtime': 7.20.6
      dom-helpers: 5.2.1
      loose-envify: 1.4.0
      prop-types: 15.8.1
      react: 19.0.0
      react-dom: 19.0.0(react@19.0.0)

  react@19.0.0: {}

  regenerator-runtime@0.13.11: {}

  regenerator-runtime@0.14.1: {}

  resolve-from@4.0.0: {}

  resolve@1.22.1:
    dependencies:
      is-core-module: 2.11.0
      path-parse: 1.0.7
      supports-preserve-symlinks-flag: 1.0.0

  rollup@4.18.0:
    dependencies:
      '@types/estree': 1.0.5
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.18.0
      '@rollup/rollup-android-arm64': 4.18.0
      '@rollup/rollup-darwin-arm64': 4.18.0
      '@rollup/rollup-darwin-x64': 4.18.0
      '@rollup/rollup-linux-arm-gnueabihf': 4.18.0
      '@rollup/rollup-linux-arm-musleabihf': 4.18.0
      '@rollup/rollup-linux-arm64-gnu': 4.18.0
      '@rollup/rollup-linux-arm64-musl': 4.18.0
      '@rollup/rollup-linux-powerpc64le-gnu': 4.18.0
      '@rollup/rollup-linux-riscv64-gnu': 4.18.0
      '@rollup/rollup-linux-s390x-gnu': 4.18.0
      '@rollup/rollup-linux-x64-gnu': 4.18.0
      '@rollup/rollup-linux-x64-musl': 4.18.0
      '@rollup/rollup-win32-arm64-msvc': 4.18.0
      '@rollup/rollup-win32-ia32-msvc': 4.18.0
      '@rollup/rollup-win32-x64-msvc': 4.18.0
      fsevents: 2.3.3

  scheduler@0.25.0: {}

  semver@6.3.1: {}

  source-map-js@1.2.0: {}

  source-map@0.5.7: {}

  stylis@4.1.3: {}

  stylis@4.2.0: {}

  supports-color@5.5.0:
    dependencies:
      has-flag: 3.0.0

  supports-preserve-symlinks-flag@1.0.0: {}

  tiny-case@1.0.3: {}

  to-fast-properties@2.0.0: {}

  toposort@2.0.2: {}

  type-fest@2.19.0: {}

  typescript@5.5.3: {}

  update-browserslist-db@1.1.0(browserslist@4.23.1):
    dependencies:
      browserslist: 4.23.1
      escalade: 3.1.2
      picocolors: 1.0.1

  use-isomorphic-layout-effect@1.1.2(@types/react@17.0.52)(react@19.0.0):
    dependencies:
      react: 19.0.0
    optionalDependencies:
      '@types/react': 17.0.52

  vite@5.3.3:
    dependencies:
      esbuild: 0.21.5
      postcss: 8.4.39
      rollup: 4.18.0
    optionalDependencies:
      fsevents: 2.3.3

  yallist@3.1.1: {}

  yaml@1.10.2: {}

  yup@1.4.0:
    dependencies:
      property-expr: 2.0.5
      tiny-case: 1.0.3
      toposort: 2.0.2
      type-fest: 2.19.0


================================================
File: /app/src/formStateWithSchema.tsx
================================================
import React from 'react';
import { useForm, ValidationMode } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const validationSchema = yup
  .object()
  .shape({
    firstName: yup.string().required(),
    lastName: yup.string().max(5).required(),
    select: yup.string().required(),
    radio: yup.string().required(),
    checkbox: yup.string().required(),
  })
  .required();

const FormStateWithSchema: React.FC = () => {
  const { mode } = useParams();
  const {
    register,
    handleSubmit,
    formState: {
      dirtyFields,
      isSubmitted,
      submitCount,
      touchedFields,
      isDirty,
      isSubmitting,
      isSubmitSuccessful,
      isValid,
    },
    reset,
  } = useForm<{
    firstName: string;
    lastName: string;
    select: string;
    radio: string | null;
    checkbox: boolean;
  }>({
    resolver: yupResolver(validationSchema),
    mode: mode as keyof ValidationMode,
    defaultValues: {
      firstName: '',
      lastName: '',
      select: '',
      checkbox: false,
      radio: null,
    },
  });
  const onSubmit = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} placeholder="firstName" />
      <input {...register('lastName')} placeholder="lastName" />
      <select {...register('select')}>
        <option value="">Select</option>
        <option value={1}>1</option>
        <option value={2}>1</option>
      </select>
      Radio1
      <input type="radio" {...register('radio')} value="1" />
      Radio2
      <input type="radio" {...register('radio')} value="2" />
      Radio3
      <input type="radio" {...register('radio')} value="3" />
      <input type="checkbox" {...register('checkbox')} />
      <button id="submit">Submit</button>
      <button type="button" onClick={() => reset()} id="resetForm">
        Reset
      </button>
      <div id="state">
        {JSON.stringify({
          isSubmitted,
          submitCount,
          isDirty,
          isSubmitting,
          isSubmitSuccessful,
          isValid,
          touched: Object.keys(touchedFields),
          dirty: Object.keys(dirtyFields),
        })}
      </div>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default FormStateWithSchema;


================================================
File: /app/src/crossFrameForm.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { useForm } from 'react-hook-form';
import App from './app';

const FRAME_CONTENT = `
  <style>
    label {display: block; margin-bottom: .5em}
    form {margin-bottom: 2em}
    input {margin: 0 1em}
  </style>

  <div id='inner-root'>
    Loading content...
  </div>
`;

const FRAME_STYLE = {
  width: '640px',
  height: '480px',
  background: 'white',
};

const CrossFrameForm: React.FC = () => {
  const ref = React.useRef<HTMLIFrameElement>(null);

  function renderFormInFrame() {
    const rootElement =
      ref.current!.contentDocument!.getElementById('inner-root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(<FrameForm />);
  }

  return (
    <iframe
      ref={ref}
      style={FRAME_STYLE}
      srcDoc={FRAME_CONTENT}
      onLoad={renderFormInFrame}
    />
  );
};

const FrameForm: React.FC = () => {
  const { register, watch } = useForm();

  const value = watch();

  return (
    <>
      <form>
        <label>
          Free text
          <input type="text" {...register('input', { required: true })} />
        </label>

        <label>
          <input
            type="radio"
            value="a"
            {...register('radio', { required: true })}
          />
          Choice A
        </label>

        <label>
          <input
            type="radio"
            value="b"
            {...register('radio', { required: true })}
          />
          Choice B
        </label>
      </form>

      <label>
        Form value
        <pre>{JSON.stringify(value)}</pre>
      </label>
    </>
  );
};

export default CrossFrameForm;


================================================
File: /app/src/useFormState.tsx
================================================
import React from 'react';
import { useFormState, useForm, Control } from 'react-hook-form';

let renderCounter = 0;

type FormInputs = {
  firstName: string;
  lastName: string;
  min: string;
  max: string;
  minDate: string;
  maxDate: string;
  minLength: string;
  minRequiredLength: string;
  selectNumber: string;
  pattern: string;
  nestItem: {
    nest1: string;
  };
  arrayItem: {
    test1: string;
  }[];
};

const SubForm = ({ control }: { control: Control<FormInputs> }) => {
  const {
    isDirty,
    dirtyFields,
    touchedFields,
    isSubmitted,
    isSubmitSuccessful,
    submitCount,
    isValid,
  } = useFormState({
    control,
  });

  return (
    <p id="state">
      {JSON.stringify({
        isDirty,
        touched: Object.keys(touchedFields),
        dirty: Object.keys(dirtyFields),
        isSubmitted,
        isSubmitSuccessful,
        submitCount,
        isValid,
      })}
    </p>
  );
};

export const UseFormState: React.FC = () => {
  const { register, handleSubmit, control, reset } = useForm<FormInputs>({
    mode: 'onChange',
  });
  const onValid = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onValid)}>
      <input
        placeholder="nest.nest1"
        {...register('nestItem.nest1', { required: true })}
      />
      <input
        placeholder="arrayItem.0.test1"
        {...register('arrayItem.0.test1', { required: true })}
      />
      <input
        {...register('firstName', { required: true })}
        placeholder="firstName"
      />
      <input
        {...register('lastName', { required: true, maxLength: 5 })}
        placeholder="lastName"
      />
      <input
        type="number"
        {...register('min', { min: 10 })}
        placeholder="min"
      />
      <input
        type="number"
        {...register('max', { max: 20 })}
        placeholder="max"
      />
      <input
        type="date"
        {...register('minDate', { min: '2019-08-01' })}
        placeholder="minDate"
      />
      <input
        type="date"
        {...register('maxDate', { max: '2019-08-01' })}
        placeholder="maxDate"
      />
      <input
        {...register('minLength', { minLength: 2 })}
        placeholder="minLength"
      />
      <input
        {...register('minRequiredLength', { minLength: 2, required: true })}
        placeholder="minRequiredLength"
      />
      <select {...register('selectNumber', { required: true })}>
        <option value="">Select</option>
        <option value={1}>1</option>
        <option value={2}>1</option>
      </select>
      <input
        {...register('pattern', { pattern: /\d+/ })}
        placeholder="pattern"
      />
      <button id="submit">Submit</button>
      <button type="button" id="resetForm" onClick={() => reset()}>
        Reset
      </button>
      <div id="renderCount">{renderCounter}</div>
      <SubForm control={control} />
    </form>
  );
};


================================================
File: /app/src/main.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './app';

const rootElement = document.getElementById('root')!;
const root = ReactDOM.createRoot(rootElement);
root.render(<App />);


================================================
File: /app/src/setFocus.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';
import type { DefaultValues } from 'react-hook-form';

type FormValues = {
  focusInput: string;
  selectInputContent: string;
  focusTextarea: string;
  selectTextareaContent: string;
};

const defaultValues: DefaultValues<FormValues> = {
  focusInput: 'Input should be focused',
  selectInputContent: 'Content should be selected',
  focusTextarea: 'Textarea should be focused',
  selectTextareaContent: 'Content should be selected',
};

const SetFocus = () => {
  const { register, setFocus } = useForm<FormValues>({
    defaultValues,
  });

  return (
    <form>
      <fieldset>
        <legend>Focus input</legend>
        <label htmlFor="focusInput">Focus Input</label>
        <input id="focusInput" {...register('focusInput')} />
        <button type="button" onClick={() => setFocus('focusInput')}>
          Focus Input
        </button>
      </fieldset>
      <fieldset>
        <legend>Select input content on focus</legend>
        <label htmlFor="selectInputContent">Select Content</label>
        <input id="selectInputContent" {...register('selectInputContent')} />
        <button
          type="button"
          onClick={() => setFocus('selectInputContent', { shouldSelect: true })}
        >
          Select Input Content
        </button>
      </fieldset>
      <fieldset>
        <legend>Focus textarea</legend>
        <label htmlFor="focusTextarea">Focus Textarea</label>
        <textarea id="focusTextarea" {...register('focusTextarea')} />
        <button type="button" onClick={() => setFocus('focusTextarea')}>
          Focus Textarea
        </button>
      </fieldset>
      <fieldset>
        <legend>Select textarea content on focus</legend>
        <label htmlFor="selectTextareaContent">Focus Textarea</label>
        <textarea
          id="selectTextareaContent"
          {...register('selectTextareaContent')}
        />
        <button
          type="button"
          onClick={() =>
            setFocus('selectTextareaContent', { shouldSelect: true })
          }
        >
          Select Textarea Content
        </button>
      </fieldset>
    </form>
  );
};

export default SetFocus;


================================================
File: /app/src/useFieldArrayNested.tsx
================================================
import React from 'react';
import {
  Controller,
  useFieldArray,
  useFormState,
  useForm,
  Control,
} from 'react-hook-form';

type FormValues = {
  test: {
    firstName: string;
    lastName: string;
    keyValue: { name: string }[];
  }[];
};

function NestedArray({
  control,
  index,
}: {
  control: Control<FormValues>;
  index: number;
}) {
  const { fields, append, prepend, swap, move, remove, insert, update } =
    useFieldArray<FormValues, 'test.0.keyValue'>({
      name: `test.${index}.keyValue` as 'test.0.keyValue',
      control,
    });
  const { touchedFields, dirtyFields } = useFormState({
    control,
  });
  const renderCountRef = React.useRef(0);
  renderCountRef.current++;

  return (
    <div>
      <ul>
        {fields.map((item, i) => (
          <Controller
            key={item.id}
            render={({ field }) => <input {...field} aria-label={'name'} />}
            name={`test.${index}.keyValue.${i}.name`}
            control={control}
          />
        ))}
      </ul>

      <div id={`dirty-nested-${index}`}>{JSON.stringify(dirtyFields)}</div>
      <div id={`touched-nested-${index}`}>{JSON.stringify(touchedFields)}</div>

      <button
        id={`nest-append-${index}`}
        type="button"
        onClick={() => append({ name: 'append' })}
      >
        append
      </button>

      <button
        id={`nest-prepend-${index}`}
        type="button"
        onClick={() => prepend({ name: 'prepend' })}
      >
        prepend
      </button>

      <button
        id={`nest-swap-${index}`}
        onClick={() => swap(1, 2)}
        type="button"
      >
        swap
      </button>

      <button
        id={`nest-move-${index}`}
        onClick={() => move(2, 0)}
        type="button"
      >
        move
      </button>

      <button
        id={`nest-insert-${index}`}
        type="button"
        onClick={() => insert(1, { name: 'insert' })}
      >
        insert
      </button>

      <button
        id={`nest-update-${index}`}
        type="button"
        onClick={() => update(0, { name: 'update' })}
      >
        update
      </button>

      <button
        id={`nest-remove-${index}`}
        type="button"
        onClick={() => remove(1)}
      >
        remove
      </button>

      <button
        id={`nest-remove-all-${index}`}
        type="button"
        onClick={() => remove()}
      >
        remove all
      </button>

      <div id={`count-nest-${index}`}>{renderCountRef.current}</div>
    </div>
  );
}

export default () => {
  const { register, control, reset, setValue, handleSubmit } =
    useForm<FormValues>({
      defaultValues: {
        test: [
          {
            firstName: 'Bill',
            lastName: 'Luo',
            keyValue: [{ name: '1a' }, { name: '1c' }],
          },
        ],
      },
    });
  const { fields, append, prepend, swap, move, insert, remove, update } =
    useFieldArray({
      control,
      name: 'test',
    });
  const renderCountRef = React.useRef(0);
  const [result, setResult] = React.useState({});
  renderCountRef.current++;

  return (
    <form onSubmit={handleSubmit((e) => setResult(e))}>
      {fields.map((item, index) => {
        return (
          <div key={item.id}>
            <input
              aria-label={`test.${index}.firstName`}
              {...register(`test.${index}.firstName` as const)}
            />
            <NestedArray control={control} index={index} />
          </div>
        );
      })}

      <hr />

      <button
        id="append"
        type="button"
        onClick={() => append({ firstName: 'append' })}
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() => prepend({ firstName: 'prepend' })}
      >
        prepend
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(2, 0)} type="button">
        move
      </button>

      <button
        id="insert"
        type="button"
        onClick={() => insert(1, { firstName: 'insert' })}
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <button
        id="update"
        onClick={() =>
          update(0, {
            firstName: 'updateFirstName',
            keyValue: [
              { name: 'updateFirstName1' },
              { name: 'updateFirstName2' },
            ],
          })
        }
        type="button"
      >
        update
      </button>

      <button
        id="setValue"
        type={'button'}
        onClick={() =>
          setValue('test', [
            {
              firstName: 'test',
              lastName: 'test',
              keyValue: [
                {
                  name: 'test',
                },
              ],
            },
            {
              firstName: 'test1',
              lastName: 'test1',
              keyValue: [
                {
                  name: 'test1',
                },
              ],
            },
            {
              firstName: 'test2',
              lastName: 'test3',
              keyValue: [
                {
                  name: 'test3',
                },
              ],
            },
          ])
        }
      >
        setValue
      </button>

      <button
        id="reset"
        type="button"
        onClick={() => {
          reset({
            test: [
              { firstName: 'test' },
              { firstName: 'test1' },
              { firstName: 'test2' },
            ],
          });
        }}
      >
        reset
      </button>

      <div id="count">{renderCountRef.current}</div>

      <p id="result">{JSON.stringify(result)}</p>

      <button id={'submit'}>Submit</button>
    </form>
  );
};


================================================
File: /app/src/basicSchemaValidation.tsx
================================================
import React from 'react';
import { useForm, ValidationMode } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const validationSchema = yup
  .object()
  .shape(
    {
      firstName: yup.string().required(),
      lastName: yup.string().max(5).required(),
      min: yup.number().min(10),
      max: yup.number().max(20),
      minDate: yup.date().min('2019-08-01'),
      maxDate: yup.date().max('2019-08-01'),
      minLength: yup.string().min(2),
      minRequiredLength: yup.string().min(2).required(),
      selectNumber: yup.string().required(),
      pattern: yup.string().matches(/\d+/),
      radio: yup.string().required(),
      checkbox: yup.string().required(),
      exclusivelyRequiredOne: yup.string().when('exclusivelyRequiredTwo', {
        is: '',
        then: () => yup.string().required(),
        otherwise: () => yup.string().length(0),
      }),
      exclusivelyRequiredTwo: yup.string().when('exclusivelyRequiredOne', {
        is: '',
        then: () => yup.string().required(),
        otherwise: () => yup.string().length(0),
      }),
    },
    [['exclusivelyRequiredOne', 'exclusivelyRequiredTwo']],
  )
  .required();

const BasicSchemaValidation: React.FC = () => {
  const { mode } = useParams();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    minDate: string;
    maxDate: string;
    minLength: string;
    minRequiredLength: string;
    selectNumber: string;
    pattern: string;
    radio: string;
    checkbox: string;
    multiple: string;
    validate: string;
  }>({
    resolver: yupResolver(validationSchema),
    mode: mode as keyof ValidationMode,
  });
  const onSubmit = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} placeholder="firstName" />
      {errors.firstName && <p>firstName error</p>}
      <input {...register('lastName')} placeholder="lastName" />
      {errors.lastName && <p>lastName error</p>}
      <input type="number" {...register('min')} placeholder="min" />
      {errors.min && <p>min error</p>}
      <input type="number" {...register('max')} placeholder="max" />
      {errors.max && <p>max error</p>}
      <input type="date" {...register('minDate')} placeholder="minDate" />
      {errors.minDate && <p>minDate error</p>}
      <input type="date" {...register('maxDate')} placeholder="maxDate" />
      {errors.maxDate && <p>maxDate error</p>}
      <input {...register('minLength')} placeholder="minLength" />
      {errors.minLength && <p>minLength error</p>}
      <input
        {...register('minRequiredLength')}
        placeholder="minRequiredLength"
      />
      {errors.minRequiredLength && <p>minRequiredLength error</p>}
      <select {...register('selectNumber')}>
        <option value="">Select</option>
        <option value={1}>1</option>
        <option value={2}>1</option>
      </select>
      {errors.selectNumber && <p>selectNumber error</p>}
      <input {...register('pattern')} placeholder="pattern" />
      {errors.pattern && <p>pattern error</p>}
      Radio1
      <input type="radio" {...register('radio')} value="1" />
      Radio2
      <input type="radio" {...register('radio')} value="2" />
      Radio3
      <input type="radio" {...register('radio')} value="3" />
      {errors.radio && <p>radio error</p>}
      <input type="checkbox" {...register('checkbox')} />
      {errors.checkbox && <p>checkbox error</p>}
      <button>Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default BasicSchemaValidation;


================================================
File: /app/src/useWatch.tsx
================================================
import React from 'react';
import { useForm, Control, useWatch, Controller } from 'react-hook-form';
import { useRef } from 'react';

type FormInputs = {
  test: string;
  test1: string;
  test2: string;
};

let counter = 0;

const GrandChild = ({
  control,
  index = 0,
}: {
  control: Control<FormInputs>;
  index?: number;
}) => {
  const counter1 = useRef(0);
  const output = useWatch({
    name: 'test',
    control,
  });

  counter1.current++;

  return (
    <div style={{ border: '2px solid blue', padding: 10, margin: 5 }}>
      <h2 style={{ margin: 0 }}>Grandchild 0:</h2>
      <p id={`grandchild0${index}`}>{output}</p>
      <p id="grandChildCounter">Render counter: {counter1.current}</p>
    </div>
  );
};

const GrandChild1 = ({ control }: { control: Control<FormInputs> }) => {
  const counter = useRef(0);
  const output = useWatch<FormInputs>({
    name: ['test', 'test1'],
    control,
  });

  counter.current++;

  return (
    <div style={{ border: '2px solid blue', padding: 10, margin: 5 }}>
      <h2 style={{ margin: 0 }}>Grandchild 1:</h2>
      <p id="grandchild1">
        {output[0]}
        {output[1]}
      </p>
      <p id="grandChild1Counter">Render counter: {counter.current}</p>
    </div>
  );
};

const GrandChild2 = ({
  control,
}: {
  control: Control<{
    test: string;
    test1: string;
    test2: string;
  }>;
}) => {
  const counter = useRef(0);
  const output = useWatch<{
    test: string;
    test1: string;
    test2: string;
  }>({
    control,
  });

  counter.current++;

  return (
    <div style={{ border: '2px solid blue', padding: 10, margin: 5 }}>
      <h2 style={{ margin: 0 }}>Grandchild 2:</h2>
      <p id="grandchild2">
        {output.test}
        {output.test1}
        {output.test2}
      </p>
      <p id="grandChild2Counter">Render counter: {counter.current}</p>
    </div>
  );
};

const Child = ({ control }: { control: Control<FormInputs> }) => {
  const counter1 = useRef(0);
  counter1.current++;

  return (
    <div style={{ border: '2px solid green', padding: 10, margin: 5 }}>
      <h2 style={{ margin: 0 }}>Child:</h2>
      <GrandChild index={1} control={control} />
      <p id="childCounter" style={{ color: 'red' }}>
        <b>Render counter: {counter1.current} 👀</b>
      </p>
    </div>
  );
};

export default () => {
  const { register, control } = useForm<FormInputs>();

  counter++;

  return (
    <div style={{ border: '2px solid red', padding: 10, margin: 5 }}>
      <h2 style={{ margin: 0 }}>Parent:</h2>
      <input
        {...register('test')}
        autoComplete="off"
        placeholder="👀 watching me :)"
        style={{ fontSize: 20 }}
      />

      <Controller
        name="test1"
        control={control}
        render={({ field }) => (
          <input
            placeholder="👀 watching me :)"
            autoComplete="off"
            style={{ fontSize: 20 }}
            {...field}
          />
        )}
        defaultValue=""
      />

      <input
        {...register('test2')}
        name="test2"
        autoComplete="off"
        placeholder="👀 watching me :)"
        style={{ fontSize: 20 }}
      />

      <GrandChild control={control} />
      <Child control={control} />
      <GrandChild1 control={control} />
      <GrandChild2 control={control} />

      <p id="parentCounter" style={{ color: 'red' }}>
        <b>Render counter: {counter} 👀</b>
      </p>
    </div>
  );
};


================================================
File: /app/src/validateFieldCriteria.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

const ValidateFieldCriteria: React.FC = () => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
    clearErrors,
  } = useForm<{
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    minDate: string;
    maxDate: string;
    minLength: string;
    minRequiredLength: string;
    selectNumber: string;
    pattern: string;
    radio: string;
    checkbox: string;
    multiple: string;
    validate: string;
  }>({
    criteriaMode: 'all',
  });
  const onSubmit = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('firstName', { required: true, minLength: 4 })}
        placeholder="firstName"
      />
      {errors.firstName &&
        errors.firstName.types &&
        errors.firstName.types.required && <p>firstName required</p>}
      {errors.firstName &&
        errors.firstName.types &&
        errors.firstName.types.minLength && <p>firstName minLength</p>}

      {errors.firstName && errors.firstName.types && (
        <b>{errors.firstName.types.required || ''}</b>
      )}

      {errors.firstName && errors.firstName.types && (
        <b>{errors.firstName.types.minLength || ''}</b>
      )}

      <input
        type="number"
        {...register('min', { required: true, min: 10, max: 30 })}
        placeholder="min"
      />
      {errors.min && errors.min.types && errors.min.types.required && (
        <p>min required</p>
      )}
      {errors.min && errors.min.types && errors.min.types.min && <p>min min</p>}
      {errors.min && errors.min.types && errors.min.types.max && <p>min max</p>}
      <input
        type="date"
        {...register('minDate', { required: true, min: '2019-08-01' })}
        placeholder="minDate"
      />
      {errors.minDate &&
        errors.minDate.types &&
        errors.minDate.types.required && <p>minDate required</p>}
      {errors.minDate && errors.minDate.types && errors.minDate.types.min && (
        <p>minDate min</p>
      )}
      <input
        type="date"
        {...register('maxDate', { required: true, max: '2019-08-01' })}
        placeholder="maxDate"
      />
      {errors.maxDate &&
        errors.maxDate.types &&
        errors.maxDate.types.required && <p>maxDate required</p>}
      {errors.maxDate && errors.maxDate.types && errors.maxDate.types.max && (
        <p>maxDate max</p>
      )}
      <input
        {...register('minLength', { required: true, minLength: 2 })}
        placeholder="minLength"
      />
      {errors.minLength &&
        errors.minLength.types &&
        errors.minLength.types.required && <p>minLength required</p>}
      {errors.minLength &&
        errors.minLength.types &&
        errors.minLength.types.minLength && <p>minLength minLength</p>}
      <select {...register('selectNumber', { required: true, minLength: 2 })}>
        <option value="">Select</option>
        <option value="1">1</option>
        <option value="12">2</option>
      </select>
      {errors.selectNumber &&
        errors.selectNumber.types &&
        errors.selectNumber.types.required && <p>selectNumber required</p>}
      {errors.selectNumber &&
        errors.selectNumber.types &&
        errors.selectNumber.types.minLength && <p>selectNumber minLength</p>}
      <input
        {...register('pattern', {
          pattern: /\d+/,
          required: true,
          minLength: 3,
        })}
        placeholder="pattern"
      />
      {errors.pattern &&
        errors.pattern.types &&
        errors.pattern.types.pattern && <p>pattern pattern</p>}
      {errors.pattern &&
        errors.pattern.types &&
        errors.pattern.types.required && <p>pattern required</p>}
      {errors.pattern &&
        errors.pattern.types &&
        errors.pattern.types.minLength && <p>pattern minLength</p>}
      <select
        multiple
        {...register('multiple', {
          required: true,
          validate: (value) => value.includes('optionB'),
        })}
      >
        <option value="optionA">optionA</option>
        <option value="optionB">optionB</option>
      </select>
      {errors.multiple &&
        errors.multiple.types &&
        errors.multiple.types.required && <p>multiple required</p>}
      {errors.multiple &&
        errors.multiple.types &&
        errors.multiple.types.validate && <p>multiple validate</p>}
      <input
        type="validate"
        placeholder="validate"
        {...register('validate', {
          validate: {
            test: (value) => value !== '',
            test1: (value) => value.length > 3,
            test2: (value) => value === 'test',
          },
        })}
      />
      {errors.validate &&
        errors.validate.types &&
        errors.validate.types.test && <p>validate test</p>}
      {errors.validate &&
        errors.validate.types &&
        errors.validate.types.test1 && <p>validate test1</p>}
      {errors.validate &&
        errors.validate.types &&
        errors.validate.types.test2 && <p>validate test2</p>}
      <button id="submit">Submit</button>

      <button
        type="button"
        id="trigger"
        onClick={() => {
          setError('firstName', {
            types: {
              minLength: 'test1',
              required: 'test2',
            },
          });
        }}
      >
        Trigger Error
      </button>

      <button
        type="button"
        id="clear"
        onClick={() => {
          clearErrors('firstName');
        }}
      >
        Clear Error
      </button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default ValidateFieldCriteria;


================================================
File: /app/src/form.tsx
================================================
import { useForm, Form } from 'react-hook-form';
import React from 'react';

export default function FormComponent() {
  const methods = useForm<{
    test: string;
  }>({
    defaultValues: {
      test: '',
    },
  });

  return (
    <Form control={methods.control} action={'/test'}>
      <input {...methods.register('test')} />
      <button>Submit</button>
    </Form>
  );
}


================================================
File: /app/src/test.tsx
================================================
import React from 'react';
import { useFieldArray, useForm } from 'react-hook-form';
import { Control } from '../../src/types';

type FormData = {
  nest: {
    test: {
      value: string;
      nestedArray: {
        value: string;
      }[];
    }[];
  };
};
const ChildComponent = ({
  index,
  control,
}: {
  control: Control<FormData>;
  index: number;
}) => {
  const { fields } = useFieldArray<FormData>({
    name: `nest.test.${index}.nestedArray` as const,
    control,
  });

  return (
    <div>
      {fields.map((item, i) => (
        <input
          key={item.id}
          {...control.register(
            `nest.test.${index}.nestedArray.${i}.value` as const,
          )}
        />
      ))}
    </div>
  );
};

const Component = () => {
  const { register, control } = useForm({
    defaultValues: {
      nest: {
        test: [
          { value: '1', nestedArray: [{ value: '2' }] },
          { value: '3', nestedArray: [{ value: '4' }] },
        ],
      },
    },
  });
  const { fields, remove, append } = useFieldArray({
    name: 'nest.test',
    control,
  });

  return (
    <div>
      {fields.map((item, i) => (
        <div key={item.id}>
          <input {...register(`nest.test.${i}.value` as const)} />

          <ChildComponent control={control} index={i} />

          <button
            type={'button'}
            onClick={() => remove(i)}
            data-testid={item.value}
          >
            remove
          </button>
        </div>
      ))}

      <button type={'button'} onClick={() => append({ value: 'test' })}>
        append
      </button>
    </div>
  );
};

export default Component;


================================================
File: /app/src/welcome/styles.ts
================================================
export const page: object = {
  minHeight: '100vh',
  color: 'white',
  padding: '1rem',
  fontFamily:
    'Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif',
};

export const h1: object = {
  fontSize: '4rem',
  fontWeight: '600',
  textAlign: 'center',
  marginBottom: '1rem',
};

export const h2: object = {
  color: '#ec5990',
  marginBottom: '2rem',
  fontSize: '1.5rem',
  textAlign: 'center',
};

export const items: object = {
  display: 'grid',
  gap: '1rem',
  gridTemplateColumns: '1fr 1fr 1fr',
};

export const item: object = {
  border: '1px solid #516391',
  padding: '1rem',
  background: '#0f111d',
};

export const title: object = {
  fontSize: '1.5rem',
  fontWeight: '600',
  marginBottom: '.5rem',
  display: 'inline-block',
  borderBottom: '1px solid #ec5990',
};

export const description: object = {
  fontSize: '1rem',
  fontWeight: '300',
  marginBottom: '.5rem',
};

export const slug: object = {
  fontSize: '.875rem',
  color: '#ec5990',
  display: 'block',
  marginBottom: '.25rem',
  textDecoration: 'none',
};


================================================
File: /app/src/welcome/index.tsx
================================================
import React from 'react';
import { Link } from 'react-router-dom';
import * as S from './styles';

type Item = {
  title: string;
  description: string;
  slugs: string[];
};

const items: Item[] = [
  {
    title: 'AutoUnregister',
    description: 'Should keep all inputs data when inputs get unmounted',
    slugs: ['/autoUnregister'],
  },
  {
    title: 'Basic',
    description: 'Should validate the form in different modes',
    slugs: ['/basic/onSubmit', '/basic/onBlur', '/basic/onChange'],
  },
  {
    title: 'BasicSchemaValidation',
    description: 'BasicSchemaValidation form validation',
    slugs: [
      '/basic-schema-validation/onSubmit',
      '/basic-schema-validation/onBlur',
      '/basic-schema-validation/onChange',
    ],
  },
  {
    title: 'ConditionalField',
    description: 'Should reflect correct form state and data collection',
    slugs: ['/conditionalField'],
  },
  {
    title: 'Controller',
    description: 'Should validate the form in different modes',
    slugs: [
      '/controller/onSubmit',
      '/controller/onBlur',
      '/controller/onChange',
    ],
  },
  {
    title: 'CustomSchemaValidation',
    description: 'Should validate the form in different modes',
    slugs: [
      '/customSchemaValidation/onSubmit',
      '/customSchemaValidation/onBlur',
      '/customSchemaValidation/onChange',
    ],
  },
  {
    title: 'DefaultValues',
    description: 'Should populate defaultValue for inputs',
    slugs: ['/default-values', '/default-values-async'],
  },
  {
    title: 'FormState',
    description: 'Should return correct form state in different modes',
    slugs: ['/formState/onSubmit', '/formState/onBlur', '/formState/onChange'],
  },
  {
    title: 'FormStateWithNestedFields',
    description:
      'Should return correct form state with nested fields in different modes',
    slugs: [
      '/formStateWithNestedFields/onSubmit',
      '/formStateWithNestedFields/onBlur',
      '/formStateWithNestedFields/onChange',
    ],
  },
  {
    title: 'FormStateWithSchema',
    description:
      'Should return correct form state with schema validation in different modes',
    slugs: [
      '/formStateWithSchema/onSubmit',
      '/formStateWithSchema/onBlur',
      '/formStateWithSchema/onChange',
    ],
  },
  {
    title: 'IsValid',
    description: 'Should showing valid correctly',
    slugs: [
      '/isValid/build-in/defaultValue',
      '/isValid/build-in/defaultValues',
      '/isValid/schema/defaultValue',
      '/isValid/schema/defaultValues',
    ],
  },
  {
    title: 'ManualRegisterForm',
    description: 'Should validate the form',
    slugs: ['/manual-register-form'],
  },
  {
    title: 'Reset',
    description: 'Should be able to re-populate the form while reset',
    slugs: ['/reset', '/resetKeepDirty'],
  },
  {
    title: 'ReValidateMode',
    description: 'Should re-validate the form in different modes',
    slugs: [
      '/re-validate-mode/onSubmit/onSubmit',
      '/re-validate-mode/onSubmit/onBlur',
      '/re-validate-mode/onBlur/onSubmit',
      '/re-validate-mode/onChange/onSubmit',
      '/re-validate-mode/onBlur/onBlur',
      '/re-validate-mode/onBlur/onChange',
    ],
  },
  {
    title: 'SetError',
    description: 'Form setError',
    slugs: ['/setError'],
  },
  {
    title: 'DelayError',
    description: 'Form showing delay error',
    slugs: ['/delayError'],
  },
  {
    title: 'setFocus',
    description: 'Form setFocus',
    slugs: ['/setFocus'],
  },
  {
    title: 'SetValue',
    description: 'Should set input value',
    slugs: ['/setValue', '/setValueAsyncStrictMode'],
  },
  {
    title: 'SetValueCustomRegister',
    description:
      'Should only trigger re-render when form state changed or error triggered',
    slugs: ['/setValueCustomRegister'],
  },
  {
    title: 'SetValueWithSchema',
    description:
      'Should set input value, trigger validation and clear all errors',
    slugs: ['/setValueWithSchema'],
  },
  {
    title: 'SetValueWithTrigger',
    description: 'Should set input value and trigger validation',
    slugs: ['/setValueWithTrigger'],
  },
  {
    title: 'TriggerValidation',
    description: 'Should trigger input validation',
    slugs: ['/trigger-validation'],
  },
  {
    title: 'UseFieldArray',
    description: 'Should behaviour correctly in different situations',
    slugs: [
      '/useFieldArray/normal',
      '/useFieldArray/default',
      '/useFieldArray/defaultAndWithoutFocus',
      '/useFieldArray/asyncReset',
      '/useFieldArray/defaultAndWithoutFocus',
      '/useFieldArray/formState',
    ],
  },
  {
    title: 'UseFieldArrayNested',
    description: 'Should work correctly with nested field array',
    slugs: ['/useFieldArrayNested'],
  },
  {
    title: 'UseFieldArrayUnregister',
    description: 'Should work correctly',
    slugs: ['/useFieldArrayUnregister'],
  },
  {
    title: 'UseFormState',
    description:
      'Should subscribed to the form state without re-render the root',
    slugs: ['/useFormState'],
  },
  {
    title: 'UseWatch',
    description: 'Should watch correctly',
    slugs: ['/useWatch'],
  },
  {
    title: 'UseWatchUseFieldArrayNested',
    description: 'Should watch the correct nested field array',
    slugs: ['/useWatchUseFieldArrayNested'],
  },
  {
    title: 'ValidateFieldCriteria',
    description: 'Should validate the form, show all errors and clear all',
    slugs: ['/validate-field-criteria'],
  },
  {
    title: 'Watch',
    description: 'Should watch all inputs',
    slugs: ['/watch'],
  },
  {
    title: 'WatchDefaultValues',
    description: 'Should return default value with watch',
    slugs: ['/watch-default-values'],
  },
  {
    title: 'WatchUseFieldArray',
    description: 'Should behave correctly when watching the field array',
    slugs: ['/watch-field-array/normal', '/watch-field-array/default'],
  },
  {
    title: 'WatchUseFieldArrayNested',
    description: 'Should watch the correct nested field array',
    slugs: ['/watchUseFieldArrayNested'],
  },
  {
    title: 'Form',
    description: 'Should validate form and submit the request',
    slugs: ['/form'],
  },
  {
    title: 'Disabled',
    description: 'Should behave correctly when disabling form or fields',
    slugs: ['/disabled'],
  },
];

const Component: React.FC = () => {
  return (
    <div style={S.page}>
      <h1 style={S.h1}>App for cypress automation</h1>
      <h2 style={S.h2}>
        Here you have the full list of the available testing routes:
      </h2>
      <div style={S.items}>
        {items.map(({ title, description, slugs }: Item) => (
          <div style={S.item} key={title}>
            <div style={S.title}>{title}</div>
            <div style={S.description}>{description}</div>
            <div>
              {slugs.map((slug, index) => (
                <Link key={index + slug} to={slug} style={S.slug}>
                  {slug}
                </Link>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Component;


================================================
File: /app/src/autoUnregister.tsx
================================================
import React, { useState } from 'react';
import ReactSelect from 'react-select';
import { useForm, Controller, NestedValue } from 'react-hook-form';

const options = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
];

export default function AutoUnregister() {
  const { register, control, handleSubmit } = useForm<{
    test: string;
    test1: string;
    test2: boolean;
    test3: string;
    test4: string;
    ReactSelect: NestedValue<{ label: string; value: string }>;
  }>();
  const [show, setShow] = useState(true);

  return (
    <form onSubmit={handleSubmit((d) => console.log(d))}>
      {show && (
        <>
          <Controller
            defaultValue=""
            control={control}
            render={({ field }) => <input {...field} />}
            name="test"
          />
          <section id="input-ReactSelect">
            <Controller
              render={({ field }) => (
                <ReactSelect isClearable options={options} {...field} />
              )}
              name="ReactSelect"
              control={control}
              rules={{ required: true }}
            />
          </section>

          <input {...register('test1')} />
          <input type="checkbox" {...register('test2')} />
          <input type="radio" {...register('test3')} />
          <select {...register('test4')}>
            <option>Select...</option>
            <option value="bill">Bill</option>
          </select>
        </>
      )}

      <button type="button" onClick={() => setShow(!show)}>
        Toggle Modal
      </button>

      <input type="submit" />
    </form>
  );
}


================================================
File: /app/src/controller.tsx
================================================
import React from 'react';
import { useForm, Controller, ValidationMode } from 'react-hook-form';
import ReactSelect from 'react-select';
import {
  TextField,
  Checkbox,
  Select,
  MenuItem,
  Switch,
  RadioGroup,
  FormControlLabel,
  Radio,
} from '@mui/material';
import { useParams } from 'react-router-dom';

let renderCount = 0;

const options = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
] as const;

const defaultValues = {
  Native: '',
  TextField: '',
  Select: '',
  ReactSelect: '',
  Checkbox: false,
  switch: false,
  RadioGroup: '',
};

type Form = {
  Native: string;
  TextField: string;
  Select: string;
  ReactSelect: string;
  Checkbox: boolean;
  switch: boolean;
  RadioGroup: string;
};

const PureReactSelect = React.memo(ReactSelect);

export default function Field() {
  const { mode } = useParams();
  const methods = useForm<Form>({
    defaultValues,
    mode: mode as keyof ValidationMode,
  });
  const {
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = methods;

  const [, setRerender] = React.useState(0);
  renderCount++;

  const rerender = () => setRerender(Math.random());

  return (
    <form onSubmit={handleSubmit(() => {})}>
      <div className="container">
        <section id="input-checkbox">
          <label>MUI Checkbox</label>
          <Controller
            name="Checkbox"
            control={control}
            rules={{ required: true }}
            render={({ field: props }) => (
              <Checkbox
                {...props}
                onChange={(e) => props.onChange(e.target.checked)}
              />
            )}
          />
        </section>

        {errors.Checkbox && <p id="Checkbox">Checkbox Error</p>}

        <section id="input-radio-group">
          <label>Radio Group</label>
          <Controller
            render={({ field }) => (
              <RadioGroup aria-label="gender" {...field} name="gender1">
                <FormControlLabel
                  value="female"
                  control={<Radio />}
                  label="Female"
                />
                <FormControlLabel
                  value="male"
                  control={<Radio />}
                  label="Male"
                />
                <FormControlLabel
                  value="other"
                  control={<Radio />}
                  label="Other"
                />
              </RadioGroup>
            )}
            rules={{ required: true }}
            name="RadioGroup"
            control={control}
          />
        </section>

        {errors.RadioGroup && <p id="RadioGroup">RadioGroup Error</p>}

        <section id="input-textField">
          <label>MUI TextField</label>
          <Controller
            render={({ field }) => <TextField {...field} />}
            name="TextField"
            control={control}
            rules={{ required: true }}
          />
        </section>

        {errors.TextField && <p id="TextField">TextField Error</p>}

        <section id="input-select">
          <label>MUI Select</label>
          <Controller
            render={({ field }) => (
              <Select {...field}>
                <MenuItem value={10}>Ten</MenuItem>
                <MenuItem value={20}>Twenty</MenuItem>
                <MenuItem value={30}>Thirty</MenuItem>
              </Select>
            )}
            rules={{ required: true }}
            name="Select"
            control={control}
          />
        </section>

        {errors.Select && <p id="Select">Select Error</p>}

        <section id="input-switch">
          <label>MUI Switch</label>
          <Controller
            name="switch"
            rules={{ required: true }}
            render={({ field: props }) => (
              <Switch
                {...props}
                onChange={(e) => props.onChange(e.target.checked)}
              />
            )}
            control={control}
          />
        </section>

        {errors.switch && <p id="switch">switch Error</p>}

        <section id="input-ReactSelect">
          <label>React Select</label>
          <Controller
            render={({ field }) => (
              <PureReactSelect isClearable options={options} {...field} />
            )}
            name="ReactSelect"
            control={control}
            rules={{ required: true }}
          />
        </section>

        {errors.ReactSelect && <p id="ReactSelect">ReactSelect Error</p>}
      </div>

      <span id="renderCount">{renderCount}</span>

      <button type="button" onClick={rerender}>
        Rerender
      </button>

      <button
        type="button"
        onClick={() => {
          reset({
            Native: '',
            TextField: '',
            Select: '',
            ReactSelect: '',
            Checkbox: false,
            switch: false,
            RadioGroup: '',
          });
        }}
      >
        Reset Form
      </button>
      <button id="submit">submit</button>
    </form>
  );
}


================================================
File: /app/src/defaultValues.tsx
================================================
import React from 'react';
import { NestedValue, useForm } from 'react-hook-form';

function DefaultValues() {
  const { register } = useForm<{
    test: string;
    test1: {
      firstName: string;
      lastName: string[];
      deep: {
        nest: string;
      };
    };
    checkbox: NestedValue<string[]>;
  }>({
    defaultValues: {
      test: 'test',
      checkbox: ['1', '2'],
      test1: {
        firstName: 'firstName',
        lastName: ['lastName0', 'lastName1'],
        deep: {
          nest: 'nest',
        },
      },
    },
  });
  const [show, setShow] = React.useState(true);

  return (
    <>
      {show ? (
        <form>
          <input {...register('test')} />
          <input {...register('test1.firstName')} />
          <input {...register('test1.deep.nest')} />
          <input {...register('test1.deep.nest')} />
          <input {...register('test1.lastName.0')} />
          <input {...register('test1.lastName.1')} />
          <input type="checkbox" value={'1'} {...register('checkbox')} />
          <input type="checkbox" value={'2'} {...register('checkbox')} />
        </form>
      ) : null}
      <button type={'button'} id={'toggle'} onClick={() => setShow(!show)}>
        toggle
      </button>
    </>
  );
}

export default DefaultValues;


================================================
File: /app/src/resetKeepDirty.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

function ResetKeepDirty() {
  const { register, reset, setValue, watch } = useForm<{
    firstName: string;
    lastName: string;
    objectData: {
      test: string;
    };
    users: { firstName: string; lastName: string }[];
    deepNest: {
      level1: {
        level2: {
          data: string;
        };
      };
    };
  }>({
    defaultValues: { users: [] },
  });
  const users = watch('users');
  return (
    <>
      <input {...register('firstName')} />
      <input name="users" value={`users#${users.length}`} />
      <input {...register('objectData.test')} />
      <input {...register('lastName')} />
      <input {...register('deepNest.level1.level2.data')} />
      <button
        onClick={() => {
          setValue(
            'users',
            [...users, { firstName: 'John', lastName: 'Doe' }],
            { shouldDirty: true },
          );
        }}
        type="button"
      >
        Add item
      </button>
      <button
        type="button"
        onClick={() =>
          reset(
            {
              firstName: 'bill',
              lastName: 'luo',
              objectData: { test: 'data' },
              deepNest: {
                level1: {
                  level2: {
                    data: 'hey',
                  },
                },
              },
              users: [],
            },
            { keepDirtyValues: true },
          )
        }
      >
        button
      </button>
    </>
  );
}

export default ResetKeepDirty;


================================================
File: /app/src/manualRegisterForm.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

const ManualRegisterForm: React.FC = () => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
  } = useForm<{
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    minDate: string;
    maxDate: string;
    minLength: string;
    minRequiredLength: string;
    selectNumber: string;
    pattern: string;
    radio: string;
    checkbox: string;
  }>();
  const onSubmit = () => {};
  renderCounter++;

  useEffect(() => {
    register('firstName', { required: true });
    register('lastName', { required: true, maxLength: 5 });
    register('min', { min: 10 });
    register('max', { max: 20 });
    register('minDate', { min: '2019-08-01' });
    register('maxDate', { max: '2019-08-01' });
    register('minLength', { minLength: 2 });
    register('minRequiredLength', { minLength: 2, required: true });
    register('selectNumber', { required: true });
    register('pattern', { pattern: /\d+/ });
    register('radio', { required: true });
    register('checkbox', { required: true });
  }, [register]);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        name="firstName"
        placeholder="firstName"
        onChange={(e) =>
          setValue('firstName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.firstName && <p>firstName error</p>}
      <input
        name="lastName"
        placeholder="lastName"
        onChange={(e) =>
          setValue('lastName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.lastName && <p>lastName error</p>}
      <input
        type="number"
        name="min"
        placeholder="min"
        onChange={(e) =>
          setValue('min', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.min && <p>min error</p>}
      <input
        type="number"
        name="max"
        placeholder="max"
        onChange={(e) =>
          setValue('max', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.max && <p>max error</p>}
      <input
        type="date"
        name="minDate"
        placeholder="minDate"
        onChange={(e) =>
          setValue('minDate', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.minDate && <p>minDate error</p>}
      <input
        type="date"
        name="maxDate"
        placeholder="maxDate"
        onChange={(e) =>
          setValue('maxDate', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.maxDate && <p>maxDate error</p>}
      <input
        name="minLength"
        placeholder="minLength"
        onChange={(e) =>
          setValue('minLength', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.minLength && <p>minLength error</p>}
      <input
        name="minRequiredLength"
        placeholder="minRequiredLength"
        onChange={(e) =>
          setValue('minRequiredLength', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.minRequiredLength && <p>minRequiredLength error</p>}
      <select
        name="selectNumber"
        onChange={(e) =>
          setValue('selectNumber', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      >
        <option value="">Select</option>
        <option value={1}>1</option>
        <option value={2}>1</option>
      </select>
      {errors.selectNumber && <p>selectNumber error</p>}
      <input
        name="pattern"
        placeholder="pattern"
        onChange={(e) =>
          setValue('pattern', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.pattern && <p>pattern error</p>}
      Radio1
      <input
        type="radio"
        name="radio"
        value="1"
        onChange={(e) =>
          setValue('radio', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      Radio2
      <input
        type="radio"
        name="radio"
        value="2"
        onChange={(e) =>
          setValue('radio', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      Radio3
      <input
        type="radio"
        name="radio"
        value="3"
        onChange={(e) =>
          setValue('radio', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.radio && <p>radio error</p>}
      <input
        type="checkbox"
        name="checkbox"
        onChange={(e) =>
          setValue('checkbox', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.checkbox && <p>checkbox error</p>}
      <button id="submit">Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default ManualRegisterForm;


================================================
File: /app/src/disabledFields.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

const toggle = (state: boolean) => !state;

export default function DisabledFields() {
  const [formDisabled, setFormDisabled] = React.useState(false);
  const [firstDisabled, setFirstDisabled] = React.useState(false);
  const [secondDisabled, setSecondDisabled] = React.useState(true);
  const { register } = useForm({ disabled: formDisabled });

  return (
    <form>
      <button type="button" onClick={() => setFormDisabled(toggle)}>
        Toggle form
      </button>
      <button type="button" onClick={() => setFirstDisabled(toggle)}>
        Toggle Field 1
      </button>
      <button type="button" onClick={() => setSecondDisabled(toggle)}>
        Toggle Field 2
      </button>

      <input
        placeholder="Field 1"
        {...register('first', { disabled: firstDisabled })}
      />
      <input
        placeholder="Field 2"
        {...register('second', { disabled: secondDisabled })}
      />
    </form>
  );
}


================================================
File: /app/src/useFieldArray.tsx
================================================
import React from 'react';
import { useForm, useFieldArray, Controller } from 'react-hook-form';
import { useParams } from 'react-router-dom';

let renderCount = 0;

type FormValues = { data: { name: string }[] };

const UseFieldArray: React.FC = () => {
  const { mode } = useParams();
  const withoutFocus: boolean = mode === 'defaultAndWithoutFocus';
  const {
    control,
    handleSubmit,
    register,
    formState: { isDirty, touchedFields, isValid, dirtyFields, errors },
    reset,
  } = useForm<FormValues>({
    ...(mode === 'default' || withoutFocus
      ? {
          defaultValues: {
            data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
          },
        }
      : {}),
    mode: mode === 'formState' ? 'onChange' : 'onSubmit',
  });
  const {
    fields,
    append,
    prepend,
    swap,
    move,
    insert,
    remove,
    update,
    replace,
  } = useFieldArray({
    control,
    name: 'data',
  });
  const [data, setData] = React.useState<FormValues>();
  const onSubmit = (data: FormValues) => {
    setData(data);
  };

  React.useEffect(() => {
    setTimeout(() => {
      if (mode === 'asyncReset') {
        reset({
          data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
        });
      }
    }, 10);
  }, [reset, mode]);

  renderCount++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <ul>
        {fields.map((data, index) => (
          <li key={data.id}>
            {index % 2 ? (
              <input
                id={`field${index}`}
                data-order={index}
                {...register(`data.${index}.name` as const, {
                  required: 'This is required',
                })}
              />
            ) : (
              <Controller
                render={({ field }) => (
                  <input id={`field${index}`} {...field} />
                )}
                control={control}
                rules={{
                  required: 'This is required',
                }}
                name={`data.${index}.name`}
                data-order={index}
              />
            )}
            {errors.data?.[index]?.name && (
              <p id={`error${index}`}>{errors.data[index]!.name!.message}</p>
            )}
            <button id={`delete${index}`} onClick={() => remove(index)}>
              Delete
            </button>
          </li>
        ))}
      </ul>

      <button
        id="append"
        type="button"
        onClick={() =>
          append(
            { name: renderCount.toString() },
            {
              shouldFocus: !withoutFocus,
            },
          )
        }
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() =>
          prepend(
            { name: renderCount.toString() },
            {
              shouldFocus: !withoutFocus,
            },
          )
        }
      >
        prepend
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(2, 0)} type="button">
        move
      </button>

      <button
        id="update"
        onClick={() =>
          update(0, {
            name: 'changed',
          })
        }
        type="button"
      >
        update
      </button>

      <button
        id="updateRevert"
        onClick={() =>
          update(0, {
            name: 'test',
          })
        }
        type="button"
      >
        update revert
      </button>

      <button
        id="insert"
        type="button"
        onClick={() =>
          insert(
            1,
            { name: renderCount.toString() },
            {
              shouldFocus: !withoutFocus,
            },
          )
        }
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button
        id="removeAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            remove(1);
          }, 90)
        }
      >
        remove async
      </button>

      <button
        id="appendAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            append({
              name: 'appendAsync',
            });
          }, 90)
        }
      >
        append async
      </button>

      <button
        id="prependAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            prepend({
              name: 'prependAsync',
            });
          }, 90)
        }
      >
        prepend async
      </button>

      <button
        id="insertAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            insert(1, {
              name: 'insertAsync',
            });
          }, 90)
        }
      >
        insert async
      </button>

      <button
        id="swapAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            swap(0, 1);
          }, 90)
        }
      >
        swap async
      </button>

      <button id="moveAsync" onClick={() => move(1, 0)} type="button">
        move async
      </button>

      <button
        id="updateAsync"
        onClick={() =>
          setTimeout(() => {
            update(0, {
              name: 'updateAsync',
            });
          }, 90)
        }
        type="button"
      >
        update async
      </button>

      <button
        id="replaceAsync"
        type="button"
        onClick={() =>
          setTimeout(() => {
            replace([
              { name: `${renderCount}. lorem` },
              { name: `${renderCount}. ipsum` },
              { name: `${renderCount}. dolor` },
              { name: `${renderCount}. sit amet` },
            ]);
          }, 90)
        }
      >
        replace async
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <button
        id="replace"
        type="button"
        onClick={() =>
          replace([
            { name: `${renderCount}. lorem` },
            { name: `${renderCount}. ipsum` },
            { name: `${renderCount}. dolor` },
            { name: `${renderCount}. sit amet` },
          ])
        }
      >
        replace
      </button>

      <button
        id="reset"
        type="button"
        onClick={() => {
          reset({
            data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
          });
        }}
      >
        reset
      </button>

      <button
        id="resetAsync"
        type="button"
        onClick={() => {
          setTimeout(() => {
            reset({
              data: [],
            });
          }, 100);
        }}
      >
        reset async
      </button>

      <button id="submit">Submit</button>

      <div id="renderCount">{renderCount}</div>
      <div id="result">{JSON.stringify(data)}</div>
      <section>
        Dirty:
        <div id="dirty">{isDirty ? 'yes' : 'no'}</div>
      </section>
      <section>
        isValid:
        <div id="isValid">{isValid ? 'yes' : 'no'}</div>
      </section>
      <div id="dirtyFields">{JSON.stringify(dirtyFields)}</div>
      <div id="touched">{JSON.stringify(touchedFields.data)}</div>
    </form>
  );
};

export default UseFieldArray;


================================================
File: /app/src/useWatchUseFieldArrayNested.tsx
================================================
import React from 'react';
import {
  Controller,
  useFieldArray,
  useForm,
  useWatch,
  Control,
} from 'react-hook-form';

type FormValues = {
  test: {
    firstName: string;
    lastName: string;
    keyValue: { name: string }[];
  }[];
};

function NestedArray({
  control,
  index,
}: {
  control: Control<FormValues>;
  index: number;
}) {
  const { fields, append, prepend, swap, move, remove, insert, update } =
    useFieldArray<FormValues, 'test.0.keyValue'>({
      name: `test.${index}.keyValue` as 'test.0.keyValue',
      control,
    });
  const value = useWatch({
    name: 'test',
    control,
  });
  const renderCountRef = React.useRef(0);
  renderCountRef.current++;

  return (
    <div>
      <div>
        {fields.map((item, i) => (
          <Controller
            key={item.id}
            render={({ field }) => <input {...field} aria-label={'name'} />}
            name={`test.${index}.keyValue.${i}.name`}
            control={control}
          />
        ))}
      </div>

      <button
        id={`nest-append-${index}`}
        type="button"
        onClick={() => append({ name: 'append' })}
      >
        append
      </button>

      <button
        id={`nest-prepend-${index}`}
        type="button"
        onClick={() => prepend({ name: 'prepend' })}
      >
        prepend
      </button>

      <button
        id={`nest-swap-${index}`}
        onClick={() => swap(1, 2)}
        type="button"
      >
        swap
      </button>

      <button
        id={`nest-move-${index}`}
        onClick={() => move(2, 0)}
        type="button"
      >
        move
      </button>

      <button
        id={`nest-insert-${index}`}
        type="button"
        onClick={() => insert(1, { name: 'insert' })}
      >
        insert
      </button>

      <button
        id={`nest-update-${index}`}
        type="button"
        onClick={() => update(2, { name: 'update' })}
      >
        update
      </button>

      <button
        id={`nest-remove-${index}`}
        type="button"
        onClick={() => remove(1)}
      >
        remove
      </button>

      <button
        id={`nest-remove-all-${index}`}
        type="button"
        onClick={() => remove()}
      >
        remove all
      </button>

      <div id={`count-nest-${index}`}>{renderCountRef.current}</div>

      {index === 0 && <p id="result">{JSON.stringify(value)}</p>}
    </div>
  );
}

export default () => {
  const { register, control, reset, setValue, handleSubmit } =
    useForm<FormValues>({
      defaultValues: {
        test: [
          {
            firstName: 'Bill',
            lastName: 'Luo',
            keyValue: [{ name: '1a' }, { name: '1c' }],
          },
        ],
      },
    });
  const { fields, append, prepend, swap, move, insert, remove, update } =
    useFieldArray({
      control,
      name: 'test',
    });
  const renderCountRef = React.useRef(0);
  renderCountRef.current++;

  return (
    <form onSubmit={handleSubmit((e) => console.log(e))}>
      {fields.map((item, index) => {
        return (
          <div key={item.id}>
            <input
              aria-label={`test.${index}.firstName`}
              {...register(`test.${index}.firstName` as const)}
            />
            <NestedArray control={control} index={index} />
          </div>
        );
      })}

      <hr />

      <button
        id="append"
        type="button"
        onClick={() => append({ firstName: 'append' })}
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() => prepend({ firstName: 'prepend' })}
      >
        prepend
      </button>

      <button
        id="update"
        type="button"
        onClick={() => update(1, { firstName: 'update' })}
      >
        update
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(2, 0)} type="button">
        move
      </button>

      <button
        id="insert"
        type="button"
        onClick={() => insert(1, { firstName: 'insert' })}
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <button
        id="setValue"
        type={'button'}
        onClick={() =>
          setValue('test', [
            {
              firstName: 'test',
              lastName: 'test',
              keyValue: [
                {
                  name: 'test',
                },
              ],
            },
            {
              firstName: 'test1',
              lastName: 'test1',
              keyValue: [
                {
                  name: 'test1',
                },
              ],
            },
            {
              firstName: 'test2',
              lastName: 'test3',
              keyValue: [
                {
                  name: 'test3',
                },
              ],
            },
          ])
        }
      >
        setValue
      </button>

      <button
        id="reset"
        type="button"
        onClick={() => {
          reset({
            test: [
              { firstName: 'test' },
              { firstName: 'test1' },
              { firstName: 'test2' },
            ],
          });
        }}
      >
        reset
      </button>

      <div id="count">{renderCountRef.current}</div>

      <button id={'submit'}>Submit</button>
    </form>
  );
};


================================================
File: /app/src/watchUseFieldArrayNested.tsx
================================================
import React from 'react';
import { Controller, useFieldArray, useForm, Control } from 'react-hook-form';

type FormValues = {
  test: {
    firstName: string;
    lastName: string;
    keyValue: { name: string }[];
  }[];
};

function NestedArray({
  control,
  index,
}: {
  control: Control<FormValues>;
  index: number;
}) {
  const { fields, append, prepend, swap, move, remove, insert, update } =
    useFieldArray<FormValues, 'test.0.keyValue'>({
      name: `test.${index}.keyValue` as 'test.0.keyValue',
      control,
    });
  const renderCountRef = React.useRef(0);
  renderCountRef.current++;

  return (
    <div>
      <ul>
        {fields.map((item, i) => (
          <Controller
            key={item.id}
            render={({ field }) => <input {...field} aria-label={'name'} />}
            name={`test.${index}.keyValue.${i}.name`}
            control={control}
          />
        ))}
      </ul>

      <button
        id={`nest-append-${index}`}
        type="button"
        onClick={() => append({ name: 'append' })}
      >
        append
      </button>

      <button
        id={`nest-prepend-${index}`}
        type="button"
        onClick={() => prepend({ name: 'prepend' })}
      >
        prepend
      </button>

      <button
        id={`nest-update-${index}`}
        type="button"
        onClick={() => update(0, { name: 'billUpdate' })}
      >
        update
      </button>

      <button
        id={`nest-swap-${index}`}
        onClick={() => swap(1, 2)}
        type="button"
      >
        swap
      </button>

      <button
        id={`nest-move-${index}`}
        onClick={() => move(2, 0)}
        type="button"
      >
        move
      </button>

      <button
        id={`nest-insert-${index}`}
        type="button"
        onClick={() => insert(1, { name: 'insert' })}
      >
        insert
      </button>

      <button
        id={`nest-remove-${index}`}
        type="button"
        onClick={() => remove(1)}
      >
        remove
      </button>

      <button
        id={`nest-remove-all-${index}`}
        type="button"
        onClick={() => remove()}
      >
        remove all
      </button>

      <div id={`count-nest-${index}`}>{renderCountRef.current}</div>
    </div>
  );
}

export default () => {
  const { register, control, reset, setValue, handleSubmit, watch } =
    useForm<FormValues>({
      defaultValues: {
        test: [
          {
            firstName: 'Bill',
            lastName: 'Luo',
            keyValue: [{ name: '1a' }, { name: '1c' }],
          },
        ],
      },
    });
  const { fields, append, prepend, swap, move, insert, remove, update } =
    useFieldArray({
      control,
      name: 'test',
    });
  const renderCountRef = React.useRef(0);
  renderCountRef.current++;

  const result = watch('test');

  return (
    <form onSubmit={handleSubmit((e) => console.log(e))}>
      {fields.map((item, index) => {
        return (
          <div key={item.id}>
            <input
              aria-label={`test.${index}.firstName`}
              {...register(`test.${index}.firstName` as const)}
            />
            <NestedArray control={control} index={index} />
          </div>
        );
      })}

      <hr />

      <button
        id="append"
        type="button"
        onClick={() => append({ firstName: 'append' })}
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() => prepend({ firstName: 'prepend' })}
      >
        prepend
      </button>

      <button
        id="update"
        onClick={() =>
          update(0, {
            firstName: 'BillUpdate',
          })
        }
        type="button"
      >
        update
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(2, 0)} type="button">
        move
      </button>

      <button
        id="insert"
        type="button"
        onClick={() => insert(1, { firstName: 'insert' })}
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <button
        id="setValue"
        type={'button'}
        onClick={() =>
          setValue('test', [
            {
              firstName: 'test',
              lastName: 'test',
              keyValue: [
                {
                  name: 'test',
                },
              ],
            },
            {
              firstName: 'test1',
              lastName: 'test',
              keyValue: [
                {
                  name: 'test',
                },
              ],
            },
            {
              firstName: 'test2',
              lastName: 'test',
              keyValue: [
                {
                  name: 'test',
                },
              ],
            },
          ])
        }
      >
        setValue
      </button>

      <button
        id="reset"
        type="button"
        onClick={() => {
          reset({
            test: [
              { firstName: 'test' },
              { firstName: 'test1' },
              { firstName: 'test2' },
            ],
          });
        }}
      >
        reset
      </button>

      <div id="count">{renderCountRef.current}</div>

      <p id="result">{JSON.stringify(result)}</p>

      <button id={'submit'}>Submit</button>
    </form>
  );
};


================================================
File: /app/src/setError.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { FieldPath } from '../../src/types';

type FormInputs = {
  firstName: string;
  lastName: string;
  age: string;
  test: string;
  test1: string;
  test2: string;
  username: string;
};

const SetError: React.FC = () => {
  const {
    register,
    setError,
    clearErrors,
    formState: { errors },
  } = useForm<FormInputs>();

  useEffect(() => {
    register('firstName');
    register('lastName');
    register('age');
    register('test');
    register('test1');
    register('username');
    register('test2');

    setError('firstName', { type: 'wrong' });
    setError('lastName', { type: 'wrong' });
    setError('age', { type: 'wrong' });
    setError('test', { type: 'test', message: 'testMessage' });
    [
      {
        type: 'required',
        name: 'test1',
        message: 'This is required.',
      },
      {
        type: 'minLength',
        name: 'test2',
        message: 'Minlength is 10',
      },
    ].forEach(({ name, type, message }) =>
      setError(name as FieldPath<FormInputs>, { type, message }),
    );
    setError('username', {
      types: {
        required: 'This is required',
        minLength: 'This is minLength',
      },
    });
  }, [register, setError]);

  return (
    <div>
      <p id="error">
        {errors.test && errors.test.message}
        {errors.test1 && errors.test1.message}
        {errors.test2 && errors.test2.message}
        {errors.username &&
          errors.username.types &&
          errors.username.types.required}
        {errors.username &&
          errors.username.types &&
          errors.username.types.minLength}
      </p>

      <div id="errorContainer">
        {Object.values(errors).map((error, index) => (
          <div id={`error${index}`} key={index}>
            {index} {error && error.type}
          </div>
        ))}
      </div>

      <input
        id="clear1"
        value="clearError1"
        type="button"
        onClick={() => {
          clearErrors('firstName');
        }}
      />

      <input
        id="clear2"
        value="clearError2"
        type="button"
        onClick={() => {
          clearErrors('lastName');
        }}
      />

      <input
        id="clearArray"
        value="clearErrorArray"
        type="button"
        onClick={() => {
          clearErrors(['firstName', 'lastName']);
        }}
      />

      <input
        id="clear"
        value="clearError"
        type="button"
        onClick={() => {
          clearErrors();
        }}
      />
    </div>
  );
};

export default SetError;


================================================
File: /app/src/formStateWithNestedFields.tsx
================================================
import React from 'react';
import { useForm, ValidationMode } from 'react-hook-form';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const FormStateWithNestedFields = () => {
  const { mode } = useParams();
  const {
    register,
    handleSubmit,
    formState: {
      dirtyFields,
      isSubmitted,
      submitCount,
      touchedFields,
      isDirty,
      isSubmitting,
      isSubmitSuccessful,
      isValid,
    },
    reset,
  } = useForm<{
    left: {
      test1: string;
      test2: string;
    };
    right: {
      test1: string;
      test2: string;
    };
  }>({
    mode: mode as keyof ValidationMode,
    defaultValues: {
      left: {
        test1: '',
        test2: '',
      },
      right: {
        test1: '',
        test2: '',
      },
    },
  });

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(() => {})}>
      <div style={{ display: 'flex' }}>
        <div style={{ display: 'flex', flexDirection: 'column' }}>
          <h4>Left</h4>
          <input
            {...register('left.test1', { required: true })}
            placeholder="firstName"
          />
          <input
            {...register('left.test2', { required: true })}
            placeholder="lastName"
          />
        </div>
        <div style={{ display: 'flex', flexDirection: 'column' }}>
          <h4>Right</h4>
          <input
            {...register('right.test1', { required: false })}
            placeholder="firstName"
          />
          <input
            {...register('right.test2', { required: false })}
            placeholder="lastName"
          />
        </div>
      </div>
      <div id="state">
        {JSON.stringify({
          isDirty,
          isSubmitted,
          submitCount,
          isSubmitting,
          isSubmitSuccessful,
          isValid,
          touched: (
            Object.keys(touchedFields) as Array<keyof typeof touchedFields>
          ).flatMap((topLevelKey) =>
            Object.keys(touchedFields[topLevelKey] || {}).map(
              (nestedKey) => `${topLevelKey}.${nestedKey}`,
            ),
          ),
          dirty: (
            Object.keys(dirtyFields) as Array<keyof typeof touchedFields>
          ).flatMap((topLevelKey) =>
            Object.keys(dirtyFields[topLevelKey] || {}).map(
              (nestedKey) => `${topLevelKey}.${nestedKey}`,
            ),
          ),
        })}
      </div>
      <button id="submit">Submit</button>
      <button type="button" onClick={() => reset()} id="resetForm">
        Reset
      </button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default FormStateWithNestedFields;


================================================
File: /app/src/conditionalField.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

const ConditionalField: React.FC = () => {
  const {
    register,
    handleSubmit,
    watch,
    formState: {
      dirtyFields,
      isSubmitted,
      submitCount,
      touchedFields,
      isDirty,
      isSubmitting,
      isSubmitSuccessful,
      isValid,
      errors,
    },
  } = useForm<{
    selectNumber: string;
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    notRequired: string;
  }>({
    mode: 'onChange',
  });
  const [result, setResult] = React.useState({});

  const selectNumber = watch('selectNumber');

  renderCounter++;

  return (
    <form
      onSubmit={handleSubmit((data) => {
        setResult(data);
      })}
    >
      <select {...register('selectNumber', { required: true })}>
        <option value="">Select</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>

      {selectNumber === '1' && (
        <>
          <input
            {...register('firstName', { required: true })}
            placeholder="firstName"
          />
          <input
            {...register('lastName', { required: true })}
            placeholder="lastName"
          />
        </>
      )}

      {selectNumber === '2' && (
        <>
          <input
            type="number"
            {...register('min', { required: true, min: 10 })}
            placeholder="min"
          />
          <input
            type="number"
            {...register('max', { required: true, max: 20 })}
            placeholder="max"
          />
        </>
      )}

      {selectNumber === '3' && (
        <>
          <input {...register('notRequired')} placeholder="notRequired" />
        </>
      )}

      <button id="submit">Submit</button>
      <div id="state">
        {JSON.stringify({
          isSubmitted,
          submitCount,
          isDirty,
          isSubmitting,
          isSubmitSuccessful,
          isValid,
          touched: Object.keys(touchedFields),
          dirty: Object.keys(dirtyFields),
        })}
      </div>
      <div id="result">{JSON.stringify(result)}</div>
      <div id="result">{typeof selectNumber}</div>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default ConditionalField;


================================================
File: /app/src/watch.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

const Watch: React.FC = () => {
  const { register, handleSubmit, watch } = useForm<{
    testSingle: string;
    test: string[];
    testObject: {
      firstName: string;
      lastName: string;
    };
    toggle: string;
  }>();
  const onSubmit = () => {};
  const test = watch('test');
  const testObject = watch('testObject');
  const testSingle = watch('testSingle');
  const testArray = watch(['test.0', 'test.1']);
  const toggle = watch('toggle');
  const watchAll = watch();

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('testSingle')} placeholder="testSingle" />
      {testSingle === 'testSingle' && (
        <div id="HideTestSingle">Hide Content TestSingle</div>
      )}

      <input {...register('test.0')} placeholder="test[0]" />
      <input {...register('test.1')} placeholder="test[1]" />

      <div id="testData">{JSON.stringify(test)}</div>
      <div id="testArray">{JSON.stringify(testArray)}</div>

      <input
        {...register('testObject.firstName')}
        placeholder="testObject.firstName"
      />
      <input
        {...register('testObject.lastName')}
        placeholder="testObject.lastName"
      />

      <div id="testObject">{JSON.stringify(testObject)}</div>

      <input type="checkbox" {...register('toggle')} />
      {toggle && <div id="hideContent">Hide Content</div>}

      <div id="watchAll">{JSON.stringify(watchAll)}</div>

      <button>Submit</button>
    </form>
  );
};

export default Watch;


================================================
File: /app/src/useFieldArrayUnregister.tsx
================================================
import React from 'react';
import {
  useForm,
  useWatch,
  useFieldArray,
  Controller,
  Control,
  UseFormReturn,
} from 'react-hook-form';

let renderCount = 0;

type FormInputs = {
  data: { name: string; conditional: string }[];
};

const ConditionField = <T extends any[]>({
  control,
  index,
  unregister,
}: {
  control: Control<FormInputs>;
  unregister: UseFormReturn<FormInputs>['unregister'];
  index: number;
  fields: T;
}) => {
  const output = useWatch({
    name: 'data',
    control,
  });

  React.useEffect(() => {
    return () => {
      unregister(`data.${index}.conditional` as const, {
        keepDirty: true,
        keepTouched: true,
      });
    };
  }, [unregister, index]);

  return output?.[index]?.name === 'bill' ? (
    <input {...control.register(`data.${index}.conditional`)} />
  ) : null;
};

const UseFieldArrayUnregister: React.FC = () => {
  const {
    control,
    handleSubmit,
    register,
    unregister,
    setValue,
    getValues,
    formState: { isDirty, touchedFields, dirtyFields, errors },
  } = useForm<FormInputs>({
    defaultValues: {
      data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
    },
    mode: 'onSubmit',
  });
  const { fields, append, prepend, swap, move, insert, remove } =
    useFieldArray<FormInputs>({
      control,
      name: 'data',
    });
  const [data, setData] = React.useState<FormInputs>();
  const updateFieldArray = () => {
    setValue('data', [...getValues().data, { name: 'test', conditional: '' }]);
  };

  renderCount++;

  return (
    <form
      onSubmit={handleSubmit((data) => {
        setData(data);
      })}
    >
      <ul>
        {fields.map((data, index) => (
          <li key={data.id}>
            {index % 2 ? (
              <input
                id={`field${index}`}
                data-order={index}
                {...register(`data.${index}.name`, {
                  required: 'This is required',
                })}
              />
            ) : (
              <Controller
                render={({ field }) => (
                  <input id={`field${index}`} {...field} />
                )}
                control={control}
                rules={{
                  required: 'This is required',
                }}
                name={`data.${index}.name`}
                data-order={index}
              />
            )}
            {errors.data?.[index]?.name && (
              <p id={`error${index}`}>{errors.data[index]!.name!.message}</p>
            )}

            <ConditionField
              control={control}
              index={index}
              fields={fields}
              unregister={unregister}
            />

            <button id={`delete${index}`} onClick={() => remove(index)}>
              Delete
            </button>
          </li>
        ))}
      </ul>

      <button
        id="append"
        type="button"
        onClick={() =>
          append({ name: renderCount.toString(), conditional: '' })
        }
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() =>
          prepend({ name: renderCount.toString(), conditional: '' })
        }
      >
        prepend
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(4, 2)} type="button">
        move
      </button>

      <button
        id="insert"
        type="button"
        onClick={() =>
          insert(1, { name: renderCount.toString(), conditional: '' })
        }
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <button id="submit">Submit</button>

      <button type={'button'} onClick={updateFieldArray}>
        SetValue
      </button>

      <div id="renderCount">{renderCount}</div>
      <div id="result">{JSON.stringify(data)}</div>
      <div id="dirty">{isDirty ? 'yes' : 'no'}</div>
      <div id="dirtyFields">{JSON.stringify(dirtyFields)}</div>
      <div id="touched">{JSON.stringify(touchedFields.data)}</div>
    </form>
  );
};

export default UseFieldArrayUnregister;


================================================
File: /app/src/isValid.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const validationSchema = yup
  .object()
  .shape({
    firstName: yup.string().required(),
    lastName: yup.string().max(5).required(),
  })
  .required();

const IsValid: React.FC = () => {
  const { mode, defaultValues } = useParams();
  const isBuildInValidation = mode === 'build-in';
  const [show, setShow] = React.useState(true);
  const {
    register,
    handleSubmit,
    unregister,
    formState: { isValid },
  } = useForm<{
    firstName: string;
    lastName: string;
    hidden: string;
    age: string;
    location: string;
    select: string;
    radio: string;
    checkbox: string;
  }>({
    mode: 'onChange',
    ...(isBuildInValidation ? {} : { resolver: yupResolver(validationSchema) }),
    ...(defaultValues === 'defaultValues'
      ? {
          defaultValues: {
            firstName: 'test',
            lastName: 'test1',
          },
        }
      : {}),
  });

  React.useEffect(() => {
    if (isBuildInValidation) {
      if (show) {
        unregister('hidden');
      }
    } else {
      if (!show) {
        unregister('firstName');
      }
    }
  }, [show, isBuildInValidation, unregister]);

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(() => {})}>
      {isBuildInValidation ? (
        <>
          <input {...register('location')} placeholder="location" />
          <input
            {...register('firstName', { required: true })}
            placeholder="firstName"
          />
          <input
            {...register('lastName', { required: true })}
            placeholder="lastName"
          />
          {!show && (
            <input
              {...register('hidden', { required: true })}
              placeholder="hidden"
            />
          )}
          <input {...register('age')} placeholder="age" />
        </>
      ) : (
        <>
          <input {...register('location')} placeholder="location" />
          {show && <input {...register('firstName')} placeholder="firstName" />}
          <input {...register('lastName')} placeholder="lastName" />
          <input {...register('age')} placeholder="age" />
        </>
      )}
      <div id="isValid">{JSON.stringify(isValid)}</div>
      <div id="renderCount">{renderCounter}</div>

      <button
        type="button"
        id="toggle"
        onClick={() => {
          setShow(!show);
        }}
      >
        Toggle
      </button>
    </form>
  );
};

export default IsValid;


================================================
File: /app/src/style.css
================================================
body {
  padding: 20px;
  background: #081229;
  color: white;
}

select,
input {
  display: block;
  box-sizing: border-box;
  width: 100%;
  border-radius: 4px;
  border: 1px solid white;
  padding: 10px 15px;
  margin-bottom: 15px;
  font-size: 14px;
  max-width: 600px;
}

label {
  display: block;
  margin-bottom: 8px;
}

button,
input[type='submit'],
.button {
  position: relative;
  background: #ec5990;
  color: white;
  text-transform: uppercase;
  border: none;
  margin-top: 20px;
  padding: 20px;
  font-size: 16px;
  letter-spacing: 10px;
  display: block;
  appearance: none;
  border-radius: 4px;
  width: 100%;
  font-weight: lighter;
  transition: 0.3s all;
  max-width: 600px;
}

button[type='button'] {
  background: #516391;
  color: white;
  text-transform: none;
  padding: 10px;
  letter-spacing: 2px;
}

input[type='submit']:hover,
button[type='button']:hover {
  background: #bf1650;
  color: white;
}

input[type='submit']:active {
  transition: 0.3s all;
  top: 2px;
}


================================================
File: /app/src/watchDefaultValues.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

function WatchDefaultValues() {
  const { watch } = useForm({
    defaultValues: {
      test: 'test',
      test1: {
        firstName: 'firstName',
        lastName: ['lastName0', 'lastName1'],
        deep: {
          nest: 'nest',
        },
      },
      'flatName[1]': {
        whatever: 'flat',
      },
    },
  });

  const all = watch();
  const array = watch(['test', 'flatName[1]']);
  const singleObject = watch('test1.firstName');
  const arrayStringOrObject = watch(['test', 'test1.firstName']);
  const getDeepArray = watch('test1.lastName');
  const singleDeepArray = watch('test1.lastName.0');

  return (
    <>
      <div id="watchAll">{JSON.stringify(all)}</div>
      <br />
      <div id="array">{JSON.stringify(array)}</div>
      <br />
      <div id="getArray">{JSON.stringify(getDeepArray)}</div>
      <br />
      <div id="object">{JSON.stringify(arrayStringOrObject)}</div>
      <br />
      <div id="single">{JSON.stringify(singleObject)}</div>
      <br />
      <div id="singleDeepArray">{JSON.stringify(singleDeepArray)}</div>
    </>
  );
}

export default WatchDefaultValues;


================================================
File: /app/src/reset.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

function Reset() {
  const { register, reset } = useForm<{
    firstName: string;
    lastName: string;
    objectData: {
      test: string;
    };
    array: string[];
    deepNest: {
      level1: {
        level2: {
          data: string;
        };
      };
    };
  }>();
  return (
    <>
      <input {...register('firstName')} />
      <input {...register('array.1')} />
      <input {...register('objectData.test')} />
      <input {...register('lastName')} />
      <input {...register('deepNest.level1.level2.data')} />
      <button
        type="button"
        onClick={() =>
          reset({
            firstName: 'bill',
            lastName: 'luo',
            array: ['', 'test'],
            objectData: { test: 'data' },
            deepNest: {
              level1: {
                level2: {
                  data: 'hey',
                },
              },
            },
          })
        }
      >
        button
      </button>
    </>
  );
}

export default Reset;


================================================
File: /app/src/triggerValidation.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

function TriggerValidation() {
  const {
    register,
    trigger,
    formState: { errors },
  } = useForm<{
    test: string;
    test1: string;
    test2: string;
  }>();

  renderCounter++;

  return (
    <>
      <input {...register('test', { required: true })} />
      <div id="testError">{errors.test && 'required'}</div>

      <input {...register('test1', { required: true })} />
      <div id="test1Error">{errors.test1 && 'required'}</div>

      <input {...register('test2', { required: true })} />
      <div id="test2Error">{errors.test2 && 'required'}</div>

      <button id="single" type="button" onClick={() => trigger('test')}>
        trigger single
      </button>

      <button
        id="multiple"
        type="button"
        onClick={() => trigger(['test1', 'test2'])}
      >
        trigger multiple
      </button>

      <div id="renderCount">{renderCounter}</div>
    </>
  );
}

export default TriggerValidation;


================================================
File: /app/src/defaultValuesAsync.tsx
================================================
import React from 'react';
import { useForm } from 'react-hook-form';

const sleep = <T,>(data: T, ms: number) =>
  new Promise<T>((res) => setTimeout(() => res(data), ms));

function DefaultValues() {
  const { register } = useForm({
    defaultValues: async () =>
      sleep(
        {
          test: 'test',
          checkbox: ['1', '2'],
          test1: {
            firstName: 'firstName',
            lastName: ['lastName0', 'lastName1'],
            deep: {
              nest: 'nest',
            },
          },
        },
        10,
      ),
  });
  const [show, setShow] = React.useState(true);

  return (
    <>
      {show ? (
        <form>
          <input {...register('test')} />
          <input {...register('test1.firstName')} />
          <input {...register('test1.deep.nest')} />
          <input {...register('test1.deep.nest')} />
          <input {...register('test1.lastName.0')} />
          <input {...register('test1.lastName.1')} />
          <input type="checkbox" value={'1'} {...register('checkbox')} />
          <input type="checkbox" value={'2'} {...register('checkbox')} />
        </form>
      ) : null}
      <button type={'button'} id={'toggle'} onClick={() => setShow(!show)}>
        toggle
      </button>
    </>
  );
}

export default DefaultValues;


================================================
File: /app/src/setValueStrictMode.tsx
================================================
import React, { useEffect } from 'react';
import { useForm, Controller } from 'react-hook-form';

const SetValueAsyncStrictMode = () => {
  const state = React.useRef(new Set());
  const [, update] = React.useState({});
  const { register, setValue, control } = useForm<{
    firstName: string;
  }>();

  useEffect(() => {
    setTimeout(() => {
      setValue('firstName', 'A');
    }, 10);

    setTimeout(() => {
      setValue('firstName', 'B', { shouldDirty: true });
    }, 20);

    setTimeout(() => {
      setValue('firstName', 'C', { shouldTouch: true });
    }, 30);

    setTimeout(() => {
      setValue('firstName', 'D', { shouldValidate: true });
    }, 40);
  }, [register, setValue]);

  return (
    <React.StrictMode>
      <form>
        <Controller
          defaultValue={'test'}
          control={control}
          render={({ field }) => {
            state.current.add(field.value);
            return <input id={'input'} {...field} />;
          }}
          name={'firstName'}
        />

        <button id="submit" type={'button'} onClick={() => update({})}>
          Submit
        </button>

        <p id="result">{JSON.stringify([...state.current])}</p>
      </form>
    </React.StrictMode>
  );
};

export default SetValueAsyncStrictMode;


================================================
File: /app/src/formState.tsx
================================================
import React from 'react';
import { useForm, ValidationMode } from 'react-hook-form';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const FormState = () => {
  const { mode } = useParams();
  const {
    register,
    handleSubmit,
    formState: {
      dirtyFields,
      isSubmitted,
      submitCount,
      touchedFields,
      isDirty,
      isSubmitting,
      isSubmitSuccessful,
      isValid,
    },
    reset,
  } = useForm<{
    firstName: string;
    lastName: string;
    select: string;
    radio: string | null;
    checkbox: boolean;
    ['checkbox-checked']: boolean;
  }>({
    mode: mode as keyof ValidationMode,
    defaultValues: {
      firstName: '',
      lastName: '',
      select: '',
      checkbox: false,
      radio: null,
      'checkbox-checked': true,
    },
  });

  renderCounter++;

  return (
    <form
      onSubmit={handleSubmit((d) => {
        console.log(d);
      })}
    >
      <input
        {...register('firstName', { required: true })}
        placeholder="firstName"
      />
      <input
        {...register('lastName', { required: true })}
        placeholder="lastName"
      />
      <div id="state">
        {JSON.stringify({
          isSubmitted,
          submitCount,
          isDirty,
          isSubmitting,
          isSubmitSuccessful,
          isValid,
          touched: Object.keys(touchedFields),
          dirty: Object.keys(dirtyFields),
        })}
      </div>
      <select {...register('select')} defaultValue="test">
        <option value="">Select</option>
        <option value="test">test</option>
        <option value="test1">test1</option>
        <option value="test2">test3</option>
      </select>

      <input type="radio" {...register('radio')} />

      <input type="checkbox" {...register('checkbox')} />
      <input type="checkbox" {...register('checkbox-checked')} />
      <button id="submit">Submit</button>
      <button type="button" onClick={() => reset()} id="resetForm">
        Reset
      </button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default FormState;


================================================
File: /app/src/reValidateMode.tsx
================================================
import React from 'react';
import { useParams } from 'react-router-dom';
import { useForm, ValidationMode } from 'react-hook-form';

type ReValidateMode = 'onBlur' | 'onChange' | 'onSubmit' | undefined;
let renderCounter = 0;

const Basic: React.FC = () => {
  const { mode, reValidateMode } = useParams();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
  }>({
    mode: mode as keyof ValidationMode,
    reValidateMode: reValidateMode as keyof ReValidateMode,
  });
  const onSubmit = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('firstName', { required: true })}
        placeholder="firstName"
      />
      {errors.firstName && <p>firstName error</p>}
      <input
        {...register('lastName', { required: true, maxLength: 5 })}
        placeholder="lastName"
      />
      {errors.lastName && <p>lastName error</p>}
      <button id="submit">Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default Basic;


================================================
File: /app/src/delayError.tsx
================================================
import { useForm } from 'react-hook-form';
import React from 'react';

export function DelayError() {
  const {
    register,
    reset,
    formState: { errors },
  } = useForm({
    delayError: 100,
    mode: 'onChange',
    defaultValues: {
      first: '',
      last: '',
    },
  });
  return (
    <form>
      <input
        {...register('first', {
          maxLength: {
            value: 1,
            message: 'First too long.',
          },
        })}
        placeholder="First field"
      />
      {errors.first?.message && <p>{errors.first?.message}</p>}
      <input
        autoComplete="off"
        {...register('last', {
          maxLength: {
            value: 5,
            message: 'Last too long.',
          },
          minLength: {
            value: 2,
            message: 'Last too long.',
          },
        })}
        placeholder="Last field"
      />
      {errors.last?.message && <p>{errors.last?.message}</p>}
      <button
        type={'button'}
        onClick={() =>
          reset({
            first: '',
            last: '',
          })
        }
      >
        reset
      </button>
    </form>
  );
}


================================================
File: /app/src/setValueWithSchema.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

let renderCounter = 0;

const validationSchema = yup
  .object()
  .shape({
    lastName: yup.string().min(10).required(),
    firstName: yup.string().min(10).required(),
    requiredField: yup.string().required(),
  })
  .required();

const SetValueWithSchema: React.FC = () => {
  const {
    register,
    setValue,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
    age: string;
    checkbox: boolean;
    radio: string;
    select: string;
    multiple: string[];
    requiredField: string;
  }>({
    resolver: yupResolver(validationSchema),
  });

  renderCounter++;

  useEffect(() => {
    register('firstName', { required: true });
    register('lastName', { required: true });
  }, [register]);

  return (
    <form
      onSubmit={handleSubmit((d) => {
        console.log(d);
      })}
    >
      <input
        name="firstName"
        placeholder="firstName"
        onChange={(e) => {
          setValue('firstName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          });
        }}
      />
      {errors.firstName && <p>firstName error</p>}

      <input
        name="lastName"
        placeholder="lastName"
        onChange={(e) => {
          setValue('lastName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          });
        }}
      />
      {errors.lastName && <p>lastName error</p>}

      <input
        {...register('age')}
        onChange={(e) => {
          setValue('age', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          });
        }}
      />

      <input placeholder="requiredField" {...register('requiredField')} />
      {errors.requiredField && <p>RequiredField error</p>}

      <button
        type="button"
        id="setValue"
        onClick={() => {
          setValue('requiredField', 'test123456789', {
            shouldValidate: true,
            shouldDirty: true,
          });
        }}
      >
        firstName reset
      </button>

      <button id="submit">Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default SetValueWithSchema;


================================================
File: /app/src/setValueCustomRegister.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

const SetValueCustomRegister: React.FC = () => {
  const {
    register,
    setValue,
    handleSubmit,
    formState: { touchedFields, isDirty, errors },
  } = useForm<{
    firstName: string;
    lastName: string;
  }>();

  useEffect(() => {
    register('firstName', { required: true });
    register('lastName', { required: true });
  }, [register]);

  renderCounter++;

  console.log(errors);

  return (
    <form onSubmit={handleSubmit(() => {})}>
      <button
        id="TriggerDirty"
        type="button"
        onClick={() => setValue('lastName', 'test', { shouldDirty: true })}
      >
        TriggerDirty
      </button>
      <button
        id="TriggerNothing"
        type="button"
        onClick={() => setValue('firstName', '', { shouldDirty: true })}
      >
        TriggerNothing
      </button>
      <button
        id="WithError"
        type="button"
        onClick={() =>
          setValue('firstName', '', { shouldValidate: true, shouldDirty: true })
        }
      >
        WithError
      </button>
      <button
        id="WithoutError"
        type="button"
        onClick={() =>
          setValue('firstName', 'true', {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      >
        WithOutError
      </button>

      <div id="dirty">{isDirty.toString()}</div>
      <div id="touched">{Object.keys(touchedFields).map((touch) => touch)}</div>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default SetValueCustomRegister;


================================================
File: /app/src/setValueWithTrigger.tsx
================================================
import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';

let renderCounter = 0;

const SetValueWithTrigger: React.FC = () => {
  const {
    register,
    setValue,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
  }>();

  useEffect(() => {
    register('firstName', {
      required: 'required',
      minLength: {
        value: 10,
        message: 'minLength 10',
      },
    });
    register('lastName', {
      validate: (data) => {
        if (data === 'bill') {
          return true;
        }

        if (data && data.length < 10) {
          return 'too short';
        }

        return 'error message';
      },
    });
  }, [register]);

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(() => {})}>
      <input
        name="firstName"
        placeholder="firstName"
        onChange={(e) =>
          setValue('firstName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.firstName && <p>{errors.firstName.message}</p>}

      <input
        name="lastName"
        placeholder="lastName"
        onChange={(e) =>
          setValue('lastName', e.target.value, {
            shouldValidate: true,
            shouldDirty: true,
          })
        }
      />
      {errors.lastName && <p>{errors.lastName.message}</p>}

      <button>Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default SetValueWithTrigger;


================================================
File: /app/src/basic.tsx
================================================
import React, { useState } from 'react';
import { useForm, NestedValue, ValidationMode } from 'react-hook-form';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const Basic: React.FC = () => {
  const { mode } = useParams();
  const [data, setData] = React.useState({});
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<{
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    minDate: string;
    maxDate: string;
    minLength: string;
    minRequiredLength: string;
    selectNumber: string;
    pattern: string;
    radio: string;
    checkbox: string;
    checkboxArray: NestedValue<string[]>;
    multiple: string;
    validate: string;
    nestItem: {
      nest1: string;
    };
    arrayItem: { test1: string; test2: string }[];
  }>({
    mode: mode as keyof ValidationMode,
  });
  const [onInvalidCalledTimes, setOnInvalidCalledTimes] = useState(0);
  const onInvalid = () => setOnInvalidCalledTimes((prevCount) => prevCount + 1);

  renderCounter++;

  return (
    <form
      onSubmit={handleSubmit((data) => {
        setData(data);
      }, onInvalid)}
    >
      <input
        placeholder="nestItem.nest1"
        {...register('nestItem.nest1', { required: true })}
      />
      {errors.nestItem?.nest1 && <p>nest 1 error</p>}
      <input
        placeholder="arrayItem[0].test1"
        {...register('arrayItem.0.test1', { required: true })}
      />
      {errors.arrayItem?.[0]?.test1 && <p>array item 1 error</p>}
      <input
        {...register('firstName', { required: true })}
        placeholder="firstName"
      />
      {errors.firstName && <p>firstName error</p>}
      <input
        {...register('lastName', { required: true, maxLength: 5 })}
        placeholder="lastName"
      />
      {errors.lastName && <p>lastName error</p>}
      <input
        type="number"
        {...register('min', { min: 10 })}
        placeholder="min"
      />
      {errors.min && <p>min error</p>}
      <input
        type="number"
        {...register('max', { max: 20 })}
        placeholder="max"
      />
      {errors.max && <p>max error</p>}
      <input
        type="date"
        {...register('minDate', { min: '2019-08-01' })}
        placeholder="minDate"
      />
      {errors.minDate && <p>minDate error</p>}
      <input
        type="date"
        {...register('maxDate', { max: '2019-08-01' })}
        placeholder="maxDate"
      />
      {errors.maxDate && <p>maxDate error</p>}
      <input
        {...register('minLength', { minLength: 2 })}
        placeholder="minLength"
      />
      {errors.minLength && <p>minLength error</p>}
      <input
        {...register('minRequiredLength', { minLength: 2, required: true })}
        placeholder="minRequiredLength"
      />
      {errors.minRequiredLength && <p>minRequiredLength error</p>}
      <select {...register('selectNumber', { required: true })}>
        <option value="">Select</option>
        <option value={'1'}>1</option>
        <option value={'2'}>2</option>
      </select>
      {errors.selectNumber && <p>selectNumber error</p>}
      <input
        {...register('pattern', { pattern: /\d+/ })}
        placeholder="pattern"
      />
      {errors.pattern && <p>pattern error</p>}
      Radio1
      <input type="radio" {...register('radio')} value="1" />
      Radio2
      <input type="radio" value="2" {...register('radio')} />
      Radio3
      <input
        type="radio"
        value="3"
        {...register('radio', { required: true })}
      />
      {errors.radio && <p>radio error</p>}
      <input type="checkbox" {...register('checkbox', { required: true })} />
      {errors.checkbox && <p>checkbox error</p>}
      <input
        type="checkbox"
        value="1"
        {...register('checkboxArray', { required: true })}
      />
      <input
        type="checkbox"
        value="2"
        {...register('checkboxArray', { required: true })}
      />
      <input
        type="checkbox"
        value="3"
        {...register('checkboxArray', { required: true })}
      />
      {errors.checkboxArray && <p>checkboxArray error</p>}
      <select multiple {...register('multiple', { required: true })}>
        <option value="optionA">optionA</option>
        <option value="optionB">optionB</option>
      </select>
      {errors.multiple && <p>multiple error</p>}
      <input
        type="validate"
        placeholder="validate"
        {...register('validate', {
          validate: (value) => value === 'test',
        })}
      />
      {errors.validate && <p>validate error</p>}
      <button id="submit">Submit</button>
      <button type="button" id="resetForm" onClick={() => reset()}>
        Reset
      </button>
      <div id="renderCount">{renderCounter}</div>
      <div id="on-invalid-called-times">
        onInvalid callback called {onInvalidCalledTimes} times
      </div>
      <pre>{JSON.stringify(data)}</pre>
    </form>
  );
};

export default Basic;


================================================
File: /app/src/app.tsx
================================================
import React from 'react';
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import AutoUnregister from './autoUnregister';
import Basic from './basic';
import Watch from './watch';
import BasicSchemaValidation from './basicSchemaValidation';
import CrossFrameForm from './crossFrameForm';
import SetError from './setError';
import SetFocus from './setFocus';
import SetValue from './setValue';
import FormState from './formState';
import ManualRegisterForm from './manualRegisterForm';
import DefaultValues from './defaultValues';
import DefaultValuesAsync from './defaultValuesAsync';
import WatchDefaultValues from './watchDefaultValues';
import Reset from './reset';
import TriggerValidation from './triggerValidation';
import ReValidateMode from './reValidateMode';
import ValidateFieldCriteria from './validateFieldCriteria';
import SetValueCustomRegister from './setValueCustomRegister';
import ConditionalField from './conditionalField';
import FormStateWithSchema from './formStateWithSchema';
import SetValueWithSchema from './setValueWithSchema';
import SetValueWithTrigger from './setValueWithTrigger';
import IsValid from './isValid';
import Controller from './controller';
import UseFieldArray from './useFieldArray';
import UseFieldArrayNested from './useFieldArrayNested';
import CustomSchemaValidation from './customSchemaValidation';
import WatchFieldArray from './watchUseFieldArray';
import UseWatch from './useWatch';
import FormStateWithNestedFields from './formStateWithNestedFields';
import UseFieldArrayUnregister from './useFieldArrayUnregister';
import WatchUseFieldArrayNested from './watchUseFieldArrayNested';
import UseWatchUseFieldArrayNested from './useWatchUseFieldArrayNested';
import Test from './test';
import Welcome from './welcome';
import { UseFormState } from './useFormState';
import SetValueAsyncStrictMode from './setValueStrictMode';
import { DelayError } from './delayError';
import './style.css';
import FormComponent from './form';
import DisabledFields from './disabledFields';
import ResetKeepDirty from './resetKeepDirty';

const App = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/basic/:mode" element={<Basic />} />
        <Route
          path="/validate-field-criteria"
          element={<ValidateFieldCriteria />}
        />
        <Route path="/controller/:mode" element={<Controller />} />
        <Route
          path="/re-validate-mode/:mode/:reValidateMode"
          element={<ReValidateMode />}
        />
        <Route path="/crossFrameForm" element={<CrossFrameForm />} />
        <Route path="/manual-register-form" element={<ManualRegisterForm />} />
        <Route path="/watch" element={<Watch />} />
        <Route
          path="/basic-schema-validation/:mode"
          element={<BasicSchemaValidation />}
        />
        <Route path="/setError" element={<SetError />} />
        <Route path="/delayError" element={<DelayError />} />
        <Route path="/setFocus" element={<SetFocus />} />
        <Route path="/setValueWithTrigger" element={<SetValueWithTrigger />} />
        <Route path="/conditionalField" element={<ConditionalField />} />
        <Route path="/UseFieldArray/:mode" element={<UseFieldArray />} />
        <Route
          path="/UseFieldArrayUnregister"
          element={<UseFieldArrayUnregister />}
        />
        <Route path="/reset" element={<Reset />} />
        <Route path="/resetKeepDirty" element={<ResetKeepDirty />} />
        <Route path="/setValue" element={<SetValue />} />
        <Route
          path="/setValueAsyncStrictMode"
          element={<SetValueAsyncStrictMode />}
        />
        <Route path="/setValueWithSchema" element={<SetValueWithSchema />} />
        <Route
          path="/SetValueCustomRegister"
          element={<SetValueCustomRegister />}
        />
        <Route path="/formState/:mode" element={<FormState />} />
        <Route
          path="/formStateWithNestedFields/:mode"
          element={<FormStateWithNestedFields />}
        />
        <Route
          path="/formStateWithSchema/:mode"
          element={<FormStateWithSchema />}
        />
        <Route path="/isValid/:mode/:defaultValues" element={<IsValid />} />
        <Route path="/default-values" element={<DefaultValues />} />
        <Route path="/default-values-async" element={<DefaultValuesAsync />} />
        <Route path="/trigger-validation" element={<TriggerValidation />} />
        <Route path="/watch-default-values" element={<WatchDefaultValues />} />
        <Route path="/watch-field-array/:mode" element={<WatchFieldArray />} />
        <Route
          path="/customSchemaValidation/:mode"
          element={<CustomSchemaValidation />}
        />
        <Route path="/autoUnregister" element={<AutoUnregister />} />
        <Route path="/useWatch" element={<UseWatch />} />
        <Route path="/useFormState" element={<UseFormState />} />
        <Route path="/useFieldArrayNested" element={<UseFieldArrayNested />} />
        <Route
          path="/watchUseFieldArrayNested"
          element={<WatchUseFieldArrayNested />}
        />
        <Route
          path="/useWatchUseFieldArrayNested"
          element={<UseWatchUseFieldArrayNested />}
        />
        <Route path="/test" element={<Test />} />
        <Route path="/" element={<Welcome />} />
        <Route path="/form" element={<FormComponent />} />
        <Route path="/disabled" element={<DisabledFields />} />
      </Routes>
    </BrowserRouter>
  );
};

export default App;


================================================
File: /app/src/setValue.tsx
================================================
import React, { useEffect } from 'react';
import { useForm, NestedValue } from 'react-hook-form';

let renderCounter = 0;

const SetValue: React.FC = () => {
  const {
    register,
    setValue,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
    age: string;
    trigger: string;
    checkbox: boolean;
    checkboxArray: string[];
    radio: string;
    select: string;
    multiple: NestedValue<string[]>;
    array: string[];
    object: {
      firstName: string;
      lastName: string;
      middleName: string;
    };
    nestedValue: NestedValue<string[]>;
  }>();

  useEffect(() => {
    register('lastName', { required: true });
    setValue('firstName', 'wrong', { shouldDirty: true });
    setValue('age', '2', { shouldDirty: true });
    setValue('trigger', '', { shouldDirty: true, shouldValidate: true });
    setValue('checkbox', true, { shouldDirty: true });
    setValue('checkboxArray', ['2', '3'], {
      shouldDirty: true,
      shouldValidate: true,
    });
    setValue('radio', 'radio', { shouldDirty: true });
    setValue('select', 'a', { shouldDirty: true });
    setValue('multiple', ['a', 'b'], { shouldDirty: true });
    setValue('array', ['array.0', 'array.1', 'array.2'], {
      shouldDirty: true,
    });
    setValue(
      'object',
      {
        firstName: 'firstName',
        lastName: 'lastName',
        middleName: 'middleName',
      },
      { shouldDirty: true },
    );
    setValue('nestedValue', [], {
      shouldValidate: true,
      shouldDirty: true,
    });
  }, [register, setValue]);

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(() => {})}>
      <input {...register('firstName')} placeholder="firstName" />
      <input {...register('array.0')} placeholder="array[0]" />
      <input {...register('array.1')} placeholder="array[1]" />
      <input {...register('array.2')} placeholder="array[2]" />
      <input {...register('object.firstName')} placeholder="object.firstName" />
      <input {...register('object.lastName')} placeholder="object.lastName" />
      <input
        {...register('object.middleName')}
        placeholder="object.middleName"
      />
      <input type="number" {...register('age')} placeholder="age" />
      <input value="radio" type="radio" {...register('radio')} />
      <input type="checkbox" {...register('checkbox')} />
      <input type="checkbox" value="1" {...register('checkboxArray')} />
      <input type="checkbox" value="2" {...register('checkboxArray')} />
      <input type="checkbox" value="3" {...register('checkboxArray')} />
      <select {...register('select')}>
        <option>Select</option>
        <option value="a">a</option>
        <option value="b">b</option>
      </select>
      <select multiple {...register('multiple')}>
        <option>Select</option>
        <option value="a">a</option>
        <option value="b">b</option>
      </select>

      <input
        name="lastName"
        placeholder="lastName"
        onChange={() => {
          setValue('lastName', 'test');
        }}
      />
      {errors.lastName && <p id="lastName">Last name error</p>}

      <input
        {...register('trigger', { required: true })}
        placeholder="trigger"
      />
      {errors.trigger && <p id="trigger">Trigger error</p>}

      <input
        {...register('nestedValue', { required: 'required' })}
        placeholder="nestedValue"
      />
      {errors.nestedValue && (
        <p id="nestedValue">{errors.nestedValue.message}</p>
      )}

      <button
        type="button"
        id="setMultipleValues"
        onClick={() => {
          setValue(
            'object',
            {
              firstName: 'firstName1',
              lastName: 'lastName1',
              middleName: 'middleName1',
            },
            { shouldDirty: true },
          );
          setValue('array', ['array[0]1', 'array[1]1', 'array[2]1'], {
            shouldDirty: true,
          });
          setValue('nestedValue', ['a', 'b'], { shouldDirty: true });
        }}
      >
        Set Multiple Values
      </button>

      <button id="submit">Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default SetValue;


================================================
File: /app/src/watchUseFieldArray.tsx
================================================
import React from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { useParams } from 'react-router-dom';

let renderCount = 0;

type FormInputs = {
  data: { name: string }[];
};

const WatchUseFieldArray: React.FC = () => {
  const { mode } = useParams();
  const { control, handleSubmit, reset, watch, register } = useForm<FormInputs>(
    {
      ...(mode === 'default'
        ? {
            defaultValues: {
              data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
            },
          }
        : {}),
      mode: mode === 'formState' ? 'onChange' : 'onSubmit',
    },
  );
  const { fields, append, prepend, swap, move, insert, remove, update } =
    useFieldArray({
      control,
      name: 'data',
    });
  const onSubmit = () => {};
  const watchAll = watch('data') || [];

  React.useEffect(() => {
    setTimeout(() => {
      if (mode === 'asyncReset') {
        reset({
          data: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],
        });
      }
    }, 10);
  }, [reset, mode]);

  renderCount++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <ul>
        {fields.map((data, index) => (
          <li key={data.id}>
            <input
              id={`field${index}`}
              data-order={index}
              {...register(`data.${index}.name` as const)}
            />
            <button id={`delete${index}`} onClick={() => remove(index)}>
              Delete
            </button>
          </li>
        ))}
      </ul>

      <button
        id="append"
        type="button"
        onClick={() => append({ name: renderCount.toString() })}
      >
        append
      </button>

      <button
        id="prepend"
        type="button"
        onClick={() => prepend({ name: renderCount.toString() })}
      >
        prepend
      </button>

      <button
        id="update"
        type="button"
        onClick={() => update(3, { name: 'updated value' })}
      >
        append
      </button>

      <button id="swap" onClick={() => swap(1, 2)} type="button">
        swap
      </button>

      <button id="move" onClick={() => move(2, 0)} type="button">
        move
      </button>

      <button
        id="insert"
        type="button"
        onClick={() => insert(1, { name: renderCount.toString() })}
      >
        insert
      </button>

      <button id="remove" type="button" onClick={() => remove(1)}>
        remove
      </button>

      <button id="removeAll" type="button" onClick={() => remove()}>
        remove all
      </button>

      <div id="renderCount">{renderCount}</div>
      <div id="result">{JSON.stringify(watchAll)}</div>
    </form>
  );
};

export default WatchUseFieldArray;


================================================
File: /app/src/customSchemaValidation.tsx
================================================
import React from 'react';
import { useForm, ValidationMode } from 'react-hook-form';
import Joi from 'joi';
import { useParams } from 'react-router-dom';

let renderCounter = 0;

const validationSchema = Joi.object({
  firstName: Joi.string().required(),
  lastName: Joi.string().max(5).required(),
  min: Joi.number().min(10).required(),
  max: Joi.number().max(20).required(),
  minDate: Joi.date().min('2019-08-01'),
  maxDate: Joi.date().max('2019-08-01'),
  minLength: Joi.string().min(2),
  minRequiredLength: Joi.string().required(),
  selectNumber: Joi.string().required(),
  pattern: Joi.string().required(),
  radio: Joi.string().required(),
  checkbox: Joi.required(),
});

const resolver = async (data: unknown) => {
  const { error, value: values } = validationSchema.validate(data, {
    abortEarly: false,
  });

  return {
    values: error ? {} : values,
    errors: error
      ? error.details.reduce((previous, { message, type, path }) => {
          return {
            ...previous,
            [path[0]]: {
              message,
              type,
            },
          };
        }, {})
      : {},
  };
};

const BasicSchemaValidation: React.FC = () => {
  const { mode } = useParams();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<{
    firstName: string;
    lastName: string;
    min: string;
    max: string;
    minDate: string;
    maxDate: string;
    minLength: string;
    minRequiredLength: string;
    selectNumber: string;
    pattern: string;
    radio: string;
    checkbox: string;
    multiple: string;
    validate: string;
  }>({
    resolver,
    mode: mode as keyof ValidationMode,
  });
  const onSubmit = () => {};

  renderCounter++;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName')} placeholder="firstName" />
      {errors.firstName && <p>firstName error</p>}
      <input {...register('lastName')} placeholder="lastName" />
      {errors.lastName && <p>lastName error</p>}
      <input type="number" {...register('min')} placeholder="min" />
      {errors.min && <p>min error</p>}
      <input type="number" {...register('max')} placeholder="max" />
      {errors.max && <p>max error</p>}
      <input type="date" {...register('minDate')} placeholder="minDate" />
      {errors.minDate && <p>minDate error</p>}
      <input type="date" {...register('maxDate')} placeholder="maxDate" />
      {errors.maxDate && <p>maxDate error</p>}
      <input {...register('minLength')} placeholder="minLength" />
      {errors.minLength && <p>minLength error</p>}
      <input
        {...register('minRequiredLength')}
        placeholder="minRequiredLength"
      />
      {errors.minRequiredLength && <p>minRequiredLength error</p>}
      <select {...register('selectNumber')}>
        <option value="">Select</option>
        <option value={1}>1</option>
        <option value={2}>1</option>
      </select>
      {errors.selectNumber && <p>selectNumber error</p>}
      <input {...register('pattern')} placeholder="pattern" />
      {errors.pattern && <p>pattern error</p>}
      Radio1
      <input type="radio" {...register('radio')} value="1" />
      Radio2
      <input type="radio" {...register('radio')} value="2" />
      Radio3
      <input type="radio" {...register('radio')} value="3" />
      {errors.radio && <p>radio error</p>}
      <input type="checkbox" {...register('checkbox')} />
      {errors.checkbox && <p>checkbox error</p>}
      <button>Submit</button>
      <div id="renderCount">{renderCounter}</div>
    </form>
  );
};

export default BasicSchemaValidation;


================================================
File: /src/useFormState.ts
================================================
import React from 'react';

import getProxyFormState from './logic/getProxyFormState';
import shouldRenderFormState from './logic/shouldRenderFormState';
import shouldSubscribeByName from './logic/shouldSubscribeByName';
import {
  FieldValues,
  FormState,
  InternalFieldName,
  UseFormStateProps,
  UseFormStateReturn,
} from './types';
import { useFormContext } from './useFormContext';
import { useSubscribe } from './useSubscribe';

/**
 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)
 *
 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, control } = useForm({
 *     defaultValues: {
 *     firstName: "firstName"
 *   }});
 *   const { dirtyFields } = useFormState({
 *     control
 *   });
 *   const onSubmit = (data) => console.log(data);
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input {...register("firstName")} placeholder="First Name" />
 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFormState<TFieldValues extends FieldValues = FieldValues>(
  props?: UseFormStateProps<TFieldValues>,
): UseFormStateReturn<TFieldValues> {
  const methods = useFormContext<TFieldValues>();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false,
  });
  const _name = React.useRef(name);

  _name.current = name;

  useSubscribe({
    disabled,
    next: (
      value: Partial<FormState<TFieldValues>> & { name?: InternalFieldName },
    ) =>
      _mounted.current &&
      shouldSubscribeByName(
        _name.current as InternalFieldName,
        value.name,
        exact,
      ) &&
      shouldRenderFormState(
        value,
        _localProxyFormState.current,
        control._updateFormState,
      ) &&
      updateFormState({
        ...control._formState,
        ...value,
      }),
    subject: control._subjects.state,
  });

  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);

    return () => {
      _mounted.current = false;
    };
  }, [control]);

  return React.useMemo(
    () =>
      getProxyFormState(
        formState,
        control,
        _localProxyFormState.current,
        false,
      ),
    [formState, control],
  );
}

export { useFormState };


================================================
File: /src/logic/getFieldValueAs.ts
================================================
import { Field, NativeFieldValue } from '../types';
import isString from '../utils/isString';
import isUndefined from '../utils/isUndefined';

export default <T extends NativeFieldValue>(
  value: T,
  { valueAsNumber, valueAsDate, setValueAs }: Field['_f'],
) =>
  isUndefined(value)
    ? value
    : valueAsNumber
      ? value === ''
        ? NaN
        : value
          ? +value
          : value
      : valueAsDate && isString(value)
        ? new Date(value)
        : setValueAs
          ? setValueAs(value)
          : value;


================================================
File: /src/logic/getFieldValue.ts
================================================
import { Field } from '../types';
import isCheckBox from '../utils/isCheckBoxInput';
import isFileInput from '../utils/isFileInput';
import isMultipleSelect from '../utils/isMultipleSelect';
import isRadioInput from '../utils/isRadioInput';
import isUndefined from '../utils/isUndefined';

import getCheckboxValue from './getCheckboxValue';
import getFieldValueAs from './getFieldValueAs';
import getRadioValue from './getRadioValue';

export default function getFieldValue(_f: Field['_f']) {
  const ref = _f.ref;

  if (_f.refs ? _f.refs.every((ref) => ref.disabled) : ref.disabled) {
    return;
  }

  if (isFileInput(ref)) {
    return ref.files;
  }

  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }

  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }

  if (isCheckBox(ref)) {
    return getCheckboxValue(_f.refs).value;
  }

  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}


================================================
File: /src/logic/getDirtyFields.ts
================================================
import deepEqual from '../utils/deepEqual';
import isNullOrUndefined from '../utils/isNullOrUndefined';
import isObject from '../utils/isObject';
import isPrimitive from '../utils/isPrimitive';
import isUndefined from '../utils/isUndefined';
import objectHasFunction from '../utils/objectHasFunction';

function markFieldsDirty<T>(data: T, fields: Record<string, any> = {}) {
  const isParentNodeArray = Array.isArray(data);

  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (
        Array.isArray(data[key]) ||
        (isObject(data[key]) && !objectHasFunction(data[key]))
      ) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }

  return fields;
}

function getDirtyFieldsFromDefaultValues<T>(
  data: T,
  formValues: T,
  dirtyFieldsFromValues: Record<
    Extract<keyof T, string>,
    ReturnType<typeof markFieldsDirty> | boolean
  >,
) {
  const isParentNodeArray = Array.isArray(data);

  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (
        Array.isArray(data[key]) ||
        (isObject(data[key]) && !objectHasFunction(data[key]))
      ) {
        if (
          isUndefined(formValues) ||
          isPrimitive(dirtyFieldsFromValues[key])
        ) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key])
            ? markFieldsDirty(data[key], [])
            : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(
            data[key],
            isNullOrUndefined(formValues) ? {} : formValues[key],
            dirtyFieldsFromValues[key],
          );
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }

  return dirtyFieldsFromValues;
}

export default <T>(defaultValues: T, formValues: T) =>
  getDirtyFieldsFromDefaultValues(
    defaultValues,
    formValues,
    markFieldsDirty(formValues),
  );


================================================
File: /src/logic/validateField.ts
================================================
import { INPUT_VALIDATION_RULES } from '../constants';
import {
  Field,
  FieldError,
  FieldValues,
  InternalFieldErrors,
  MaxType,
  Message,
  MinType,
  NativeFieldValue,
} from '../types';
import get from '../utils/get';
import isBoolean from '../utils/isBoolean';
import isCheckBoxInput from '../utils/isCheckBoxInput';
import isEmptyObject from '../utils/isEmptyObject';
import isFileInput from '../utils/isFileInput';
import isFunction from '../utils/isFunction';
import isHTMLElement from '../utils/isHTMLElement';
import isMessage from '../utils/isMessage';
import isNullOrUndefined from '../utils/isNullOrUndefined';
import isObject from '../utils/isObject';
import isRadioInput from '../utils/isRadioInput';
import isRegex from '../utils/isRegex';
import isString from '../utils/isString';
import isUndefined from '../utils/isUndefined';

import appendErrors from './appendErrors';
import getCheckboxValue from './getCheckboxValue';
import getRadioValue from './getRadioValue';
import getValidateError from './getValidateError';
import getValueAndMessage from './getValueAndMessage';

export default async <T extends FieldValues>(
  field: Field,
  formValues: T,
  validateAllFieldCriteria: boolean,
  shouldUseNativeValidation?: boolean,
  isFieldArray?: boolean,
): Promise<InternalFieldErrors> => {
  const {
    ref,
    refs,
    required,
    maxLength,
    minLength,
    min,
    max,
    pattern,
    validate,
    name,
    valueAsNumber,
    mount,
    disabled,
  } = field._f;
  const inputValue: NativeFieldValue = get(formValues, name);
  if (!mount || disabled) {
    return {};
  }
  const inputRef: HTMLInputElement = refs ? refs[0] : (ref as HTMLInputElement);
  const setCustomValidity = (message?: string | boolean) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
      inputRef.reportValidity();
    }
  };
  const error: InternalFieldErrors = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox = isRadio || isCheckBox;
  const isEmpty =
    ((valueAsNumber || isFileInput(ref)) &&
      isUndefined(ref.value) &&
      isUndefined(inputValue)) ||
    (isHTMLElement(ref) && ref.value === '') ||
    inputValue === '' ||
    (Array.isArray(inputValue) && !inputValue.length);
  const appendErrorsCurry = appendErrors.bind(
    null,
    name,
    validateAllFieldCriteria,
    error,
  );
  const getMinMaxMessage = (
    exceedMax: boolean,
    maxLengthMessage: Message,
    minLengthMessage: Message,
    maxType: MaxType = INPUT_VALIDATION_RULES.maxLength,
    minType: MinType = INPUT_VALIDATION_RULES.minLength,
  ) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message),
    };
  };

  if (
    isFieldArray
      ? !Array.isArray(inputValue) || !inputValue.length
      : required &&
        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||
          (isBoolean(inputValue) && !inputValue) ||
          (isCheckBox && !getCheckboxValue(refs).isValid) ||
          (isRadio && !getRadioValue(refs).isValid))
  ) {
    const { value, message } = isMessage(required)
      ? { value: !!required, message: required }
      : getValueAndMessage(required);

    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }

  if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max);
    const minOutput = getValueAndMessage(min);

    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue as number)) {
      const valueNumber =
        (ref as HTMLInputElement).valueAsNumber ||
        (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate =
        (ref as HTMLInputElement).valueAsDate || new Date(inputValue as string);
      const convertTimeToDate = (time: unknown) =>
        new Date(new Date().toDateString() + ' ' + time);
      const isTime = ref.type == 'time';
      const isWeek = ref.type == 'week';

      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime
          ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)
          : isWeek
            ? inputValue > maxOutput.value
            : valueDate > new Date(maxOutput.value);
      }

      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime
          ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)
          : isWeek
            ? inputValue < minOutput.value
            : valueDate < new Date(minOutput.value);
      }
    }

    if (exceedMax || exceedMin) {
      getMinMaxMessage(
        !!exceedMax,
        maxOutput.message,
        minOutput.message,
        INPUT_VALIDATION_RULES.max,
        INPUT_VALIDATION_RULES.min,
      );
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name]!.message);
        return error;
      }
    }
  }

  if (
    (maxLength || minLength) &&
    !isEmpty &&
    (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))
  ) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax =
      !isNullOrUndefined(maxLengthOutput.value) &&
      inputValue.length > +maxLengthOutput.value;
    const exceedMin =
      !isNullOrUndefined(minLengthOutput.value) &&
      inputValue.length < +minLengthOutput.value;

    if (exceedMax || exceedMin) {
      getMinMaxMessage(
        exceedMax,
        maxLengthOutput.message,
        minLengthOutput.message,
      );
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name]!.message);
        return error;
      }
    }
  }

  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);

    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }

  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);

      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(
            INPUT_VALIDATION_RULES.validate,
            validateError.message,
          ),
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {} as FieldError;

      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }

        const validateError = getValidateError(
          await validate[key](inputValue, formValues),
          inputRef,
          key,
        );

        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message),
          };

          setCustomValidity(validateError.message);

          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }

      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult,
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }

  setCustomValidity(true);
  return error;
};


================================================
File: /src/logic/iterateFieldsByAction.ts
================================================
import { FieldRefs, InternalFieldName, Ref } from '../types';
import { get } from '../utils';
import isObject from '../utils/isObject';

const iterateFieldsByAction = (
  fields: FieldRefs,
  action: (ref: Ref, name: string) => 1 | undefined | void,
  fieldsNames?: Set<InternalFieldName> | InternalFieldName[] | 0,
  abortEarly?: boolean,
) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);

    if (field) {
      const { _f, ...currentField } = field;

      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField as FieldRefs, action)) {
          break;
        }
      }
    }
  }
  return;
};
export default iterateFieldsByAction;


================================================
File: /src/logic/getEventValue.ts
================================================
import isCheckBoxInput from '../utils/isCheckBoxInput';
import isObject from '../utils/isObject';

type Event = { target: any };

export default (event: unknown) =>
  isObject(event) && (event as Event).target
    ? isCheckBoxInput((event as Event).target)
      ? (event as Event).target.checked
      : (event as Event).target.value
    : event;


================================================
File: /src/logic/getCheckboxValue.ts
================================================
import isUndefined from '../utils/isUndefined';

type CheckboxFieldResult = {
  isValid: boolean;
  value: string | string[] | boolean | undefined;
};

const defaultResult: CheckboxFieldResult = {
  value: false,
  isValid: false,
};

const validResult = { value: true, isValid: true };

export default (options?: HTMLInputElement[]): CheckboxFieldResult => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options
        .filter((option) => option && option.checked && !option.disabled)
        .map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }

    return options[0].checked && !options[0].disabled
      ? // @ts-expect-error expected to work in the browser
        options[0].attributes && !isUndefined(options[0].attributes.value)
        ? isUndefined(options[0].value) || options[0].value === ''
          ? validResult
          : { value: options[0].value, isValid: true }
        : validResult
      : defaultResult;
  }

  return defaultResult;
};


================================================
File: /src/logic/getFocusFieldName.ts
================================================
import { FieldArrayMethodProps, InternalFieldName } from '../types';
import isUndefined from '../utils/isUndefined';

export default (
  name: InternalFieldName,
  index: number,
  options: FieldArrayMethodProps = {},
): string =>
  options.shouldFocus || isUndefined(options.shouldFocus)
    ? options.focusName ||
      `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.`
    : '';


================================================
File: /src/logic/getNodeParentName.ts
================================================
export default (name: string) =>
  name.substring(0, name.search(/\.\d+(\.|$)/)) || name;


================================================
File: /src/logic/getRadioValue.ts
================================================
type RadioFieldResult = {
  isValid: boolean;
  value: number | string | null;
};

const defaultReturn: RadioFieldResult = {
  isValid: false,
  value: null,
};

export default (options?: HTMLInputElement[]): RadioFieldResult =>
  Array.isArray(options)
    ? options.reduce(
        (previous, option): RadioFieldResult =>
          option && option.checked && !option.disabled
            ? {
                isValid: true,
                value: option.value,
              }
            : previous,
        defaultReturn,
      )
    : defaultReturn;


================================================
File: /src/logic/shouldRenderFormState.ts
================================================
import { VALIDATION_MODE } from '../constants';
import {
  Control,
  FieldValues,
  FormState,
  InternalFieldName,
  ReadFormState,
} from '../types';
import isEmptyObject from '../utils/isEmptyObject';

export default <T extends FieldValues, K extends ReadFormState>(
  formStateData: Partial<FormState<T>> & { name?: InternalFieldName },
  _proxyFormState: K,
  updateFormState: Control<T>['_updateFormState'],
  isRoot?: boolean,
) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;

  return (
    isEmptyObject(formState) ||
    Object.keys(formState).length >= Object.keys(_proxyFormState).length ||
    Object.keys(formState).find(
      (key) =>
        _proxyFormState[key as keyof ReadFormState] ===
        (!isRoot || VALIDATION_MODE.all),
    )
  );
};


================================================
File: /src/logic/schemaErrorLookup.ts
================================================
import { FieldError, FieldErrors, FieldValues } from '../types';
import get from '../utils/get';
import isKey from '../utils/isKey';

export default function schemaErrorLookup<T extends FieldValues = FieldValues>(
  errors: FieldErrors<T>,
  _fields: FieldValues,
  name: string,
): {
  error?: FieldError;
  name: string;
} {
  const error = get(errors, name);

  if (error || isKey(name)) {
    return {
      error,
      name,
    };
  }

  const names = name.split('.');

  while (names.length) {
    const fieldName = names.join('.');
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);

    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }

    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError,
      };
    }

    names.pop();
  }

  return {
    name,
  };
}


================================================
File: /src/logic/createFormControl.ts
================================================
import { EVENTS, VALIDATION_MODE } from '../constants';
import {
  BatchFieldArrayUpdate,
  ChangeHandler,
  Control,
  DeepPartial,
  DelayCallback,
  EventType,
  Field,
  FieldError,
  FieldErrors,
  FieldNamesMarkedBoolean,
  FieldPath,
  FieldRefs,
  FieldValues,
  FormState,
  GetIsDirty,
  InternalFieldName,
  Names,
  Path,
  PathValue,
  ReadFormState,
  Ref,
  SetFieldValue,
  SetValueConfig,
  Subjects,
  UseFormClearErrors,
  UseFormGetFieldState,
  UseFormGetValues,
  UseFormHandleSubmit,
  UseFormProps,
  UseFormRegister,
  UseFormReset,
  UseFormResetField,
  UseFormReturn,
  UseFormSetError,
  UseFormSetFocus,
  UseFormSetValue,
  UseFormTrigger,
  UseFormUnregister,
  UseFormWatch,
  WatchInternal,
  WatchObserver,
} from '../types';
import cloneObject from '../utils/cloneObject';
import compact from '../utils/compact';
import convertToArrayPayload from '../utils/convertToArrayPayload';
import createSubject from '../utils/createSubject';
import deepEqual from '../utils/deepEqual';
import get from '../utils/get';
import isBoolean from '../utils/isBoolean';
import isCheckBoxInput from '../utils/isCheckBoxInput';
import isDateObject from '../utils/isDateObject';
import isEmptyObject from '../utils/isEmptyObject';
import isFileInput from '../utils/isFileInput';
import isFunction from '../utils/isFunction';
import isHTMLElement from '../utils/isHTMLElement';
import isMultipleSelect from '../utils/isMultipleSelect';
import isNullOrUndefined from '../utils/isNullOrUndefined';
import isObject from '../utils/isObject';
import isRadioOrCheckbox from '../utils/isRadioOrCheckbox';
import isString from '../utils/isString';
import isUndefined from '../utils/isUndefined';
import isWeb from '../utils/isWeb';
import live from '../utils/live';
import set from '../utils/set';
import unset from '../utils/unset';

import generateWatchOutput from './generateWatchOutput';
import getDirtyFields from './getDirtyFields';
import getEventValue from './getEventValue';
import getFieldValue from './getFieldValue';
import getFieldValueAs from './getFieldValueAs';
import getResolverOptions from './getResolverOptions';
import getRuleValue from './getRuleValue';
import getValidationModes from './getValidationModes';
import hasPromiseValidation from './hasPromiseValidation';
import hasValidation from './hasValidation';
import isNameInFieldArray from './isNameInFieldArray';
import isWatched from './isWatched';
import iterateFieldsByAction from './iterateFieldsByAction';
import schemaErrorLookup from './schemaErrorLookup';
import skipValidation from './skipValidation';
import unsetEmptyArray from './unsetEmptyArray';
import updateFieldArrayRootError from './updateFieldArrayRootError';
import validateField from './validateField';

const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true,
} as const;

export function createFormControl<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
>(
  props: UseFormProps<TFieldValues, TContext> = {},
): Omit<UseFormReturn<TFieldValues, TContext>, 'formState'> {
  let _options = {
    ...defaultOptions,
    ...props,
  };
  let _formState: FormState<TFieldValues> = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false,
  };
  let _fields: FieldRefs = {};
  let _defaultValues =
    isObject(_options.defaultValues) || isObject(_options.values)
      ? cloneObject(_options.defaultValues || _options.values) || {}
      : {};
  let _formValues = _options.shouldUnregister
    ? {}
    : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false,
  };
  let _names: Names = {
    mount: new Set(),
    unMount: new Set(),
    array: new Set(),
    watch: new Set(),
  };
  let delayErrorCallback: DelayCallback | null;
  let timer = 0;
  const _proxyFormState: ReadFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false,
  };
  const _subjects: Subjects<TFieldValues> = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject(),
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors =
    _options.criteriaMode === VALIDATION_MODE.all;

  const debounce =
    <T extends Function>(callback: T) =>
    (wait: number) => {
      clearTimeout(timer);
      timer = setTimeout(callback, wait);
    };

  const _updateValid = async (shouldUpdateValid?: boolean) => {
    if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
      const isValid = _options.resolver
        ? isEmptyObject((await _executeSchema()).errors)
        : await executeBuiltInValidation(_fields, true);

      if (isValid !== _formState.isValid) {
        _subjects.state.next({
          isValid,
        });
      }
    }
  };

  const _updateIsValidating = (names?: string[], isValidating?: boolean) => {
    if (
      !_options.disabled &&
      (_proxyFormState.isValidating || _proxyFormState.validatingFields)
    ) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating
            ? set(_formState.validatingFields, name, isValidating)
            : unset(_formState.validatingFields, name);
        }
      });

      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields),
      });
    }
  };

  const _updateFieldArray: BatchFieldArrayUpdate = (
    name,
    values = [],
    method,
    args,
    shouldSetValues = true,
    shouldUpdateFieldsAndState = true,
  ) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }

      if (
        shouldUpdateFieldsAndState &&
        Array.isArray(get(_formState.errors, name))
      ) {
        const errors = method(
          get(_formState.errors, name),
          args.argA,
          args.argB,
        );
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }

      if (
        _proxyFormState.touchedFields &&
        shouldUpdateFieldsAndState &&
        Array.isArray(get(_formState.touchedFields, name))
      ) {
        const touchedFields = method(
          get(_formState.touchedFields, name),
          args.argA,
          args.argB,
        );
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }

      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }

      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid,
      });
    } else {
      set(_formValues, name, values);
    }
  };

  const updateErrors = (name: InternalFieldName, error: FieldError) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors,
    });
  };

  const _setErrors = (errors: FieldErrors<TFieldValues>) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false,
    });
  };

  const updateValidAndValue = (
    name: InternalFieldName,
    shouldSkipSetValueAs: boolean,
    value?: unknown,
    ref?: Ref,
  ) => {
    const field: Field = get(_fields, name);

    if (field) {
      const defaultValue = get(
        _formValues,
        name,
        isUndefined(value) ? get(_defaultValues, name) : value,
      );

      isUndefined(defaultValue) ||
      (ref && (ref as HTMLInputElement).defaultChecked) ||
      shouldSkipSetValueAs
        ? set(
            _formValues,
            name,
            shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f),
          )
        : setFieldValue(name, defaultValue);

      _state.mount && _updateValid();
    }
  };

  const updateTouchAndDirty = (
    name: InternalFieldName,
    fieldValue: unknown,
    isBlurEvent?: boolean,
    shouldDirty?: boolean,
    shouldRender?: boolean,
  ): Partial<
    Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>
  > => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output: Partial<FormState<TFieldValues>> & { name: string } = {
      name,
    };

    if (!_options.disabled) {
      const disabledField = !!(
        get(_fields, name) &&
        get(_fields, name)._f &&
        get(_fields, name)._f.disabled
      );
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }

        const isCurrentFieldPristine =
          disabledField || deepEqual(get(_defaultValues, name), fieldValue);

        isPreviousDirty = !!(
          !disabledField && get(_formState.dirtyFields, name)
        );
        isCurrentFieldPristine || disabledField
          ? unset(_formState.dirtyFields, name)
          : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField =
          shouldUpdateField ||
          (_proxyFormState.dirtyFields &&
            isPreviousDirty !== !isCurrentFieldPristine);
      }

      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);

        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField =
            shouldUpdateField ||
            (_proxyFormState.touchedFields &&
              isPreviousFieldTouched !== isBlurEvent);
        }
      }

      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }

    return shouldUpdateField ? output : {};
  };

  const shouldRenderByError = (
    name: InternalFieldName,
    isValid?: boolean,
    error?: FieldError,
    fieldState?: {
      dirty?: FieldNamesMarkedBoolean<TFieldValues>;
      isDirty?: boolean;
      touched?: FieldNamesMarkedBoolean<TFieldValues>;
    },
  ) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid =
      _proxyFormState.isValid &&
      isBoolean(isValid) &&
      _formState.isValid !== isValid;

    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error
        ? set(_formState.errors, name, error)
        : unset(_formState.errors, name);
    }

    if (
      (error ? !deepEqual(previousFieldError, error) : previousFieldError) ||
      !isEmptyObject(fieldState) ||
      shouldUpdateValid
    ) {
      const updatedFormState = {
        ...fieldState,
        ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),
        errors: _formState.errors,
        name,
      };

      _formState = {
        ..._formState,
        ...updatedFormState,
      };

      _subjects.state.next(updatedFormState);
    }
  };

  const _executeSchema = async (name?: InternalFieldName[]) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver!(
      _formValues as TFieldValues,
      _options.context,
      getResolverOptions(
        name || _names.mount,
        _fields,
        _options.criteriaMode,
        _options.shouldUseNativeValidation,
      ),
    );
    _updateIsValidating(name);
    return result;
  };

  const executeSchemaAndUpdateState = async (names?: InternalFieldName[]) => {
    const { errors } = await _executeSchema(names);

    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error
          ? set(_formState.errors, name, error)
          : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }

    return errors;
  };

  const executeBuiltInValidation = async (
    fields: FieldRefs,
    shouldOnlyCheckValid?: boolean,
    context: {
      valid: boolean;
    } = {
      valid: true,
    },
  ) => {
    for (const name in fields) {
      const field = fields[name];

      if (field) {
        const { _f, ...fieldValue } = field as Field;

        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction =
            field._f && hasPromiseValidation((field as Field)._f);

          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }

          const fieldError = await validateField(
            field as Field,
            _formValues,
            shouldDisplayAllAssociatedErrors,
            _options.shouldUseNativeValidation && !shouldOnlyCheckValid,
            isFieldArrayRoot,
          );

          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }

          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }

          !shouldOnlyCheckValid &&
            (get(fieldError, _f.name)
              ? isFieldArrayRoot
                ? updateFieldArrayRootError(
                    _formState.errors,
                    fieldError,
                    _f.name,
                  )
                : set(_formState.errors, _f.name, fieldError[_f.name])
              : unset(_formState.errors, _f.name));
        }

        !isEmptyObject(fieldValue) &&
          (await executeBuiltInValidation(
            fieldValue,
            shouldOnlyCheckValid,
            context,
          ));
      }
    }

    return context.valid;
  };

  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field: Field = get(_fields, name);

      field &&
        (field._f.refs
          ? field._f.refs.every((ref) => !live(ref))
          : !live(field._f.ref)) &&
        unregister(name as FieldPath<TFieldValues>);
    }

    _names.unMount = new Set();
  };

  const _getDirty: GetIsDirty = (name, data) =>
    !_options.disabled &&
    (name && data && set(_formValues, name, data),
    !deepEqual(getValues(), _defaultValues));

  const _getWatch: WatchInternal<TFieldValues> = (
    names,
    defaultValue,
    isGlobal,
  ) =>
    generateWatchOutput(
      names,
      _names,
      {
        ...(_state.mount
          ? _formValues
          : isUndefined(defaultValue)
            ? _defaultValues
            : isString(names)
              ? { [names]: defaultValue }
              : defaultValue),
      },
      isGlobal,
      defaultValue,
    );

  const _getFieldArray = <TFieldArrayValues>(
    name: InternalFieldName,
  ): Partial<TFieldArrayValues>[] =>
    compact(
      get(
        _state.mount ? _formValues : _defaultValues,
        name,
        _options.shouldUnregister ? get(_defaultValues, name, []) : [],
      ),
    );

  const setFieldValue = (
    name: InternalFieldName,
    value: SetFieldValue<TFieldValues>,
    options: SetValueConfig = {},
  ) => {
    const field: Field = get(_fields, name);
    let fieldValue: unknown = value;

    if (field) {
      const fieldReference = field._f;

      if (fieldReference) {
        !fieldReference.disabled &&
          set(_formValues, name, getFieldValueAs(value, fieldReference));

        fieldValue =
          isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
            ? ''
            : value;

        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach(
            (optionRef) =>
              (optionRef.selected = (
                fieldValue as InternalFieldName[]
              ).includes(optionRef.value)),
          );
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1
              ? fieldReference.refs.forEach(
                  (checkboxRef) =>
                    (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&
                    (checkboxRef.checked = Array.isArray(fieldValue)
                      ? !!(fieldValue as []).find(
                          (data: string) => data === checkboxRef.value,
                        )
                      : fieldValue === checkboxRef.value),
                )
              : fieldReference.refs[0] &&
                (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach(
              (radioRef: HTMLInputElement) =>
                (radioRef.checked = radioRef.value === fieldValue),
            );
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = '';
        } else {
          fieldReference.ref.value = fieldValue;

          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues },
            });
          }
        }
      }
    }

    (options.shouldDirty || options.shouldTouch) &&
      updateTouchAndDirty(
        name,
        fieldValue,
        options.shouldTouch,
        options.shouldDirty,
        true,
      );

    options.shouldValidate && trigger(name as Path<TFieldValues>);
  };

  const setValues = <
    T extends InternalFieldName,
    K extends SetFieldValue<TFieldValues>,
    U extends SetValueConfig,
  >(
    name: T,
    value: K,
    options: U,
  ) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);

      (_names.array.has(name) ||
        isObject(fieldValue) ||
        (field && !field._f)) &&
      !isDateObject(fieldValue)
        ? setValues(fieldName, fieldValue, options)
        : setFieldValue(fieldName, fieldValue, options);
    }
  };

  const setValue: UseFormSetValue<TFieldValues> = (
    name,
    value,
    options = {},
  ) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);

    set(_formValues, name, cloneValue);

    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues },
      });

      if (
        (_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&
        options.shouldDirty
      ) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue),
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue)
        ? setValues(name, cloneValue, options)
        : setFieldValue(name, cloneValue, options);
    }

    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : undefined,
      values: { ..._formValues },
    });
  };

  const onChange: ChangeHandler = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name as string;
    let isFieldValueUpdated = true;
    const field: Field = get(_fields, name);
    const getCurrentFieldValue = () =>
      target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue: any): void => {
      isFieldValueUpdated =
        Number.isNaN(fieldValue) ||
        (isDateObject(fieldValue) && isNaN(fieldValue.getTime())) ||
        deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };

    if (field) {
      let error;
      let isValid;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent =
        event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation =
        (!hasValidation(field._f) &&
          !_options.resolver &&
          !get(_formState.errors, name) &&
          !field._f.deps) ||
        skipValidation(
          isBlurEvent,
          get(_formState.touchedFields, name),
          _formState.isSubmitted,
          validationModeAfterSubmit,
          validationModeBeforeSubmit,
        );
      const watched = isWatched(name, _names, isBlurEvent);

      set(_formValues, name, fieldValue);

      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }

      const fieldState = updateTouchAndDirty(
        name,
        fieldValue,
        isBlurEvent,
        false,
      );

      const shouldRender = !isEmptyObject(fieldState) || watched;

      !isBlurEvent &&
        _subjects.values.next({
          name,
          type: event.type,
          values: { ..._formValues },
        });

      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (_options.mode === 'onBlur' && isBlurEvent) {
            _updateValid();
          } else if (!isBlurEvent) {
            _updateValid();
          }
        }

        return (
          shouldRender &&
          _subjects.state.next({ name, ...(watched ? {} : fieldState) })
        );
      }

      !isBlurEvent && watched && _subjects.state.next({ ..._formState });

      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);

        _updateIsFieldValueUpdated(fieldValue);

        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(
            _formState.errors,
            _fields,
            name,
          );
          const errorLookupResult = schemaErrorLookup(
            errors,
            _fields,
            previousErrorLookupResult.name || name,
          );

          error = errorLookupResult.error;
          name = errorLookupResult.name;

          isValid = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (
          await validateField(
            field,
            _formValues,
            shouldDisplayAllAssociatedErrors,
            _options.shouldUseNativeValidation,
          )
        )[name];
        _updateIsValidating([name]);

        _updateIsFieldValueUpdated(fieldValue);

        if (isFieldValueUpdated) {
          if (error) {
            isValid = false;
          } else if (_proxyFormState.isValid) {
            isValid = await executeBuiltInValidation(_fields, true);
          }
        }
      }

      if (isFieldValueUpdated) {
        field._f.deps &&
          trigger(
            field._f.deps as
              | FieldPath<TFieldValues>
              | FieldPath<TFieldValues>[],
          );
        shouldRenderByError(name, isValid, error, fieldState);
      }
    }
  };

  const _focusInput = (ref: Ref, key: string) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };

  const trigger: UseFormTrigger<TFieldValues> = async (name, options = {}) => {
    let isValid;
    let validationResult;
    const fieldNames = convertToArrayPayload(name) as InternalFieldName[];

    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(
        isUndefined(name) ? name : fieldNames,
      );

      isValid = isEmptyObject(errors);
      validationResult = name
        ? !fieldNames.some((name) => get(errors, name))
        : isValid;
    } else if (name) {
      validationResult = (
        await Promise.all(
          fieldNames.map(async (fieldName) => {
            const field = get(_fields, fieldName);
            return await executeBuiltInValidation(
              field && field._f ? { [fieldName]: field } : field,
            );
          }),
        )
      ).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid = await executeBuiltInValidation(_fields);
    }

    _subjects.state.next({
      ...(!isString(name) ||
      (_proxyFormState.isValid && isValid !== _formState.isValid)
        ? {}
        : { name }),
      ...(_options.resolver || !name ? { isValid } : {}),
      errors: _formState.errors,
    });

    options.shouldFocus &&
      !validationResult &&
      iterateFieldsByAction(
        _fields,
        _focusInput,
        name ? fieldNames : _names.mount,
      );

    return validationResult;
  };

  const getValues: UseFormGetValues<TFieldValues> = (
    fieldNames?:
      | FieldPath<TFieldValues>
      | ReadonlyArray<FieldPath<TFieldValues>>,
  ) => {
    const values = {
      ...(_state.mount ? _formValues : _defaultValues),
    };

    return isUndefined(fieldNames)
      ? values
      : isString(fieldNames)
        ? get(values, fieldNames)
        : fieldNames.map((name) => get(values, name));
  };

  const getFieldState: UseFormGetFieldState<TFieldValues> = (
    name,
    formState,
  ) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name),
  });

  const clearErrors: UseFormClearErrors<TFieldValues> = (name) => {
    name &&
      convertToArrayPayload(name).forEach((inputName) =>
        unset(_formState.errors, inputName),
      );

    _subjects.state.next({
      errors: name ? _formState.errors : {},
    });
  };

  const setError: UseFormSetError<TFieldValues> = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};

    // Don't override existing error messages elsewhere in the object tree.
    const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;

    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref,
    });

    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false,
    });

    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };

  const watch: UseFormWatch<TFieldValues> = (
    name?:
      | FieldPath<TFieldValues>
      | ReadonlyArray<FieldPath<TFieldValues>>
      | WatchObserver<TFieldValues>,
    defaultValue?: DeepPartial<TFieldValues>,
  ) =>
    isFunction(name)
      ? _subjects.values.subscribe({
          next: (payload) =>
            name(
              _getWatch(undefined, defaultValue),
              payload as {
                name?: FieldPath<TFieldValues>;
                type?: EventType;
                value?: unknown;
              },
            ),
        })
      : _getWatch(
          name as InternalFieldName | InternalFieldName[],
          defaultValue,
          true,
        );

  const unregister: UseFormUnregister<TFieldValues> = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);

      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }

      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating &&
        unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister &&
        !options.keepDefaultValue &&
        unset(_defaultValues, fieldName);
    }

    _subjects.values.next({
      values: { ..._formValues },
    });

    _subjects.state.next({
      ..._formState,
      ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),
    });

    !options.keepIsValid && _updateValid();
  };

  const _updateDisabledField: Control<TFieldValues>['_updateDisabledField'] = ({
    disabled,
    name,
    field,
    fields,
    value,
  }) => {
    if ((isBoolean(disabled) && _state.mount) || !!disabled) {
      const inputValue = disabled
        ? undefined
        : isUndefined(value)
          ? getFieldValue(field ? field._f : get(fields, name)._f)
          : value;
      if (disabled || (!disabled && !isUndefined(inputValue))) {
        set(_formValues, name, inputValue);
      }
      updateTouchAndDirty(name, inputValue, false, false, true);
    }
  };

  const register: UseFormRegister<TFieldValues> = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined =
      isBoolean(options.disabled) || isBoolean(_options.disabled);

    set(_fields, name, {
      ...(field || {}),
      _f: {
        ...(field && field._f ? field._f : { ref: { name } }),
        name,
        mount: true,
        ...options,
      },
    });
    _names.mount.add(name);

    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled)
          ? options.disabled
          : _options.disabled,
        name,
        value: options.value,
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }

    return {
      ...(disabledIsDefined
        ? { disabled: options.disabled || _options.disabled }
        : {}),
      ...(_options.progressive
        ? {
            required: !!options.required,
            min: getRuleValue(options.min),
            max: getRuleValue(options.max),
            minLength: getRuleValue<number>(options.minLength) as number,
            maxLength: getRuleValue(options.maxLength) as number,
            pattern: getRuleValue(options.pattern) as string,
          }
        : {}),
      name,
      onChange,
      onBlur: onChange,
      ref: (ref: HTMLInputElement | null): void => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);

          const fieldRef = isUndefined(ref.value)
            ? ref.querySelectorAll
              ? (ref.querySelectorAll('input,select,textarea')[0] as Ref) || ref
              : ref
            : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];

          if (
            radioOrCheckbox
              ? refs.find((option: Ref) => option === fieldRef)
              : fieldRef === field._f.ref
          ) {
            return;
          }

          set(_fields, name, {
            _f: {
              ...field._f,
              ...(radioOrCheckbox
                ? {
                    refs: [
                      ...refs.filter(live),
                      fieldRef,
                      ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),
                    ],
                    ref: { type: fieldRef.type, name },
                  }
                : { ref: fieldRef }),
            },
          });

          updateValidAndValue(name, false, undefined, fieldRef);
        } else {
          field = get(_fields, name, {});

          if (field._f) {
            field._f.mount = false;
          }

          (_options.shouldUnregister || options.shouldUnregister) &&
            !(isNameInFieldArray(_names.array, name) && _state.action) &&
            _names.unMount.add(name);
        }
      },
    };
  };

  const _focusError = () =>
    _options.shouldFocusError &&
    iterateFieldsByAction(_fields, _focusInput, _names.mount);

  const _disableForm = (disabled?: boolean) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(
        _fields,
        (ref, name) => {
          const currentField: Field = get(_fields, name);
          if (currentField) {
            ref.disabled = currentField._f.disabled || disabled;

            if (Array.isArray(currentField._f.refs)) {
              currentField._f.refs.forEach((inputRef) => {
                inputRef.disabled = currentField._f.disabled || disabled;
              });
            }
          }
        },
        0,
        false,
      );
    }
  };

  const handleSubmit: UseFormHandleSubmit<TFieldValues> =
    (onValid, onInvalid) => async (e) => {
      let onValidError = undefined;
      if (e) {
        e.preventDefault && e.preventDefault();
        e.persist && e.persist();
      }

      if (_options.disabled) {
        if (onInvalid) {
          await onInvalid({ ..._formState.errors }, e);
        }
        return;
      }

      let fieldValues = cloneObject(_formValues);

      _subjects.state.next({
        isSubmitting: true,
      });

      if (_options.resolver) {
        const { errors, values } = await _executeSchema();
        _formState.errors = errors;
        fieldValues = values;
      } else {
        await executeBuiltInValidation(_fields);
      }

      unset(_formState.errors, 'root');

      if (isEmptyObject(_formState.errors)) {
        _subjects.state.next({
          errors: {},
        });
        try {
          await onValid(fieldValues as TFieldValues, e);
        } catch (error) {
          onValidError = error;
        }
      } else {
        if (onInvalid) {
          await onInvalid({ ..._formState.errors }, e);
        }
        _focusError();
        setTimeout(_focusError);
      }

      _subjects.state.next({
        isSubmitted: true,
        isSubmitting: false,
        isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
        submitCount: _formState.submitCount + 1,
        errors: _formState.errors,
      });
      if (onValidError) {
        throw onValidError;
      }
    };

  const resetField: UseFormResetField<TFieldValues> = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(
          name,
          options.defaultValue as PathValue<
            TFieldValues,
            FieldPath<TFieldValues>
          >,
        );
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }

      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }

      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue
          ? _getDirty(name, cloneObject(get(_defaultValues, name)))
          : _getDirty();
      }

      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }

      _subjects.state.next({ ..._formState });
    }
  };

  const _reset: UseFormReset<TFieldValues> = (
    formValues,
    keepStateOptions = {},
  ) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;

    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }

    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues)),
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName)
            ? set(values, fieldName, get(_formValues, fieldName))
            : setValue(
                fieldName as FieldPath<TFieldValues>,
                get(values, fieldName),
              );
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs)
                ? field._f.refs[0]
                : field._f.ref;

              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest('form');
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }

        _fields = {};
      }

      _formValues = _options.shouldUnregister
        ? keepStateOptions.keepDefaultValues
          ? cloneObject(_defaultValues)
          : {}
        : cloneObject(values);

      _subjects.array.next({
        values: { ...values },
      });

      _subjects.values.next({
        values: { ...values },
      });
    }

    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
      unMount: new Set(),
      array: new Set(),
      watch: new Set(),
      watchAll: false,
      focus: '',
    };

    _state.mount =
      !_proxyFormState.isValid ||
      !!keepStateOptions.keepIsValid ||
      !!keepStateOptions.keepDirtyValues;

    _state.watch = !!_options.shouldUnregister;

    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount
        ? _formState.submitCount
        : 0,
      isDirty: isEmptyResetValues
        ? false
        : keepStateOptions.keepDirty
          ? _formState.isDirty
          : !!(
              keepStateOptions.keepDefaultValues &&
              !deepEqual(formValues, _defaultValues)
            ),
      isSubmitted: keepStateOptions.keepIsSubmitted
        ? _formState.isSubmitted
        : false,
      dirtyFields: isEmptyResetValues
        ? {}
        : keepStateOptions.keepDirtyValues
          ? keepStateOptions.keepDefaultValues && _formValues
            ? getDirtyFields(_defaultValues, _formValues)
            : _formState.dirtyFields
          : keepStateOptions.keepDefaultValues && formValues
            ? getDirtyFields(_defaultValues, formValues)
            : keepStateOptions.keepDirty
              ? _formState.dirtyFields
              : {},
      touchedFields: keepStateOptions.keepTouched
        ? _formState.touchedFields
        : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful
        ? _formState.isSubmitSuccessful
        : false,
      isSubmitting: false,
    });
  };

  const reset: UseFormReset<TFieldValues> = (formValues, keepStateOptions) =>
    _reset(
      isFunction(formValues)
        ? (formValues as Function)(_formValues as TFieldValues)
        : formValues,
      keepStateOptions,
    );

  const setFocus: UseFormSetFocus<TFieldValues> = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;

    if (fieldReference) {
      const fieldRef = fieldReference.refs
        ? fieldReference.refs[0]
        : fieldReference.ref;

      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect &&
          isFunction(fieldRef.select) &&
          fieldRef.select();
      }
    }
  };

  const _updateFormState = (
    updatedFormState: Partial<FormState<TFieldValues>>,
  ) => {
    _formState = {
      ..._formState,
      ...updatedFormState,
    };
  };

  const _resetDefaultValues = () =>
    isFunction(_options.defaultValues) &&
    (_options.defaultValues as Function)().then((values: TFieldValues) => {
      reset(values, _options.resetOptions);
      _subjects.state.next({
        isLoading: false,
      });
    });

  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value,
        };
      },
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState,
  };
}


================================================
File: /src/logic/isNameInFieldArray.ts
================================================
import { InternalFieldName } from '../types';

import getNodeParentName from './getNodeParentName';

export default (names: Set<InternalFieldName>, name: InternalFieldName) =>
  names.has(getNodeParentName(name));


================================================
File: /src/logic/getValueAndMessage.ts
================================================
import { ValidationRule } from '../types';
import isObject from '../utils/isObject';
import isRegex from '../utils/isRegex';

export default (validationData?: ValidationRule) =>
  isObject(validationData) && !isRegex(validationData)
    ? validationData
    : {
        value: validationData,
        message: '',
      };


================================================
File: /src/logic/hasPromiseValidation.ts
================================================
import { Field, Validate } from '../types';
import isFunction from '../utils/isFunction';
import isObject from '../utils/isObject';

const ASYNC_FUNCTION = 'AsyncFunction';

export default (fieldReference: Field['_f']) =>
  !!fieldReference &&
  !!fieldReference.validate &&
  !!(
    (isFunction(fieldReference.validate) &&
      fieldReference.validate.constructor.name === ASYNC_FUNCTION) ||
    (isObject(fieldReference.validate) &&
      Object.values(fieldReference.validate).find(
        (validateFunction: Validate<unknown, unknown>) =>
          validateFunction.constructor.name === ASYNC_FUNCTION,
      ))
  );


================================================
File: /src/logic/getValidateError.ts
================================================
import { FieldError, Ref, ValidateResult } from '../types';
import isBoolean from '../utils/isBoolean';
import isMessage from '../utils/isMessage';

export default function getValidateError(
  result: ValidateResult,
  ref: Ref,
  type = 'validate',
): FieldError | void {
  if (
    isMessage(result) ||
    (Array.isArray(result) && result.every(isMessage)) ||
    (isBoolean(result) && !result)
  ) {
    return {
      type,
      message: isMessage(result) ? result : '',
      ref,
    };
  }
}


================================================
File: /src/logic/appendErrors.ts
================================================
import {
  InternalFieldErrors,
  InternalFieldName,
  ValidateResult,
} from '../types';

export default (
  name: InternalFieldName,
  validateAllFieldCriteria: boolean,
  errors: InternalFieldErrors,
  type: string,
  message: ValidateResult,
) =>
  validateAllFieldCriteria
    ? {
        ...errors[name],
        types: {
          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),
          [type]: message || true,
        },
      }
    : {};


================================================
File: /src/logic/skipValidation.ts
================================================
import { ValidationModeFlags } from '../types';

export default (
  isBlurEvent: boolean,
  isTouched: boolean,
  isSubmitted: boolean,
  reValidateMode: {
    isOnBlur: boolean;
    isOnChange: boolean;
  },
  mode: Partial<ValidationModeFlags>,
) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};


================================================
File: /src/logic/updateFieldArrayRootError.ts
================================================
import {
  FieldError,
  FieldErrors,
  FieldValues,
  InternalFieldName,
} from '../types';
import convertToArrayPayload from '../utils/convertToArrayPayload';
import get from '../utils/get';
import set from '../utils/set';

export default <T extends FieldValues = FieldValues>(
  errors: FieldErrors<T>,
  error: Partial<Record<string, FieldError>>,
  name: InternalFieldName,
): FieldErrors<T> => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, 'root', error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};


================================================
File: /src/logic/getProxyFormState.ts
================================================
import { VALIDATION_MODE } from '../constants';
import { Control, FieldValues, FormState, ReadFormState } from '../types';

export default <TFieldValues extends FieldValues, TContext = any>(
  formState: FormState<TFieldValues>,
  control: Control<TFieldValues, TContext>,
  localProxyFormState?: ReadFormState,
  isRoot = true,
) => {
  const result = {
    defaultValues: control._defaultValues,
  } as typeof formState;

  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key as keyof FormState<TFieldValues> & keyof ReadFormState;

        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }

        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      },
    });
  }

  return result;
};


================================================
File: /src/logic/isWatched.ts
================================================
import { InternalFieldName, Names } from '../types';

export default (
  name: InternalFieldName,
  _names: Names,
  isBlurEvent?: boolean,
) =>
  !isBlurEvent &&
  (_names.watchAll ||
    _names.watch.has(name) ||
    [..._names.watch].some(
      (watchName) =>
        name.startsWith(watchName) &&
        /^\.\w+/.test(name.slice(watchName.length)),
    ));


================================================
File: /src/logic/getResolverOptions.ts
================================================
import {
  CriteriaMode,
  Field,
  FieldName,
  FieldRefs,
  FieldValues,
  InternalFieldName,
} from '../types';
import { get } from '../utils';
import set from '../utils/set';

export default <TFieldValues extends FieldValues>(
  fieldsNames: Set<InternalFieldName> | InternalFieldName[],
  _fields: FieldRefs,
  criteriaMode?: CriteriaMode,
  shouldUseNativeValidation?: boolean | undefined,
) => {
  const fields: Record<InternalFieldName, Field['_f']> = {};

  for (const name of fieldsNames) {
    const field: Field = get(_fields, name);

    field && set(fields, name, field._f);
  }

  return {
    criteriaMode,
    names: [...fieldsNames] as FieldName<TFieldValues>[],
    fields,
    shouldUseNativeValidation,
  };
};


================================================
File: /src/logic/generateId.ts
================================================
export default () => {
  const d =
    typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;

  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16 + d) % 16 | 0;

    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
  });
};


================================================
File: /src/logic/index.ts
================================================
import appendErrors from './appendErrors';

export { appendErrors };


================================================
File: /src/logic/unsetEmptyArray.ts
================================================
import compact from '../utils/compact';
import get from '../utils/get';
import unset from '../utils/unset';

export default <T>(ref: T, name: string) =>
  !compact(get(ref, name)).length && unset(ref, name);


================================================
File: /src/logic/generateWatchOutput.ts
================================================
import { DeepPartial, FieldValues, Names } from '../types';
import get from '../utils/get';
import isString from '../utils/isString';

export default <T>(
  names: string | string[] | undefined,
  _names: Names,
  formValues?: FieldValues,
  isGlobal?: boolean,
  defaultValue?: DeepPartial<T> | unknown,
) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }

  if (Array.isArray(names)) {
    return names.map(
      (fieldName) => (
        isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)
      ),
    );
  }

  isGlobal && (_names.watchAll = true);

  return formValues;
};


================================================
File: /src/logic/getRuleValue.ts
================================================
import {
  ValidationRule,
  ValidationValue,
  ValidationValueMessage,
} from '../types';
import isObject from '../utils/isObject';
import isRegex from '../utils/isRegex';
import isUndefined from '../utils/isUndefined';

export default <T extends ValidationValue>(
  rule?: ValidationRule<T> | ValidationValueMessage<T>,
) =>
  isUndefined(rule)
    ? rule
    : isRegex(rule)
      ? rule.source
      : isObject(rule)
        ? isRegex(rule.value)
          ? rule.value.source
          : rule.value
        : rule;


================================================
File: /src/logic/hasValidation.ts
================================================
import { Field } from '../types';

export default (options: Field['_f']) =>
  options.mount &&
  (options.required ||
    options.min ||
    options.max ||
    options.maxLength ||
    options.minLength ||
    options.pattern ||
    options.validate);


================================================
File: /src/logic/getValidationModes.ts
================================================
import { VALIDATION_MODE } from '../constants';
import { Mode, ValidationModeFlags } from '../types';

export default (mode?: Mode): ValidationModeFlags => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched,
});


================================================
File: /src/logic/shouldSubscribeByName.ts
================================================
import convertToArrayPayload from '../utils/convertToArrayPayload';

export default <T extends string | string[] | undefined>(
  name?: T,
  signalName?: string,
  exact?: boolean,
) =>
  !name ||
  !signalName ||
  name === signalName ||
  convertToArrayPayload(name).some(
    (currentName) =>
      currentName &&
      (exact
        ? currentName === signalName
        : currentName.startsWith(signalName) ||
          signalName.startsWith(currentName)),
  );


================================================
File: /src/useFieldArray.ts
================================================
import React from 'react';

import generateId from './logic/generateId';
import getFocusFieldName from './logic/getFocusFieldName';
import getValidationModes from './logic/getValidationModes';
import isWatched from './logic/isWatched';
import iterateFieldsByAction from './logic/iterateFieldsByAction';
import updateFieldArrayRootError from './logic/updateFieldArrayRootError';
import validateField from './logic/validateField';
import appendAt from './utils/append';
import cloneObject from './utils/cloneObject';
import convertToArrayPayload from './utils/convertToArrayPayload';
import fillEmptyArray from './utils/fillEmptyArray';
import get from './utils/get';
import insertAt from './utils/insert';
import isEmptyObject from './utils/isEmptyObject';
import moveArrayAt from './utils/move';
import prependAt from './utils/prepend';
import removeArrayAt from './utils/remove';
import set from './utils/set';
import swapArrayAt from './utils/swap';
import unset from './utils/unset';
import updateAt from './utils/update';
import { VALIDATION_MODE } from './constants';
import {
  Control,
  Field,
  FieldArray,
  FieldArrayMethodProps,
  FieldArrayPath,
  FieldArrayWithId,
  FieldErrors,
  FieldPath,
  FieldValues,
  FormState,
  InternalFieldName,
  RegisterOptions,
  UseFieldArrayProps,
  UseFieldArrayReturn,
} from './types';
import { useFormContext } from './useFormContext';
import { useSubscribe } from './useSubscribe';

/**
 * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)
 *
 * @param props - useFieldArray props
 *
 * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({
 *     defaultValues: {
 *       test: []
 *     }
 *   });
 *   const { fields, append } = useFieldArray({
 *     control,
 *     name: "test"
 *   });
 *
 *   return (
 *     <form onSubmit={handleSubmit(data => console.log(data))}>
 *       {fields.map((item, index) => (
 *          <input key={item.id} {...register(`test.${index}.firstName`)}  />
 *       ))}
 *       <button type="button" onClick={() => append({ firstName: "bill" })}>
 *         append
 *       </button>
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
export function useFieldArray<
  TFieldValues extends FieldValues = FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
  TKeyName extends string = 'id',
>(
  props: UseFieldArrayProps<TFieldValues, TFieldArrayName, TKeyName>,
): UseFieldArrayReturn<TFieldValues, TFieldArrayName, TKeyName> {
  const methods = useFormContext();
  const {
    control = methods.control,
    name,
    keyName = 'id',
    shouldUnregister,
    rules,
  } = props;
  const [fields, setFields] = React.useState(control._getFieldArray(name));
  const ids = React.useRef<string[]>(
    control._getFieldArray(name).map(generateId),
  );
  const _fieldIds = React.useRef(fields);
  const _name = React.useRef(name);
  const _actioned = React.useRef(false);

  _name.current = name;
  _fieldIds.current = fields;
  control._names.array.add(name);

  rules &&
    (control as Control<TFieldValues>).register(
      name as FieldPath<TFieldValues>,
      rules as RegisterOptions<TFieldValues>,
    );

  useSubscribe({
    next: ({
      values,
      name: fieldArrayName,
    }: {
      values?: FieldValues;
      name?: InternalFieldName;
    }) => {
      if (fieldArrayName === _name.current || !fieldArrayName) {
        const fieldValues = get(values, _name.current);
        if (Array.isArray(fieldValues)) {
          setFields(fieldValues);
          ids.current = fieldValues.map(generateId);
        }
      }
    },
    subject: control._subjects.array,
  });

  const updateValues = React.useCallback(
    <
      T extends Partial<
        FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>
      >[],
    >(
      updatedFieldArrayValues: T,
    ) => {
      _actioned.current = true;
      control._updateFieldArray(name, updatedFieldArrayValues);
    },
    [control, name],
  );

  const append = (
    value:
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],
    options?: FieldArrayMethodProps,
  ) => {
    const appendValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = appendAt(
      control._getFieldArray(name),
      appendValue,
    );
    control._names.focus = getFocusFieldName(
      name,
      updatedFieldArrayValues.length - 1,
      options,
    );
    ids.current = appendAt(ids.current, appendValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {
      argA: fillEmptyArray(value),
    });
  };

  const prepend = (
    value:
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],
    options?: FieldArrayMethodProps,
  ) => {
    const prependValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = prependAt(
      control._getFieldArray(name),
      prependValue,
    );
    control._names.focus = getFocusFieldName(name, 0, options);
    ids.current = prependAt(ids.current, prependValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {
      argA: fillEmptyArray(value),
    });
  };

  const remove = (index?: number | number[]) => {
    const updatedFieldArrayValues: Partial<
      FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>
    >[] = removeArrayAt(control._getFieldArray(name), index);
    ids.current = removeArrayAt(ids.current, index);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    !Array.isArray(get(control._fields, name)) &&
      set(control._fields, name, undefined);
    control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
      argA: index,
    });
  };

  const insert = (
    index: number,
    value:
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],
    options?: FieldArrayMethodProps,
  ) => {
    const insertValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = insertAt(
      control._getFieldArray(name),
      index,
      insertValue,
    );
    control._names.focus = getFocusFieldName(name, index, options);
    ids.current = insertAt(ids.current, index, insertValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, insertAt, {
      argA: index,
      argB: fillEmptyArray(value),
    });
  };

  const swap = (indexA: number, indexB: number) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    swapArrayAt(updatedFieldArrayValues, indexA, indexB);
    swapArrayAt(ids.current, indexA, indexB);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(
      name,
      updatedFieldArrayValues,
      swapArrayAt,
      {
        argA: indexA,
        argB: indexB,
      },
      false,
    );
  };

  const move = (from: number, to: number) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    moveArrayAt(updatedFieldArrayValues, from, to);
    moveArrayAt(ids.current, from, to);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(
      name,
      updatedFieldArrayValues,
      moveArrayAt,
      {
        argA: from,
        argB: to,
      },
      false,
    );
  };

  const update = (
    index: number,
    value: FieldArray<TFieldValues, TFieldArrayName>,
  ) => {
    const updateValue = cloneObject(value);
    const updatedFieldArrayValues = updateAt(
      control._getFieldArray<
        FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>
      >(name),
      index,
      updateValue as FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>,
    );
    ids.current = [...updatedFieldArrayValues].map((item, i) =>
      !item || i === index ? generateId() : ids.current[i],
    );
    updateValues(updatedFieldArrayValues);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(
      name,
      updatedFieldArrayValues,
      updateAt,
      {
        argA: index,
        argB: updateValue,
      },
      true,
      false,
    );
  };

  const replace = (
    value:
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>
      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],
  ) => {
    const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
    ids.current = updatedFieldArrayValues.map(generateId);
    updateValues([...updatedFieldArrayValues]);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(
      name,
      [...updatedFieldArrayValues],
      <T>(data: T): T => data,
      {},
      true,
      false,
    );
  };

  React.useEffect(() => {
    control._state.action = false;

    isWatched(name, control._names) &&
      control._subjects.state.next({
        ...control._formState,
      } as FormState<TFieldValues>);

    if (
      _actioned.current &&
      (!getValidationModes(control._options.mode).isOnSubmit ||
        control._formState.isSubmitted)
    ) {
      if (control._options.resolver) {
        control._executeSchema([name]).then((result) => {
          const error = get(result.errors, name);
          const existingError = get(control._formState.errors, name);

          if (
            existingError
              ? (!error && existingError.type) ||
                (error &&
                  (existingError.type !== error.type ||
                    existingError.message !== error.message))
              : error && error.type
          ) {
            error
              ? set(control._formState.errors, name, error)
              : unset(control._formState.errors, name);
            control._subjects.state.next({
              errors: control._formState.errors as FieldErrors<TFieldValues>,
            });
          }
        });
      } else {
        const field: Field = get(control._fields, name);
        if (
          field &&
          field._f &&
          !(
            getValidationModes(control._options.reValidateMode).isOnSubmit &&
            getValidationModes(control._options.mode).isOnSubmit
          )
        ) {
          validateField(
            field,
            control._formValues,
            control._options.criteriaMode === VALIDATION_MODE.all,
            control._options.shouldUseNativeValidation,
            true,
          ).then(
            (error) =>
              !isEmptyObject(error) &&
              control._subjects.state.next({
                errors: updateFieldArrayRootError(
                  control._formState.errors as FieldErrors<TFieldValues>,
                  error,
                  name,
                ) as FieldErrors<TFieldValues>,
              }),
          );
        }
      }
    }

    control._subjects.values.next({
      name,
      values: { ...control._formValues },
    });

    control._names.focus &&
      iterateFieldsByAction(control._fields, (ref, key: string) => {
        if (
          control._names.focus &&
          key.startsWith(control._names.focus) &&
          ref.focus
        ) {
          ref.focus();
          return 1;
        }
        return;
      });

    control._names.focus = '';

    control._updateValid();

    _actioned.current = false;
  }, [fields, name, control]);

  React.useEffect(() => {
    !get(control._formValues, name) && control._updateFieldArray(name);

    return () => {
      (control._options.shouldUnregister || shouldUnregister) &&
        control.unregister(name as FieldPath<TFieldValues>);
    };
  }, [name, control, keyName, shouldUnregister]);

  return {
    swap: React.useCallback(swap, [updateValues, name, control]),
    move: React.useCallback(move, [updateValues, name, control]),
    prepend: React.useCallback(prepend, [updateValues, name, control]),
    append: React.useCallback(append, [updateValues, name, control]),
    remove: React.useCallback(remove, [updateValues, name, control]),
    insert: React.useCallback(insert, [updateValues, name, control]),
    update: React.useCallback(update, [updateValues, name, control]),
    replace: React.useCallback(replace, [updateValues, name, control]),
    fields: React.useMemo(
      () =>
        fields.map((field, index) => ({
          ...field,
          [keyName]: ids.current[index] || generateId(),
        })) as FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>[],
      [fields, keyName],
    ),
  };
}


================================================
File: /src/form.tsx
================================================
import React from 'react';

import { flatten } from './utils/flatten';
import { FieldValues, FormProps } from './types';
import { useFormContext } from './useFormContext';

const POST_REQUEST = 'post';

/**
 * Form component to manage submission.
 *
 * @param props - to setup submission detail. {@link FormProps}
 *
 * @returns form component or headless render prop.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control, formState: { errors } } = useForm();
 *
 *   return (
 *     <Form action="/api" control={control}>
 *       <input {...register("name")} />
 *       <p>{errors?.root?.server && 'Server error'}</p>
 *       <button>Submit</button>
 *     </Form>
 *   );
 * }
 * ```
 */
function Form<
  T extends FieldValues,
  U extends FieldValues | undefined = undefined,
>(props: FormProps<T, U>) {
  const methods = useFormContext<T>();
  const [mounted, setMounted] = React.useState(false);
  const {
    control = methods.control,
    onSubmit,
    children,
    action,
    method = POST_REQUEST,
    headers,
    encType,
    onError,
    render,
    onSuccess,
    validateStatus,
    ...rest
  } = props;

  const submit = async (event?: React.BaseSyntheticEvent) => {
    let hasError = false;
    let type = '';

    await control.handleSubmit(async (data) => {
      const formData = new FormData();
      let formDataJson = '';

      try {
        formDataJson = JSON.stringify(data);
      } catch {}

      const flattenFormValues = flatten(control._formValues);

      for (const key in flattenFormValues) {
        formData.append(key, flattenFormValues[key]);
      }

      if (onSubmit) {
        await onSubmit({
          data,
          event,
          method,
          formData,
          formDataJson,
        });
      }

      if (action) {
        try {
          const shouldStringifySubmissionData = [
            headers && headers['Content-Type'],
            encType,
          ].some((value) => value && value.includes('json'));

          const response = await fetch(String(action), {
            method,
            headers: {
              ...headers,
              ...(encType ? { 'Content-Type': encType } : {}),
            },
            body: shouldStringifySubmissionData ? formDataJson : formData,
          });

          if (
            response &&
            (validateStatus
              ? !validateStatus(response.status)
              : response.status < 200 || response.status >= 300)
          ) {
            hasError = true;
            onError && onError({ response });
            type = String(response.status);
          } else {
            onSuccess && onSuccess({ response });
          }
        } catch (error: unknown) {
          hasError = true;
          onError && onError({ error });
        }
      }
    })(event);

    if (hasError && props.control) {
      props.control._subjects.state.next({
        isSubmitSuccessful: false,
      });
      props.control.setError('root.server', {
        type,
      });
    }
  };

  React.useEffect(() => {
    setMounted(true);
  }, []);

  return render ? (
    <>
      {render({
        submit,
      })}
    </>
  ) : (
    <form
      noValidate={mounted}
      action={action}
      method={method}
      encType={encType}
      onSubmit={submit}
      {...rest}
    >
      {children}
    </form>
  );
}

export { Form };


================================================
File: /src/controller.tsx
================================================
import { ControllerProps, FieldPath, FieldValues } from './types';
import { useController } from './useController';

/**
 * Component based on `useController` hook to work with controlled component.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns provide field handler functions, field and form state.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control } = useForm<FormValues>({
 *     defaultValues: {
 *       test: ""
 *     }
 *   });
 *
 *   return (
 *     <form>
 *       <Controller
 *         control={control}
 *         name="test"
 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
 *           <>
 *             <input
 *               onChange={onChange} // send value to hook form
 *               onBlur={onBlur} // notify when input is touched
 *               value={value} // return updated value
 *               ref={ref} // set ref for focus management
 *             />
 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
 *           </>
 *         )}
 *       />
 *     </form>
 *   );
 * }
 * ```
 */
const Controller = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  props: ControllerProps<TFieldValues, TName>,
) => props.render(useController<TFieldValues, TName>(props));

export { Controller };


================================================
File: /src/useWatch.ts
================================================
import React from 'react';

import generateWatchOutput from './logic/generateWatchOutput';
import shouldSubscribeByName from './logic/shouldSubscribeByName';
import cloneObject from './utils/cloneObject';
import {
  Control,
  DeepPartialSkipArrayKey,
  FieldPath,
  FieldPathValue,
  FieldPathValues,
  FieldValues,
  InternalFieldName,
  UseWatchProps,
} from './types';
import { useFormContext } from './useFormContext';
import { useSubscribe } from './useSubscribe';

/**
 * Subscribe to the entire form values change and re-render at the hook level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @param props - defaultValue, disable subscription and match exact name.
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   control,
 *   defaultValue: {
 *     name: "data"
 *   },
 *   exact: false,
 * })
 * ```
 */
export function useWatch<
  TFieldValues extends FieldValues = FieldValues,
>(props: {
  defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
  control?: Control<TFieldValues>;
  disabled?: boolean;
  exact?: boolean;
}): DeepPartialSkipArrayKey<TFieldValues>;
/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @param props - defaultValue, disable subscription and match exact name.
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   control,
 *   name: "fieldA",
 *   defaultValue: "default value",
 *   exact: false,
 * })
 * ```
 */
export function useWatch<
  TFieldValues extends FieldValues = FieldValues,
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(props: {
  name: TFieldName;
  defaultValue?: FieldPathValue<TFieldValues, TFieldName>;
  control?: Control<TFieldValues>;
  disabled?: boolean;
  exact?: boolean;
}): FieldPathValue<TFieldValues, TFieldName>;
/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @param props - defaultValue, disable subscription and match exact name.
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   control,
 *   name: ["fieldA", "fieldB"],
 *   defaultValue: {
 *     fieldA: "data",
 *     fieldB: "data"
 *   },
 *   exact: false,
 * })
 * ```
 */
export function useWatch<
  TFieldValues extends FieldValues = FieldValues,
  TFieldNames extends
    readonly FieldPath<TFieldValues>[] = readonly FieldPath<TFieldValues>[],
>(props: {
  name: readonly [...TFieldNames];
  defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
  control?: Control<TFieldValues>;
  disabled?: boolean;
  exact?: boolean;
}): FieldPathValues<TFieldValues, TFieldNames>;
/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * // can skip passing down the control into useWatch if the form is wrapped with the FormProvider
 * const values = useWatch()
 * ```
 */
export function useWatch<
  TFieldValues extends FieldValues = FieldValues,
>(): DeepPartialSkipArrayKey<TFieldValues>;
/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   name: "fieldName"
 *   control,
 * })
 * ```
 */
export function useWatch<TFieldValues extends FieldValues>(
  props?: UseWatchProps<TFieldValues>,
) {
  const methods = useFormContext();
  const {
    control = methods.control,
    name,
    defaultValue,
    disabled,
    exact,
  } = props || {};
  const _name = React.useRef(name);

  _name.current = name;

  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState: { name?: InternalFieldName; values?: FieldValues }) => {
      if (
        shouldSubscribeByName(
          _name.current as InternalFieldName,
          formState.name,
          exact,
        )
      ) {
        updateValue(
          cloneObject(
            generateWatchOutput(
              _name.current as InternalFieldName | InternalFieldName[],
              control._names,
              formState.values || control._formValues,
              false,
              defaultValue,
            ),
          ),
        );
      }
    },
  });

  const [value, updateValue] = React.useState(
    control._getWatch(
      name as InternalFieldName,
      defaultValue as DeepPartialSkipArrayKey<TFieldValues>,
    ),
  );

  React.useEffect(() => control._removeUnmounted());

  return value;
}


================================================
File: /src/index.react-server.ts
================================================
export * from './logic';
export * from './utils';


================================================
File: /src/useSubscribe.ts
================================================
import React from 'react';

import { Subject } from './utils/createSubject';

type Props<T> = {
  disabled?: boolean;
  subject: Subject<T>;
  next: (value: T) => void;
};

export function useSubscribe<T>(props: Props<T>) {
  const _props = React.useRef(props);
  _props.current = props;

  React.useEffect(() => {
    const subscription =
      !props.disabled &&
      _props.current.subject &&
      _props.current.subject.subscribe({
        next: _props.current.next,
      });

    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}


================================================
File: /src/constants.ts
================================================
export const EVENTS = {
  BLUR: 'blur',
  FOCUS_OUT: 'focusout',
  CHANGE: 'change',
} as const;

export const VALIDATION_MODE = {
  onBlur: 'onBlur',
  onChange: 'onChange',
  onSubmit: 'onSubmit',
  onTouched: 'onTouched',
  all: 'all',
} as const;

export const INPUT_VALIDATION_RULES = {
  max: 'max',
  min: 'min',
  maxLength: 'maxLength',
  minLength: 'minLength',
  pattern: 'pattern',
  required: 'required',
  validate: 'validate',
} as const;


================================================
File: /src/useFormContext.tsx
================================================
import React from 'react';

import { FieldValues, FormProviderProps, UseFormReturn } from './types';

const HookFormContext = React.createContext<UseFormReturn | null>(null);

/**
 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @returns return all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
export const useFormContext = <
  TFieldValues extends FieldValues,
  TContext = any,
  TransformedValues extends FieldValues | undefined = undefined,
>(): UseFormReturn<TFieldValues, TContext, TransformedValues> =>
  React.useContext(HookFormContext) as UseFormReturn<
    TFieldValues,
    TContext,
    TransformedValues
  >;

/**
 * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @param props - all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
export const FormProvider = <
  TFieldValues extends FieldValues,
  TContext = any,
  TTransformedValues extends FieldValues | undefined = undefined,
>(
  props: FormProviderProps<TFieldValues, TContext, TTransformedValues>,
) => {
  const { children, ...data } = props;
  return (
    <HookFormContext.Provider value={data as unknown as UseFormReturn}>
      {children}
    </HookFormContext.Provider>
  );
};


================================================
File: /src/useForm.ts
================================================
import React from 'react';

import { createFormControl } from './logic/createFormControl';
import getProxyFormState from './logic/getProxyFormState';
import shouldRenderFormState from './logic/shouldRenderFormState';
import deepEqual from './utils/deepEqual';
import isFunction from './utils/isFunction';
import {
  FieldValues,
  FormState,
  InternalFieldName,
  UseFormProps,
  UseFormReturn,
} from './types';
import { useSubscribe } from './useSubscribe';

/**
 * Custom hook to manage the entire form.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
 *
 * @param props - form configuration and validation parameters.
 *
 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   console.log(watch("example"));
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input defaultValue="test" {...register("example")} />
 *       <input {...register("exampleRequired", { required: true })} />
 *       {errors.exampleRequired && <span>This field is required</span>}
 *       <button>Submit</button>
 *     </form>
 *   );
 * }
 * ```
 */
export function useForm<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
  TTransformedValues extends FieldValues | undefined = undefined,
>(
  props: UseFormProps<TFieldValues, TContext> = {},
): UseFormReturn<TFieldValues, TContext, TTransformedValues> {
  const _formControl = React.useRef<
    UseFormReturn<TFieldValues, TContext, TTransformedValues> | undefined
  >(undefined);
  const _values = React.useRef<typeof props.values>(undefined);
  const [formState, updateFormState] = React.useState<FormState<TFieldValues>>({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues)
      ? undefined
      : props.defaultValues,
  });

  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState,
    };
  }

  const control = _formControl.current.control;
  control._options = props;

  useSubscribe({
    subject: control._subjects.state,
    next: (
      value: Partial<FormState<TFieldValues>> & { name?: InternalFieldName },
    ) => {
      if (
        shouldRenderFormState(
          value,
          control._proxyFormState,
          control._updateFormState,
          true,
        )
      ) {
        updateFormState({ ...control._formState });
      }
    },
  });

  React.useEffect(
    () => control._disableForm(props.disabled),
    [control, props.disabled],
  );

  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty,
        });
      }
    }
  }, [control, formState.isDirty]);

  React.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);

  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);

  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }

    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }

    control._removeUnmounted();
  });

  React.useEffect(() => {
    props.shouldUnregister &&
      control._subjects.values.next({
        values: control._getWatch(),
      });
  }, [props.shouldUnregister, control]);

  _formControl.current.formState = getProxyFormState(formState, control);

  return _formControl.current;
}


================================================
File: /src/index.ts
================================================
export * from './controller';
export * from './form';
export * from './logic';
export * from './types';
export * from './useController';
export * from './useFieldArray';
export * from './useForm';
export * from './useFormContext';
export * from './useFormState';
export * from './useWatch';
export * from './utils';


================================================
File: /src/__typetest__/errors.test-d.ts
================================================
import { expectType } from 'tsd';

import { FieldError, FieldErrors, GlobalError, Merge } from '../types';

import { _ } from './__fixtures__';

/** {@link FieldErrors} */ {
  /** it should support optional record fields */
  {
    const actual = _ as FieldErrors<{
      test?: string;
      test1?: string;
      attachment: {
        data: string;
        data1: string;
      };
    }>;
    expectType<
      {
        test?: FieldError;
        test1?: FieldError;
        attachment?: Merge<
          FieldError,
          {
            data?: FieldError;
            data1?: FieldError;
          }
        >;
      } & {
        root?: Record<string, GlobalError> & GlobalError;
      }
    >(actual);
  }

  /** it should support nullable record fields */
  {
    const actual = _ as FieldErrors<{
      test?: string;
      test1?: string | null;
      attachment: {
        data: string;
        data1: string;
      } | null;
    }>;
    expectType<
      {
        test?: FieldError;
        test1?: FieldError;
        attachment?: Merge<
          FieldError,
          {
            data?: FieldError;
            data1?: FieldError;
          }
        >;
      } & {
        root?: Record<string, GlobalError> & GlobalError;
      }
    >(actual);
  }

  /** it should not treat Date, File, FileList or Blob as record fields */
  {
    const actual = _ as FieldErrors<{
      date: Date;
      file: File;
      fileList: FileList;
      record: {
        date: Date;
        file: File;
        fileList: FileList;
      };
    }>;
    expectType<FieldError | undefined>(actual.date);
    expectType<FieldError | undefined>(actual.file);
    expectType<FieldError | undefined>(actual.fileList);
    expectType<FieldError | undefined>(actual.record?.date);
    expectType<FieldError | undefined>(actual.record?.file);
    expectType<FieldError | undefined>(actual.record?.fileList);
  }
}


================================================
File: /src/__typetest__/form.test-d.ts
================================================
import { expectType } from 'tsd';

import { FieldError } from '../types';
import { useForm } from '../useForm';

/** {@link UseFormHandleSubmit} */ {
  /** it should infer the correct defaultValues from useForm */ {
    /* eslint-disable react-hooks/rules-of-hooks */
    const { handleSubmit } = useForm({
      defaultValues: {
        test: '',
        test1: 2,
      },
    });

    handleSubmit((data) => expectType<{ test: string; test1: number }>(data));
  }

  /** it should infer the correct defaultValues from useForm generic */ {
    /* eslint-disable react-hooks/rules-of-hooks */
    const { handleSubmit } = useForm<{
      test: string;
      test1: number;
    }>();

    handleSubmit((data) => expectType<{ test: string; test1: number }>(data));
  }
}

/** {@link UseFormGetFieldState} */ {
  /** it should return associated field state */ {
    /* eslint-disable react-hooks/rules-of-hooks */
    const { getFieldState } = useForm({
      defaultValues: {
        test: '',
      },
    });

    expectType<{
      invalid: boolean;
      isDirty: boolean;
      isTouched: boolean;
      isValidating: boolean;
      error?: FieldError;
    }>(getFieldState('test'));
  }

  /** it should return associated field state when formState is supplied */ {
    /* eslint-disable react-hooks/rules-of-hooks */
    const { getFieldState, formState } = useForm({
      defaultValues: {
        test: '',
      },
    });

    expectType<{
      invalid: boolean;
      isDirty: boolean;
      isTouched: boolean;
      isValidating: boolean;
      error?: FieldError;
    }>(getFieldState('test', formState));
  }
}


================================================
File: /src/__typetest__/path/common.test-d.ts
================================================
import { expectType } from 'tsd';

import {
  ArrayKey,
  AsKey,
  AsPathTuple,
  CheckKeyConstraint,
  ContainsIndexable,
  EvaluateKey,
  EvaluatePath,
  HasKey,
  HasPath,
  IsTuple,
  JoinPathTuple,
  Key,
  Keys,
  NumericKeys,
  ObjectKeys,
  PathString,
  SplitPathString,
  ToKey,
  TupleKeys,
  UnionToIntersection,
  ValidPathPrefix,
} from '../../types/path/common';
import {
  _,
  HundredPathString,
  HundredTuple,
  InfiniteType,
  Nested,
  NullableInfiniteType,
} from '../__fixtures__';

/** {@link IsTuple} */ {
  /** it should evaluate to true if it's a tuple */ {
    const actual = _ as IsTuple<[string, number]>;
    expectType<true>(actual);
  }

  /** it should evaluate to false if it's not a tuple */ {
    const actual = _ as IsTuple<string[]>;
    expectType<false>(actual);
  }
}

/** {@link TupleKeys} */ {
  /** it should evaluate to the own keys of the tuple */ {
    const actual = _ as TupleKeys<[string, number]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should evaluate to never if an array type is passed */ {
    const actual = _ as TupleKeys<string[]>;
    expectType<never>(actual);
  }
}

/** {@link AsKey} */ {
  /** it should behave like a noop type when a Key is passed */ {
    const actual = _ as AsKey<'foo'>;
    expectType<'foo'>(actual);
  }

  /** it should evaluate to never if not a Key is passed */ {
    const actual = _ as AsKey<boolean>;
    expectType<never>(actual);
  }
}

/** {@link ToKey} */ {
  /** it should behave like a noop type when a Key is passed */ {
    const actual = _ as ToKey<'foo'>;
    expectType<'foo'>(actual);
  }

  /** it should evaluate to never if not a Key or ArrayKey is passed */ {
    const actual = _ as ToKey<boolean>;
    expectType<never>(actual);
  }

  /** it should convert an ArrayKey to a template literal type */ {
    const actual = _ as ToKey<ArrayKey>;
    expectType<`${ArrayKey}`>(actual);
  }
}

/** {@link AsPathTuple} */ {
  /** it should behave like a noop type when a PathTuple is passed */ {
    const actual = _ as AsPathTuple<['foo']>;
    expectType<['foo']>(actual);
  }

  /** it should evaluate to never if not a PathTuple is passed */ {
    const actual = _ as AsPathTuple<[42]>;
    expectType<never>(actual);
  }
}

/** {@link SplitPathString} */ {
  /** it should split the PathString */ {
    const actual = _ as SplitPathString<'foo.bar.0.baz'>;
    expectType<['foo', 'bar', '0', 'baz']>(actual);
  }

  /** it should split a PathString which does not contain a "." */ {
    const actual = _ as SplitPathString<'foo'>;
    expectType<['foo']>(actual);
  }

  /** it should return an empty tuple for a blank PathString */ {
    const actual = _ as SplitPathString<''>;
    expectType<[]>(actual);
  }

  /** it should return an empty tuple for a PathString containing only a "." */ {
    const actual = _ as SplitPathString<'.'>;
    expectType<[]>(actual);
  }

  /** it should be implemented tail recursively */ {
    const actual = _ as SplitPathString<HundredPathString<'foo'>>;
    expectType<HundredTuple<'foo'>>(actual);
  }

  /** it should work on unions */ {
    const actual = _ as SplitPathString<'foo.bar' | 'bar.foo'>;
    expectType<['foo', 'bar'] | ['bar', 'foo']>(actual);
  }

  /** it should split a PathString containing a number template */ {
    const actual = _ as SplitPathString<`foo.bar.${number}.baz`>;
    expectType<['foo', 'bar', `${number}`, 'baz']>(actual);
  }

  /** it should split a PathString containing a string template */ {
    const actual = _ as SplitPathString<`foo.bar.${string}.baz`>;
    expectType<['foo', 'bar', string, 'baz']>(actual);
  }
}

/** {@link JoinPathTuple} */ {
  /** it should join the PathTuple */ {
    const actual = _ as JoinPathTuple<['foo', 'bar', '0', 'baz']>;
    expectType<'foo.bar.0.baz'>(actual);
  }

  /** it should join a PathTuple of length 1 */ {
    const actual = _ as JoinPathTuple<['foo']>;
    expectType<'foo'>(actual);
  }

  /** it should evaluate to never when passed an empty PathTuple */ {
    const actual = _ as JoinPathTuple<[]>;
    expectType<never>(actual);
  }

  /** it should be implemented tail recursively */ {
    const actual = _ as JoinPathTuple<HundredTuple<'foo'>>;
    expectType<HundredPathString<'foo'>>(actual);
  }

  /** it should work on unions */ {
    const actual = _ as JoinPathTuple<['foo', 'bar'] | ['bar', 'foo']>;
    expectType<'foo.bar' | 'bar.foo'>(actual);
  }

  /** it should evaluate to never if a keys is never */ {
    const actual = _ as JoinPathTuple<['foo', never]>;
    expectType<never>(actual);
  }
}

/** {@link CheckKeyConstraint} */ {
  /** it should remove the keys which don't match the constraint */ {
    const actual = _ as CheckKeyConstraint<
      { foo: string; bar: number },
      'foo' | 'bar',
      string
    >;
    expectType<'foo'>(actual);
  }
}

/** {@link UnionToIntersection} */ {
  /** it should intersect a union of objects */ {
    const actual = _ as UnionToIntersection<{ foo: string } | { bar: number }>;
    expectType<{ foo: string } & { bar: number }>(actual);
  }

  /** it should intersect wrapped unions */ {
    const actual = _ as UnionToIntersection<[0 | 1] | [1 | 2]>[never];
    expectType<1>(actual);
  }
}

/** {@link ContainsIndexable} */ {
  /** it should evaluate to true when an array is passed */ {
    const actual = _ as ContainsIndexable<number[]>;
    expectType<true>(actual);
  }

  /** it should evaluate to true when a tuple is passed */ {
    const actual = _ as ContainsIndexable<[number]>;
    expectType<true>(actual);
  }

  /** it should evaluate to false when a string is passed */ {
    const actual = _ as ContainsIndexable<string>;
    expectType<false>(actual);
  }

  /** it should evaluate to false when an object is passed */ {
    const actual = _ as ContainsIndexable<{ foo: string }>;
    expectType<false>(actual);
  }

  /** it should evaluate to true when an array is part of the union */ {
    const actual = _ as ContainsIndexable<{ foo: string } | number[]>;
    expectType<true>(actual);
  }

  /** it should evaluate to true when a tuple is part of the union */ {
    const actual = _ as ContainsIndexable<{ foo: string } | [number]>;
    expectType<true>(actual);
  }
}

/** {@link NumericKeys} */ {
  /** it should return the numeric keys of an object */ {
    const actual = _ as NumericKeys<{ 0: string; '1': string; foo: string }>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the numeric keys of an array */ {
    const actual = _ as NumericKeys<number[]>;
    expectType<`${number}`>(actual);
  }

  /** it should return the numeric keys of a tuple */ {
    const actual = _ as NumericKeys<[string, number]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the overlapping numeric keys of a tuple and array */ {
    const actual = _ as NumericKeys<[number, string] | number[]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the overlapping numeric keys of an object and array */ {
    const actual = _ as NumericKeys<{ 0: string; '1': string } | number[]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the overlapping numeric keys of an object and tuple */ {
    const actual = _ as NumericKeys<{ 1: string } | [number, string]>;
    expectType<'1'>(actual);
  }
}

/** {@link ObjectKeys} */ {
  /** it should return the keys of an object */ {
    const actual = _ as ObjectKeys<{ foo: string; bar: number }>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the overlapping keys of a union of objects */ {
    const actual = _ as ObjectKeys<
      { foo: string; bar: number } | { bar: number; baz: string }
    >;
    expectType<'bar'>(actual);
  }

  /** it should not return keys which contain dots */ {
    const actual = _ as ObjectKeys<{ foo: string; 'foo.bar': number }>;
    expectType<'foo'>(actual);
  }

  /** it should not return blank keys */ {
    const actual = _ as ObjectKeys<{ foo: string; '': number }>;
    expectType<'foo'>(actual);
  }
}

/** {@link Keys} */ {
  /** it should return the keys of an object */ {
    const actual = _ as Keys<{ foo: string; bar: number }>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the keys of a tuple */ {
    const actual = _ as Keys<[number, string]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the keys of an array */ {
    const actual = _ as Keys<string[]>;
    expectType<`${number}`>(actual);
  }

  /** it should return the optional keys of an object */ {
    const actual = _ as Keys<{ foo?: string; bar?: number }>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the keys of a nullable type */ {
    const actual = _ as Keys<{ foo: string; bar: number } | null>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the keys of an undefinable type */ {
    const actual = _ as Keys<{ foo: string; bar: number } | undefined>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the optional keys of a tuple */ {
    const actual = _ as Keys<[foo?: string, bar?: number]>;
    expectType<'0' | '1'>(actual);
  }

  /** it should return the optional keys of a union of tuple and object */ {
    const actual = _ as Keys<[foo?: string] | { 0?: string; 1?: string }>;
    expectType<'0'>(actual);
  }

  /** it should only return the keys of string properties */ {
    const actual = _ as Keys<{ foo: string; bar: number }, string>;
    expectType<'foo'>(actual);
  }

  /** it should only return the keys of string properties */ {
    const actual = _ as Keys<{ 1: string; 2: number }, string>;
    expectType<'1'>(actual);
  }

  /** it should return only the required keys when undefined is excluded */ {
    const actual = _ as Keys<{ foo: string; bar?: string }, string>;
    expectType<'foo'>(actual);
  }

  /** it should return the optional keys when undefined is included */ {
    const actual = _ as Keys<{ foo: string; bar?: string }, string | undefined>;
    expectType<'foo' | 'bar'>(actual);
  }

  /** it should return the overlapping keys of a union of objects */ {
    const actual = _ as Keys<
      { foo: string; bar: number } | { bar: number; baz: string }
    >;
    expectType<'bar'>(actual);
  }

  /** it should return the keys of the tuple when given a tuple and an array */ {
    const actual = _ as Keys<number[] | [number]>;
    expectType<'0'>(actual);
  }

  /** it should return the overlapping keys when given a tuple and an object */ {
    const actual = _ as Keys<{ 0: string; 1: number } | [number]>;
    expectType<'0'>(actual);
  }

  /** it should return the overlapping keys when given a tuple and an object */ {
    const actual = _ as Keys<{ foo: string } | [number]>;
    expectType<never>(actual);
  }

  /** it should return the numeric keys when given an array and an object */ {
    const actual = _ as Keys<{ 0: string; foo: number } | number[]>;
    expectType<'0'>(actual);
  }

  /** it should return {@link Key} when given any */ {
    const actual = _ as Keys<any>;
    expectType<Key>(actual);
  }

  /** it should return {@link Key} when given never */ {
    const actual = _ as Keys<never>;
    expectType<Key>(actual);
  }

  /** it should return never when given unknown */ {
    const actual = _ as Keys<unknown>;
    expectType<never>(actual);
  }

  /** it should return never when given a string */ {
    const actual = _ as Keys<string>;
    expectType<never>(actual);
  }

  /** it should return never when given undefined */ {
    const actual = _ as Keys<undefined>;
    expectType<never>(actual);
  }

  /** it should return never when given null */ {
    const actual = _ as Keys<null>;
    expectType<never>(actual);
  }
}

/** {@link HasKey} */ {
  /** it should return true when the key exists */ {
    const actual = _ as HasKey<{ foo: string }, 'foo'>;
    expectType<true>(actual);
  }

  /** it should return false when the key doesn't exist */ {
    const actual = _ as HasKey<{ foo: string }, 'bar'>;
    expectType<false>(actual);
  }

  /** it should return false when one of the keys doesn't exist */ {
    const actual = _ as HasKey<{ foo: string }, 'foo' | 'bar'>;
    expectType<false>(actual);
  }

  /** it should return false when one key doesn't exist in one of the types */ {
    const actual = _ as HasKey<{ foo: string } | { bar: string }, 'foo'>;
    expectType<false>(actual);
  }
}

/** {@link EvaluateKey} */ {
  /** it should traverse an object */ {
    const actual = _ as EvaluateKey<{ foo: number; bar: string }, 'foo'>;
    expectType<number>(actual);
  }

  /** it should traverse an index signature */ {
    const actual = _ as EvaluateKey<Record<string, number>, string>;
    expectType<number>(actual);
  }

  /** it should traverse a numeric index signature */ {
    const actual = _ as EvaluateKey<Record<number, string>, `${number}`>;
    expectType<string>(actual);
  }

  /** it should traverse an object with numeric keys */ {
    const actual = _ as EvaluateKey<{ 0: number }, '0'>;
    expectType<number>(actual);
  }

  /** it should traverse a tuple */ {
    const actual = _ as EvaluateKey<[boolean, string], '1'>;
    expectType<string>(actual);
  }

  /** it should traverse an array */ {
    const actual = _ as EvaluateKey<boolean[], '42'>;
    expectType<boolean>(actual);
  }

  /** it should handle optional keys */ {
    const actual = _ as EvaluateKey<{ foo?: number }, 'foo'>;
    expectType<number | undefined>(actual);
  }

  /** it should handle optional indexes */ {
    const actual = _ as EvaluateKey<[foo?: number], '0'>;
    expectType<number | undefined>(actual);
  }

  /** it should add undefined if the key is not valid */ {
    const actual = _ as EvaluateKey<{ foo: string }, 'foobar'>;
    expectType<undefined>(actual);
  }

  /** it should evaluate to undefined if the key is out of bounds */ {
    const actual = _ as EvaluateKey<[string], '1'>;
    expectType<undefined>(actual);
  }

  /** it should work on path unions */ {
    const actual = _ as EvaluateKey<
      { foo: number; bar: string },
      'foo' | 'bar'
    >;
    expectType<number | string>(actual);
  }

  /** it should add undefined if one of the keys doesn't exist */ {
    const actual = _ as EvaluateKey<{ foo: number }, 'foo' | 'bar'>;
    expectType<number | undefined>(actual);
  }

  /** it should add null if the type may be null */ {
    const actual = _ as EvaluateKey<null | { foo: string }, 'foo'>;
    expectType<string | null>(actual);
  }

  /** it should add undefined if the type may be undefined */ {
    const actual = _ as EvaluateKey<undefined | { foo: string }, 'foo'>;
    expectType<string | undefined>(actual);
  }

  /** it should add null and undefined if the type may be null or undefined */ {
    const actual = _ as EvaluateKey<null | undefined | { foo: string }, 'foo'>;
    expectType<string | null | undefined>(actual);
  }

  /** it should evaluate to undefined if the type is not traversable */ {
    const actual = _ as EvaluateKey<string, 'foo'>;
    expectType<undefined>(actual);
  }

  /** it should evaluate to undefined if the key is non-numeric */ {
    const actual = _ as EvaluateKey<string[], 'foo'>;
    expectType<undefined>(actual);
  }

  /** it should work on unions of object */ {
    const actual = _ as EvaluateKey<{ foo: number } | { foo: string }, 'foo'>;
    expectType<number | string>(actual);
  }

  /** it should work on unions of object and tuple */ {
    const actual = _ as EvaluateKey<{ 0: number } | [string], '0'>;
    expectType<number | string>(actual);
  }

  /** it should work on unions of object and array */ {
    const actual = _ as EvaluateKey<{ 0: number } | string[], '0'>;
    expectType<number | string>(actual);
  }

  /** it should work on unions of tuple and array */ {
    const actual = _ as EvaluateKey<[number] | string[], '0'>;
    expectType<number | string>(actual);
  }

  /** it should add undefined if the key doesn't exist in one of the types */ {
    const actual = _ as EvaluateKey<{ foo: number } | { bar: string }, 'foo'>;
    expectType<number | undefined>(actual);
  }

  /** it should add undefined if the key is out of bounds in one of the types */ {
    const actual = _ as EvaluateKey<[] | [number], '0'>;
    expectType<number | undefined>(actual);
  }

  /** it should evaluate to any if the type is any */ {
    const actual = _ as EvaluateKey<any, string>;
    expectType<any>(actual);
  }

  /** it should access methods on primitives */ {
    const actual = _ as EvaluateKey<string, 'toString'>;
    expectType<() => string>(actual);
  }

  /** it should access methods on arrays */ {
    const actual = _ as EvaluateKey<number[], 'toString'>;
    expectType<() => string>(actual);
  }

  /** it should access methods on tuples */ {
    const actual = _ as EvaluateKey<[number], 'toString'>;
    expectType<() => string>(actual);
  }
}

/** {@link ValidPathPrefix} */ {
  /** it should return the entire path if it is valid */ {
    const actual = _ as ValidPathPrefix<
      InfiniteType<string>,
      ['foo', 'bar', '0', 'baz', '42']
    >;
    expectType<['foo', 'bar', '0', 'baz', '42']>(actual);
  }

  /** it should return the entire nullable path if it is valid */ {
    const actual = _ as ValidPathPrefix<
      NullableInfiniteType<string>,
      ['foo', 'bar', '0', 'baz', '42']
    >;
    expectType<['foo', 'bar', '0', 'baz', '42']>(actual);
  }

  /** it should return the longest valid prefix */ {
    const actual = _ as ValidPathPrefix<
      InfiniteType<string>,
      ['foo', 'bar', '0', 'ba', '42']
    >;
    expectType<['foo', 'bar', '0']>(actual);
  }

  /** it should return the longest common valid prefix */ {
    const actual = _ as ValidPathPrefix<
      InfiniteType<string> | { foo: string },
      ['foo', 'value']
    >;
    expectType<['foo']>(actual);
  }

  /** it should return an empty tuple when the path is an empty tuple */ {
    const actual = _ as ValidPathPrefix<InfiniteType<string>, []>;
    expectType<[]>(actual);
  }

  /** it should be implemented tail recursively */ {
    const actual = _ as ValidPathPrefix<
      InfiniteType<string>,
      HundredTuple<'foo'>
    >;
    expectType<HundredTuple<'foo'>>(actual);
  }

  /** it should be distributive on path unions */ {
    const actual = _ as ValidPathPrefix<
      InfiniteType<string>,
      ['foo', 'bar', '0', 'ba', '42'] | ['foo', 'ba']
    >;
    expectType<['foo', 'bar', '0'] | ['foo']>(actual);
  }
}

/** {@link HasPath} */ {
  /** it should return true if the path exists */ {
    const actual = _ as HasPath<
      InfiniteType<string>,
      ['foo', 'bar', '0', 'baz', '42']
    >;
    expectType<true>(actual);
  }

  /** it should return false if the path doesn't exist */ {
    const actual = _ as HasPath<
      InfiniteType<string>,
      ['foo', 'bar', '0', 'ba', '42']
    >;
    expectType<false>(actual);
  }

  /** it should return true if the path exist in both types */ {
    const actual = _ as HasPath<
      InfiniteType<string> | { foo: { bar: string } },
      ['foo', 'bar']
    >;
    expectType<true>(actual);
  }

  /** it should return false if the path doesn't exist in both types */ {
    const actual = _ as HasPath<
      InfiniteType<string> | { foo: { bar: string } },
      ['foo', 'value']
    >;
    expectType<false>(actual);
  }

  /** it should return false if either of the paths is invalid */ {
    const actual = _ as HasPath<
      InfiniteType<string>,
      ['foo', 'bar'] | ['foo', 'ba']
    >;
    expectType<false>(actual);
  }

  /** it should return true if both of the path are valid */ {
    const actual = _ as HasPath<
      InfiniteType<string>,
      ['foo', 'baz'] | ['foo', 'bar']
    >;
    expectType<true>(actual);
  }

  /** it should evaluate to true when any is encountered */ {
    const actual = _ as HasPath<{ foo: any }, ['foo', 'bar', 'baz']>;
    expectType<true>(actual);
  }

  /** it should evaluate to false when any is not encountered */ {
    const actual = _ as HasPath<{ foo: any }, ['bar', 'baz']>;
    expectType<false>(actual);
  }
}

/** {@link EvaluatePath} */ {
  /** it should traverse an object */ {
    const actual = _ as EvaluatePath<
      InfiniteType<number>,
      ['foo', 'foo', 'value']
    >;
    expectType<number>(actual);
  }

  /** it should traverse an index signature */ {
    const actual = _ as EvaluatePath<Record<string, number>, [string]>;
    expectType<number>(actual);
  }

  /** it should traverse a numeric index signature */ {
    const actual = _ as EvaluatePath<Record<number, string>, [`${number}`]>;
    expectType<string>(actual);
  }

  /** it should traverse a tuple */ {
    const actual = _ as EvaluatePath<
      InfiniteType<boolean>,
      ['bar', '0', 'value']
    >;
    expectType<boolean>(actual);
  }

  /** it should traverse an array */ {
    const actual = _ as EvaluatePath<
      InfiniteType<boolean>,
      ['baz', '42', 'value']
    >;
    expectType<boolean>(actual);
  }

  /** it should evaluate to never if the path is not valid */ {
    const actual = _ as EvaluatePath<InfiniteType<string>, ['foobar']>;
    expectType<undefined>(actual);
  }

  /** it should be implemented tail recursively */ {
    const actual = _ as EvaluatePath<InfiniteType<string>, HundredTuple<'foo'>>;
    expectType<InfiniteType<string>>(actual);
  }

  /** it should work on path unions */ {
    const actual = _ as EvaluatePath<
      InfiniteType<number>,
      ['foo', 'foo'] | ['foo', 'value']
    >;
    expectType<number | InfiniteType<number>>(actual);
  }

  /** it should add undefined if one of the paths doesn't exist */ {
    const actual = _ as EvaluatePath<
      InfiniteType<number>,
      ['foo', 'value'] | ['foo', 'foobar']
    >;
    expectType<number | undefined>(actual);
  }

  /** it should add null if the path contains a nullable */ {
    const actual = _ as EvaluatePath<
      { foo: null | { bar: string } },
      ['foo', 'bar']
    >;
    expectType<string | null>(actual);
  }

  /** it should add undefined if the path contains an optional */ {
    const actual = _ as EvaluatePath<{ foo?: { bar: string } }, ['foo', 'bar']>;
    expectType<string | undefined>(actual);
  }

  /** it should add undefined if the path contains an undefineable */ {
    const actual = _ as EvaluatePath<
      { foo: undefined | { bar: string } },
      ['foo', 'bar']
    >;
    expectType<string | undefined>(actual);
  }

  /** it should evaluate to undefined if the type is not traversable */ {
    const actual = _ as EvaluatePath<string, ['foo']>;
    expectType<undefined>(actual);
  }

  /** it should work on type unions */ {
    const actual = _ as EvaluatePath<
      InfiniteType<number> | InfiniteType<string>,
      ['foo', 'value']
    >;
    expectType<number | string>(actual);
  }

  /** it should add undefined if the path doesn't exist in one of the types */ {
    const actual = _ as EvaluatePath<
      InfiniteType<number> | Nested<string>,
      ['foo', 'value']
    >;
    expectType<number | undefined>(actual);
  }

  /** it should evaluate to any if the type is any */ {
    const actual = _ as EvaluatePath<any, ['foo']>;
    expectType<any>(actual);
  }

  /** it should evaluate to any if it encounters any */ {
    const actual = _ as EvaluatePath<{ foo: any }, ['foo', 'bar', 'baz']>;
    expectType<any>(actual);
  }

  /** it should not evaluate to any if it doesn't encounter any */ {
    const actual = _ as EvaluatePath<{ foo: any }, ['bar', 'baz']>;
    expectType<undefined>(actual);
  }

  /** it should not create a union which is too complex to represent */ {
    const makeSetter =
      <T>() =>
      <PS extends PathString>(
        _: PS,
        value: EvaluatePath<T, SplitPathString<PS>>,
      ) =>
        value;

    const setter = makeSetter<{ foo: string }>();

    const actual = setter('foo', 'bar');
    expectType<string>(actual);
  }
}


================================================
File: /src/__typetest__/path/eager.test-d.ts
================================================
import { expectType } from 'tsd';

import { ArrayPath, FieldPathValues, Path, PathValue } from '../../types';
import { _, Depth3Type } from '../__fixtures__';

/** {@link Path} */ {
  /** it should evaluate to never for an empty object */ {
    const actual = _ as Path<{}>;
    expectType<never>(actual);
  }

  /** it should evaluate to all paths of an object */ {
    const actual = _ as Path<{ foo: { bar: string; baz: string } }>;
    expectType<'foo' | 'foo.bar' | 'foo.baz'>(actual);
  }

  /** it should include paths through tuples */ {
    const actual = _ as Path<{ foo: [string, number] }>;
    expectType<'foo' | 'foo.0' | 'foo.1'>(actual);
  }

  /** it should include paths through arrays */ {
    const actual = _ as Path<{ foo: string[] }>;
    expectType<'foo' | `foo.${number}`>(actual);
  }

  /** it should be able to avoid self-referencing/recursion, not crashing on self-referencing types. */ {
    type Foo = { foo: Foo };
    const actual = _ as Path<Foo>;
    expectType<'foo'>(actual);
  }

  /** it should not erroneously match subtypes as traversed */ {
    type Foo =
      | {
          foo?: Foo;
          bar?: {
            baz: 1;
          };
        }
      | {};
    const actual = _ as Path<Foo>;
    expectType<'foo' | 'bar' | 'bar.baz'>(actual);
  }
}

/** {@link ArrayPath} */ {
  /** it should evaluate to all paths pointing to a non-primitive array */ {
    const actual = _ as ArrayPath<{
      foo: Array<{ bar: string[]; baz: string[] }>;
    }>;
    expectType<'foo'>(actual);
  }

  /** it should include paths through tuples */ {
    const actual = _ as ArrayPath<{ foo: [object[], object[]] }>;
    expectType<'foo' | 'foo.0' | 'foo.1'>(actual);
  }

  /** it should include paths through arrays */ {
    const actual = _ as ArrayPath<{ foo: string[][][] }>;
    expectType<'foo' | `foo.${number}`>(actual);
  }

  /** it should be able to avoid self-referencing/recursion, not crashing on self-referencing types. */ {
    type Foo = { foo: Foo[] };
    const actual = _ as ArrayPath<Foo>;
    expectType<'foo'>(actual);
  }

  /** it should not erroneously match subtypes as traversed */ {
    type Foo =
      | {
          bar?: {
            baz?: 1;
            fooArr?: Foo[];
          };
        }
      | {};
    const actual = _ as ArrayPath<Foo>;
    expectType<'bar.fooArr'>(actual);
  }
}

/** {@link PathValue} */ {
  /** it should traverse an object */ {
    const actual = _ as PathValue<Depth3Type<number>, 'foo.foo.value'>;
    expectType<number>(actual);
  }

  /** it should traverse a tuple */ {
    const actual = _ as PathValue<Depth3Type<boolean>, 'bar.0.value'>;
    expectType<boolean>(actual);
  }

  /** it should traverse an array */ {
    const actual = _ as PathValue<Depth3Type<boolean>, 'baz.42.value'>;
    expectType<boolean>(actual);
  }
}

/** {@link FieldPathValues} */ {
  /** it should resolve all paths */ {
    const actual = _ as FieldPathValues<
      Depth3Type<string>,
      ['foo.foo.value', 'bar.0.value', 'baz.42.value']
    >;
    expectType<[string, string, string]>(actual);
  }
}


================================================
File: /src/__typetest__/package.json
================================================
{
  "types": "./__fixtures__/dummy.d.ts",
  "tsd": {
    "directory": "."
  }
}


================================================
File: /src/__typetest__/util.test-d.ts
================================================
import { expectAssignable, expectType } from 'tsd';

import { DeepPartial, ExtractObjects, IsAny, IsNever } from '../types';

import { _ } from './__fixtures__';

/** {@link IsAny} */ {
  /** it should evaluate to true for any */ {
    const actual = _ as IsAny<any>;
    expectType<true>(actual);
  }

  /** it should evaluate to false for never */ {
    const actual = _ as IsAny<never>;
    expectType<false>(actual);
  }

  /** it should evaluate to false for unknown */ {
    const actual = _ as IsAny<unknown>;
    expectType<false>(actual);
  }

  /** it should evaluate to false for string */ {
    const actual = _ as IsAny<string>;
    expectType<false>(actual);
  }
}

/** {@link IsNever} */ {
  /** it should evaluate to false for any */ {
    const actual = _ as IsNever<any>;
    expectType<false>(actual);
  }

  /** it should evaluate to true for never */ {
    const actual = _ as IsNever<never>;
    expectType<true>(actual);
  }

  /** it should evaluate to false for unknown */ {
    const actual = _ as IsNever<unknown>;
    expectType<false>(actual);
  }

  /** it should evaluate to false for string */ {
    const actual = _ as IsNever<string>;
    expectType<false>(actual);
  }
}

/** {@link ExtractObjects} */ {
  /** it should extract all objects from a union */ {
    const actual = _ as ExtractObjects<
      { x: string } | { y: number; z: { w: number } } | number | string | null
    >;
    expectType<{ x: string } | { y: number; z: { w: number } }>(actual);
  }
}

/** {@link DeepPartial} */ {
  /** it should make all nested properties optional */ {
    const actual = _ as DeepPartial<{
      x: string;
      y: number;
      z: { w: boolean };
    }>;
    expectType<{ x?: string; y?: number; z?: { w?: boolean } }>(actual);
  }

  /** it should make all nested properties optional for union types */ {
    const actual = _ as DeepPartial<{
      x: string | number;
      y: { a: string | null } | null;
    }>;
    expectType<{
      x?: string | number;
      y?: { a?: string | null } | null;
    }>(actual);
  }

  /** it should make all nested properties optional for intersection types */ {
    const actual = _ as DeepPartial<{
      x: string;
      y: { a: string } & { b: number };
    }>;
    expectType<{
      x?: string;
      y?: { a?: string; b?: number };
    }>(actual);
  }

  /** it should be assignable for types containing unknown */ {
    const actual = _ as { x: unknown };
    expectAssignable<DeepPartial<{ x: unknown }>>(actual);
  }
}


================================================
File: /src/__typetest__/__fixtures__/pathString.ts
================================================
type ConcatTenTimes<T extends string> =
  `${T}.${T}.${T}.${T}.${T}.${T}.${T}.${T}.${T}.${T}`;

export type HundredPathString<T extends string> = ConcatTenTimes<
  ConcatTenTimes<T>
>;


================================================
File: /src/__typetest__/__fixtures__/tuple.ts
================================================
type ConcatTupleTenTimes<T extends unknown[]> = [
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
  ...T,
];

export type HundredTuple<T> = ConcatTupleTenTimes<ConcatTupleTenTimes<[T]>>;


================================================
File: /src/__typetest__/__fixtures__/dummy.d.ts
================================================
/** tsd needs a declarations file to work */


================================================
File: /src/__typetest__/__fixtures__/index.ts
================================================
export * from './pathString';
export * from './traversable';
export * from './tuple';
export * from './type';


================================================
File: /src/__typetest__/__fixtures__/type.ts
================================================
/**
 * tsd expects a value when calling expectType.
 * We're mostly dealing with types though. Therefore,
 * simply export this const and cast it to the expected type.
 * @example
 * ```
 * type Actual = DropLastElement<[0, 1, 2]>;
 * expectType<[0, 1]>(_ as Actual);
 * ```
 */
export declare const _: never;


================================================
File: /src/__typetest__/__fixtures__/traversable.ts
================================================
interface Base<T, V> {
  foo: T;
  bar: [T];
  baz: Array<T>;
  value: V;
}

export type InfiniteType<T> = Base<InfiniteType<T>, T>;

export type NullableInfiniteType<T> =
  | null
  | undefined
  | Partial<Base<NullableInfiniteType<T>, T>>;

export type Depth3Type<T> = Base<Base<Base<never, T>, T>, T>;

export interface Nested<T> {
  nested: T;
}


================================================
File: /src/useController.ts
================================================
import React from 'react';

import getEventValue from './logic/getEventValue';
import isNameInFieldArray from './logic/isNameInFieldArray';
import cloneObject from './utils/cloneObject';
import get from './utils/get';
import isBoolean from './utils/isBoolean';
import isUndefined from './utils/isUndefined';
import set from './utils/set';
import { EVENTS } from './constants';
import {
  ControllerFieldState,
  Field,
  FieldPath,
  FieldPathValue,
  FieldValues,
  InternalFieldName,
  UseControllerProps,
  UseControllerReturn,
} from './types';
import { useFormContext } from './useFormContext';
import { useFormState } from './useFormState';
import { useWatch } from './useWatch';

/**
 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns field properties, field and form state. {@link UseControllerReturn}
 *
 * @example
 * ```tsx
 * function Input(props) {
 *   const { field, fieldState, formState } = useController(props);
 *   return (
 *     <div>
 *       <input {...field} placeholder={props.name} />
 *       <p>{fieldState.isTouched && "Touched"}</p>
 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *     </div>
 *   );
 * }
 * ```
 */
export function useController<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  props: UseControllerProps<TFieldValues, TName>,
): UseControllerReturn<TFieldValues, TName> {
  const methods = useFormContext<TFieldValues>();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(
      control._formValues,
      name,
      get(control._defaultValues, name, props.defaultValue),
    ),
    exact: true,
  }) as FieldPathValue<TFieldValues, TName>;
  const formState = useFormState({
    control,
    name,
    exact: true,
  });

  const _registerProps = React.useRef(
    control.register(name, {
      ...props.rules,
      value,
      ...(isBoolean(props.disabled) ? { disabled: props.disabled } : {}),
    }),
  );

  const fieldState = React.useMemo(
    () =>
      Object.defineProperties(
        {},
        {
          invalid: {
            enumerable: true,
            get: () => !!get(formState.errors, name),
          },
          isDirty: {
            enumerable: true,
            get: () => !!get(formState.dirtyFields, name),
          },
          isTouched: {
            enumerable: true,
            get: () => !!get(formState.touchedFields, name),
          },
          isValidating: {
            enumerable: true,
            get: () => !!get(formState.validatingFields, name),
          },
          error: {
            enumerable: true,
            get: () => get(formState.errors, name),
          },
        },
      ) as ControllerFieldState,
    [formState, name],
  );

  const field = React.useMemo(
    () => ({
      name,
      value,
      ...(isBoolean(disabled) || formState.disabled
        ? { disabled: formState.disabled || disabled }
        : {}),
      onChange: (event: any) =>
        _registerProps.current.onChange({
          target: {
            value: getEventValue(event),
            name: name as InternalFieldName,
          },
          type: EVENTS.CHANGE,
        }),
      onBlur: () =>
        _registerProps.current.onBlur({
          target: {
            value: get(control._formValues, name),
            name: name as InternalFieldName,
          },
          type: EVENTS.BLUR,
        }),
      ref: (elm: any) => {
        const field = get(control._fields, name);

        if (field && elm) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message: string) =>
              elm.setCustomValidity(message),
            reportValidity: () => elm.reportValidity(),
          };
        }
      },
    }),
    [
      name,
      control._formValues,
      disabled,
      formState.disabled,
      value,
      control._fields,
    ],
  );

  React.useEffect(() => {
    const _shouldUnregisterField =
      control._options.shouldUnregister || shouldUnregister;

    const updateMounted = (name: InternalFieldName, value: boolean) => {
      const field: Field = get(control._fields, name);

      if (field && field._f) {
        field._f.mount = value;
      }
    };

    updateMounted(name, true);

    if (_shouldUnregisterField) {
      const value = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value);
      }
    }

    !isArrayField && control.register(name);

    return () => {
      (
        isArrayField
          ? _shouldUnregisterField && !control._state.action
          : _shouldUnregisterField
      )
        ? control.unregister(name)
        : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);

  React.useEffect(() => {
    if (isBoolean(disabled) && get(control._fields, name)) {
      control._updateDisabledField({
        disabled,
        fields: control._fields,
        name,
        value: get(control._fields, name)._f.value,
      });
    }
  }, [disabled, name, control]);

  return React.useMemo(
    () => ({
      field,
      formState,
      fieldState,
    }),
    [field, formState, fieldState],
  );
}


================================================
File: /src/__tests__/useForm/resetField.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';

import { useForm } from '../../useForm';

describe('resetField', () => {
  it('should reset input value', () => {
    const App = () => {
      const { register, resetField } = useForm({
        defaultValues: {
          test: 'test',
        },
      });

      return (
        <form>
          <input {...register('test')} />
          <button
            type={'button'}
            onClick={() => {
              resetField('test');
            }}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1234',
      },
    });

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      '1234',
    );

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );
  });

  it('should reset input touched field state', async () => {
    const App = () => {
      const {
        register,
        resetField,
        formState: { touchedFields },
      } = useForm({
        defaultValues: {
          test: 'test',
        },
      });

      return (
        <form>
          <input {...register('test')} />
          <p>{touchedFields.test ? 'touched' : 'noTouched'}</p>
          <button
            type={'button'}
            onClick={() => {
              resetField('test');
            }}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.focus(screen.getByRole('textbox'));

    fireEvent.blur(screen.getByRole('textbox'));

    expect(await screen.findByText('touched')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('noTouched')).toBeVisible();
  });

  it('should reset input dirty field and dirty state', async () => {
    const App = () => {
      const {
        register,
        resetField,
        formState: { dirtyFields, isDirty },
      } = useForm({
        defaultValues: {
          test: 'test',
        },
      });

      return (
        <form>
          <input {...register('test')} />
          <p>{dirtyFields.test ? 'dirty' : 'notDirty'}</p>
          <p>{isDirty ? 'formDirty' : 'formNotDirty'}</p>
          <button
            type={'button'}
            onClick={() => {
              resetField('test');
            }}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1234',
      },
    });

    expect(await screen.findByText('dirty')).toBeVisible();
    expect(screen.getByText('formDirty')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('notDirty')).toBeVisible();
    expect(screen.getByText('formNotDirty')).toBeVisible();
  });

  it('should reset input error field and isValid state', async () => {
    const App = () => {
      const {
        register,
        resetField,
        formState: { errors, isValid },
      } = useForm({
        defaultValues: {
          test: 'test',
        },
        mode: 'onChange',
      });

      return (
        <form>
          <input {...register('test', { maxLength: 4 })} />
          <p>{errors.test ? 'error' : 'noError'}</p>
          <p>{isValid ? 'valid' : 'NotValid'}</p>
          <button
            type={'button'}
            onClick={() => {
              resetField('test');
            }}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    expect(await screen.findByText('valid')).toBeVisible();
    expect(screen.getByText('noError')).toBeVisible();

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test12345',
      },
    });

    expect(await screen.findByText('NotValid')).toBeVisible();
    expect(screen.getByText('error')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('valid')).toBeVisible();
    expect(screen.getByText('noError')).toBeVisible();
  });

  it('should reset input file to empty string only', () => {
    const getValuesFn = jest.fn();

    const App = () => {
      const { register, resetField, getValues } = useForm({
        defaultValues: {
          test: '',
        },
      });

      return (
        <form>
          <input type={'file'} {...register('test')} />
          <button
            type={'button'}
            onClick={() => {
              resetField('test', { defaultValue: '' });
            }}
          >
            reset
          </button>
          <button
            type={'button'}
            onClick={() => {
              getValuesFn(getValues());
            }}
          >
            getValues
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'getValues' }));

    expect(getValuesFn).toBeCalledWith({ test: '' });

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));

    expect(getValuesFn).toBeCalledWith({ test: '' });
  });

  describe('when provided with options', () => {
    it('should update input value and its defaultValue', () => {
      const App = () => {
        const { register, resetField } = useForm({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <form>
            <input {...register('test')} />
            <button
              type={'button'}
              onClick={() => {
                resetField('test', {
                  defaultValue: 'test1234',
                });
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '1234',
        },
      });

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '1234',
      );

      fireEvent.click(screen.getByRole('button'));

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        'test1234',
      );
    });

    it('should keep touched field state', async () => {
      const App = () => {
        const {
          register,
          resetField,
          formState: { touchedFields },
        } = useForm({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <form>
            <input {...register('test')} />
            <p>{touchedFields.test ? 'touched' : 'noTouched'}</p>
            <button
              type={'button'}
              onClick={() => {
                resetField('test', { keepTouched: true });
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      fireEvent.focus(screen.getByRole('textbox'));

      fireEvent.blur(screen.getByRole('textbox'));

      expect(await screen.findByText('touched')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('touched')).toBeVisible();
    });

    it('should keep dirty field and isDirty state', async () => {
      const App = () => {
        const {
          register,
          resetField,
          formState: { dirtyFields, isDirty },
        } = useForm({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <form>
            <input {...register('test')} />
            <p>{dirtyFields.test ? 'dirty' : 'notDirty'}</p>
            <p>{isDirty ? 'formDirty' : 'formNotDirty'}</p>
            <button
              type={'button'}
              onClick={() => {
                resetField('test', { keepDirty: true });
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '1234',
        },
      });

      expect(await screen.findByText('dirty')).toBeVisible();
      expect(screen.getByText('formDirty')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('dirty')).toBeVisible();
      expect(screen.getByText('formDirty')).toBeVisible();
    });

    it('should skip reset error field and isValid state', async () => {
      const App = () => {
        const {
          register,
          resetField,
          formState: { errors, isValid },
        } = useForm({
          defaultValues: {
            test: 'test',
          },
          mode: 'onChange',
        });

        return (
          <form>
            <input {...register('test', { maxLength: 4 })} />
            <p>{errors.test ? 'error' : 'noError'}</p>
            <p>{isValid ? 'valid' : 'NotValid'}</p>
            <button
              type={'button'}
              onClick={() => {
                resetField('test', { keepError: true });
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      expect(await screen.findByText('valid')).toBeVisible();
      expect(screen.getByText('noError')).toBeVisible();

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'test12345',
        },
      });

      expect(await screen.findByText('NotValid')).toBeVisible();
      expect(screen.getByText('error')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('NotValid')).toBeVisible();
      expect(screen.getByText('error')).toBeVisible();
    });

    it('should work with objects as defaultValue', async () => {
      const App = () => {
        const {
          register,
          resetField,
          formState: { isDirty },
        } = useForm({
          defaultValues: {
            nestedObjectTest: {
              test: 'test',
            },
          },
          mode: 'onChange',
        });

        return (
          <form>
            <input {...register('nestedObjectTest.test', { maxLength: 4 })} />
            <p>{isDirty ? 'isDirty' : 'isNotDirty'}</p>
            <button
              type={'button'}
              onClick={() => {
                resetField('nestedObjectTest', {
                  defaultValue: { test: 'test2' },
                });
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      expect(await screen.findByText('isNotDirty')).toBeVisible();

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'abcd',
        },
      });

      expect(await screen.findByText('isDirty')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '1234',
        },
      });

      expect(await screen.findByText('isDirty')).toBeVisible();
    });
  });
});


================================================
File: /src/__tests__/useForm/getValues.test.tsx
================================================
import React from 'react';
import {
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { Controller } from '../../controller';
import { useForm } from '../../useForm';
import { FormProvider, useFormContext } from '../../useFormContext';
import { useFormState } from '../../useFormState';

describe('getValues', () => {
  it('should return defaultValues before inputs mounted', () => {
    let values;

    const Component = () => {
      const { getValues } = useForm({
        defaultValues: {
          test: 'test',
        },
      });

      values = getValues();

      return null;
    };

    const { rerender } = render(<Component />);

    expect(values).toEqual({
      test: 'test',
    });

    rerender(<Component />);

    expect(values).toEqual({
      test: 'test',
    });
  });

  it('should call getFieldsValues and return all values', () => {
    const { result } = renderHook(() => useForm<{ test: string }>());
    result.current.register('test');
    result.current.setValue('test', 'test');
    expect(result.current.getValues()).toEqual({ test: 'test' });
  });

  it('should get individual field value', () => {
    const { result } = renderHook(() =>
      useForm<{ test: string }>({
        defaultValues: {
          test: '123',
        },
      }),
    );
    result.current.register('test');
    expect(result.current.getValues('test')).toEqual('123');
  });

  it('should get all field values', () => {
    const values = {
      test: 'test',
      test1: 'test1',
      test2: 'test2',
    };
    const { result } = renderHook(() =>
      useForm<{ test: string; test1: string; test2: string }>({
        defaultValues: values,
      }),
    );
    result.current.register('test');
    result.current.register('test1');
    result.current.register('test2');

    result.current.setValue('test', 'test');
    result.current.setValue('test1', 'test1');
    result.current.setValue('test2', 'test2');

    expect(result.current.getValues(['test', 'test1', 'test2'])).toEqual([
      'test',
      'test1',
      'test2',
    ]);
  });

  it('should get undefined when field not found', () => {
    const { result } = renderHook(() => useForm());

    expect(result.current.getValues('test')).toEqual(undefined);
  });

  it('should get value from shallowFieldsStateRef by name', () => {
    const { result, unmount } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');
    result.current.setValue('test', 'test');

    unmount();

    expect(result.current.getValues('test')).toEqual('test');
  });

  it('should get value from shallowFieldsStateRef by array', () => {
    const { result, unmount } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');
    result.current.setValue('test', 'test');

    unmount();

    expect(result.current.getValues(['test'])).toEqual(['test']);
  });

  it('should get value from shallowFieldsStateRef', () => {
    const { result, unmount } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');
    result.current.setValue('test', 'test');

    unmount();

    expect(result.current.getValues()).toEqual({
      test: 'test',
    });
  });

  it('should get value from default value by name when field is not registered', () => {
    const { result } = renderHook(() =>
      useForm({
        defaultValues: {
          test: 'default',
        },
      }),
    );

    expect(result.current.getValues('test')).toEqual('default');
  });

  it('should get value from default value by array when field is not registered', () => {
    const { result } = renderHook(() =>
      useForm({
        defaultValues: {
          test: 'default',
        },
      }),
    );

    expect(result.current.getValues(['test'])).toEqual(['default']);
  });

  it('should not get value from default value when field is not registered', () => {
    const { result } = renderHook(() =>
      useForm({
        defaultValues: {
          test: 'default',
        },
      }),
    );

    expect(result.current.getValues()).toEqual({
      test: 'default',
    });
  });

  it('should return defaultValues when inputs are not registered', () => {
    let data: unknown;

    const Component = () => {
      const { getValues } = useForm({
        defaultValues: {
          test: 'test',
        },
      });

      if (!data) {
        data = getValues();
      }

      return null;
    };

    render(<Component />);

    expect(data).toEqual({ test: 'test' });
  });

  it('should return defaultValues deep merge with form values', async () => {
    let data: unknown;

    const Component = () => {
      const { getValues, register } = useForm({
        defaultValues: {
          test: {
            firstName: 'test',
            lastName: 'test',
            time: new Date('1999-09-09'),
            file: new File([''], 'filename'),
          },
        },
      });

      if (!data) {
        data = getValues();
      }

      return (
        <div>
          <input {...register('test.firstName')} />
          <button
            onClick={() => {
              data = getValues();
            }}
          >
            getValues
          </button>
        </div>
      );
    };

    render(<Component />);

    expect(data).toEqual({
      test: {
        firstName: 'test',
        lastName: 'test',
        time: new Date('1999-09-09'),
        file: new File([''], 'filename'),
      },
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1234',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(data).toMatchObject({
      test: {
        firstName: '1234',
        lastName: 'test',
      },
    });
  });

  it('should return mounted input value after async reset', async () => {
    let updatedValue: unknown;

    type FormValues = {
      firstName: string;
    };

    function Form() {
      const { handleSubmit, reset, getValues } = useFormContext();
      const { isDirty, isValid } = useFormState();

      return (
        <form
          onSubmit={handleSubmit(async (data) => {
            await Promise.resolve();
            reset(data);
          })}
        >
          <button
            type={'button'}
            onClick={() => {
              updatedValue = getValues();
            }}
          >
            getValues
          </button>
          <button type="submit" disabled={!isDirty || !isValid}>
            submit
          </button>

          <Controller
            name="firstName"
            rules={{ required: true }}
            render={({ field }) => <input {...field} />}
          />
        </form>
      );
    }

    function App() {
      const methods = useForm<FormValues>({
        defaultValues: {
          firstName: 'test',
        },
      });

      return (
        <FormProvider {...methods}>
          <Form />
        </FormProvider>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test1' },
    });

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(screen.getByRole('button', { name: 'submit' })).toBeDisabled();

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test2' },
    });

    await waitFor(() =>
      expect(screen.getByRole('button', { name: 'submit' })).not.toBeDisabled(),
    );

    fireEvent.click(screen.getByRole('button', { name: 'getValues' }));

    expect(updatedValue).toEqual({
      firstName: 'test2',
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test3' },
    });

    expect(screen.getByRole('button', { name: 'submit' })).not.toBeDisabled();
  });
});


================================================
File: /src/__tests__/useForm/trigger.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Control, FieldPath } from '../../types';
import { useController } from '../../useController';
import { useForm } from '../../useForm';
import { FormProvider } from '../../useFormContext';
import { useFormState } from '../../useFormState';
import noop from '../../utils/noop';

describe('trigger', () => {
  it('should remove all errors before set new errors when trigger entire form', async () => {
    const Component = () => {
      const [show, setShow] = React.useState(true);
      const {
        register,
        unregister,
        trigger,
        formState: { errors },
      } = useForm<{
        test: string;
      }>();

      return (
        <div>
          {show && <input {...register('test', { required: true })} />}
          <button type={'button'} onClick={() => trigger()}>
            trigger
          </button>
          <button
            type={'button'}
            onClick={() => {
              setShow(false);
              unregister('test');
            }}
          >
            toggle
          </button>
          {errors.test && <span>error</span>}
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    expect(await screen.findByText('error')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    await waitFor(() =>
      expect(screen.queryByText('error')).not.toBeInTheDocument(),
    );
  });

  it('should return empty errors when field is found and validation pass', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());
    const { errors } = result.current.formState;

    result.current.register('test');

    await act(async () => {
      await result.current.trigger('test');
    });

    await act(async () => {
      await expect(errors).toEqual({});
    });
  });

  it('should update value when value is supplied', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    const { errors } = result.current.formState;

    result.current.register('test', { required: true });

    result.current.setValue('test', 'abc');

    await act(async () => {
      await result.current.trigger('test');
    });

    expect(errors).toEqual({});
  });

  it('should trigger multiple fields validation', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; test1: string }>({
        mode: VALIDATION_MODE.onChange,
      }),
    );

    result.current.formState.errors;

    result.current.register('test', { required: 'required' });
    result.current.register('test1', { required: 'required' });

    await act(async () => {
      await result.current.trigger(['test', 'test1']);
    });

    expect(result.current.formState.errors?.test?.message).toBe('required');
    expect(result.current.formState.errors?.test1?.message).toBe('required');
  });

  describe('with schema', () => {
    it('should return the error with single field validation', async () => {
      const resolver = async (data: any) => {
        return {
          values: data,
          errors: {
            test: {
              type: 'test',
            },
          },
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver,
        }),
      );

      result.current.formState.errors;

      result.current.register('test', { required: true });

      await act(async () => {
        await result.current.trigger('test');
      });
      expect(result.current.formState.errors).toEqual({
        test: { type: 'test' },
      });
    });

    it('should return the status of the requested field with single field validation', async () => {
      const resolver = async (data: any) => {
        return {
          values: data,
          errors: {
            test2: {
              type: 'test',
            },
          },
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test1: string; test2: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver,
        }),
      );

      result.current.formState.errors;

      result.current.register('test1', { required: false });
      result.current.register('test2', { required: true });

      await act(async () =>
        expect(await result.current.trigger('test2')).toBeFalsy(),
      );

      expect(result.current.formState.errors).toEqual({
        test2: {
          type: 'test',
        },
      });
    });

    it('should not trigger any error when schema validation result not found', async () => {
      const { result } = renderHook(() =>
        useForm<{ test: string; test1: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver: async () => {
            return {
              values: {},
              errors: {
                test: {
                  type: 'test',
                },
              },
            };
          },
        }),
      );

      result.current.register('test', { required: true });

      await act(async () => {
        await result.current.trigger('test1');
      });

      expect(result.current.formState.errors).toEqual({});
    });

    it('should support array of fields for schema validation', async () => {
      const resolver = async (data: any) => {
        return {
          values: data,
          errors: {
            test1: {
              type: 'test1',
            },
            test: {
              type: 'test',
            },
          },
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test: string; test1: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver,
        }),
      );

      result.current.formState.errors;

      result.current.register('test', { required: true });

      await act(async () => {
        await result.current.trigger(['test', 'test1']);
      });

      expect(result.current.formState.errors).toEqual({
        test1: {
          type: 'test1',
        },
        test: {
          type: 'test',
        },
      });
    });

    it('should return the status of the requested fields with array of fields for validation', async () => {
      const { result } = renderHook(() =>
        useForm<{ test1: string; test2: string; test3: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver: async () => {
            return {
              values: {},
              errors: {
                test3: {
                  type: 'test',
                },
              },
            };
          },
        }),
      );

      const { errors } = result.current.formState;

      result.current.register('test1', { required: false });
      result.current.register('test2', { required: false });
      result.current.register('test3', { required: true });

      await act(async () => {
        await result.current.trigger(['test1', 'test2']);
      });

      await act(async () => {
        expect(errors).toEqual({});
      });

      await act(async () => {
        await result.current.trigger(['test3']);
      });

      await act(async () => {
        expect(result.current.formState.errors).toEqual({
          test3: {
            type: 'test',
          },
        });
      });
    });

    it('should validate all fields when pass with undefined', async () => {
      const resolver = async (data: any) => {
        return {
          values: data,
          errors: {
            test1: {
              type: 'test1',
            },
            test: {
              type: 'test',
            },
          },
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test1: string; test: string }>({
          mode: VALIDATION_MODE.onChange,
          resolver,
        }),
      );

      result.current.formState.errors;

      result.current.register('test', { required: true });
      result.current.register('test1', { required: true });

      await act(async () => {
        await result.current.trigger();
      });

      expect(result.current.formState.errors).toEqual({
        test1: {
          type: 'test1',
        },
        test: {
          type: 'test',
        },
      });
    });

    it('should update isValid with validation result at form level', async () => {
      const App = () => {
        const {
          register,
          formState: { isValid },
          trigger,
        } = useForm<{ test: string; test1: string }>({
          defaultValues: {
            test: '',
          },
          resolver: async (data) => {
            if (data.test && data.test1) {
              return {
                errors: {},
                values: {
                  test: '1',
                  test1: '2',
                },
              };
            } else {
              return {
                errors: {
                  test: {
                    message: 'test',
                    type: 'test',
                  },
                },
                values: {},
              };
            }
          },
        });

        return (
          <div>
            {isValid ? 'yes' : 'no'}
            <input {...register('test')} />
            <input {...register('test1')} />
            <button
              onClick={() => {
                trigger('test');
              }}
            >
              trigger1
            </button>
            <button
              onClick={() => {
                trigger('test1');
              }}
            >
              trigger2
            </button>
          </div>
        );
      };

      render(<App />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: 'test',
        },
      });

      fireEvent.click(screen.getByRole('button', { name: 'trigger1' }));

      expect(await screen.findByText('no')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: 'test',
        },
      });

      fireEvent.click(screen.getByRole('button', { name: 'trigger2' }));

      expect(await screen.findByText('yes')).toBeVisible();
    });

    it('should update isValid for the entire useForm scope', async () => {
      const InputA = () => {
        const { isValid } = useFormState({ name: 'name' });

        return <p>{isValid ? 'test: valid' : 'test: invalid'}</p>;
      };

      const InputB = () => {
        const { isValid } = useFormState({ name: 'email' });

        return <p>{isValid ? 'test1: valid' : 'test1: invalid'}</p>;
      };

      function App() {
        const methods = useForm({
          resolver: async (data) => {
            if (data.test && data.test1) {
              return {
                errors: {},
                values: {
                  test: '1',
                  test1: '2',
                },
              };
            } else {
              return {
                errors: {
                  test: {
                    message: 'test',
                    type: 'test',
                  },
                },
                values: {},
              };
            }
          },
          mode: 'onChange',
        });

        return (
          <FormProvider {...methods}>
            <form>
              <input
                onChange={(e) =>
                  methods.setValue('test', e.target.value, {
                    shouldValidate: true,
                  })
                }
              />
              <InputA />
              <input
                onChange={(e) =>
                  methods.setValue('test1', e.target.value, {
                    shouldValidate: true,
                  })
                }
              />
              <InputB />
            </form>
          </FormProvider>
        );
      }

      render(<App />);

      expect(await screen.findByText('test: invalid')).toBeVisible();
      expect(screen.getByText('test1: invalid')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: { value: 'test' },
      });

      expect(await screen.findByText('test: invalid')).toBeVisible();
      expect(screen.getByText('test1: invalid')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: { value: 'test' },
      });

      expect(await screen.findByText('test: valid')).toBeVisible();
      expect(screen.getByText('test1: valid')).toBeVisible();
    });
  });

  it('should return the status of the requested fields with array of fields for validation', async () => {
    const resolver = async (data: any) => {
      return {
        values: data,
        errors: { test3: 'test3' },
      };
    };

    const { result } = renderHook(() =>
      useForm<{ test1: string; test2: string; test3: string }>({
        mode: VALIDATION_MODE.onChange,
        resolver,
      }),
    );

    result.current.register('test1', { required: false });
    result.current.register('test2', { required: false });
    result.current.register('test3', { required: true });

    await act(async () =>
      expect(await result.current.trigger(['test1', 'test2'])).toBeTruthy(),
    );

    await act(async () =>
      expect(await result.current.trigger(['test3', 'test2'])).toBeFalsy(),
    );

    await act(async () =>
      expect(await result.current.trigger(['test3'])).toBeFalsy(),
    );

    await act(async () =>
      expect(await result.current.trigger(['test1'])).toBeTruthy(),
    );

    await act(async () => expect(await result.current.trigger()).toBeFalsy());
  });

  it('should return true when field is found and validation pass', async () => {
    const App = () => {
      const {
        register,
        trigger,
        formState: { isValid },
      } = useForm();

      React.useEffect(() => {
        register('test');
      }, [register]);

      return (
        <div>
          <p>{isValid ? 'yes' : 'no'}</p>
          <button
            onClick={() => {
              trigger('test');
            }}
          >
            trigger
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('yes')).toBeVisible();
  });

  it('should remove all errors before set new errors when trigger entire form', async () => {
    const Component = () => {
      const [show, setShow] = React.useState(true);
      const {
        register,
        trigger,
        formState: { errors },
      } = useForm<{
        test: string;
      }>({
        shouldUnregister: true,
      });

      return (
        <div>
          {show && <input {...register('test', { required: true })} />}
          <button type={'button'} onClick={() => trigger()}>
            trigger
          </button>
          <button type={'button'} onClick={() => setShow(false)}>
            toggle
          </button>
          {errors.test && <span>error</span>}
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    expect(await screen.findByText('error')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    await waitFor(() =>
      expect(screen.queryByText('error')).not.toBeInTheDocument(),
    );
  });

  it('should focus on errored input with build in validation', async () => {
    const Component = () => {
      const { register, trigger } = useForm<{
        test: string;
      }>();

      return (
        <>
          <input
            {...register('test', { required: true })}
            placeholder={'test'}
          />
          <button onClick={() => trigger('test', { shouldFocus: true })}>
            trigger
          </button>
        </>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(document.activeElement).toEqual(
        screen.getByPlaceholderText('test'),
      );
    });
  });

  it('should focus on errored input with schema validation', async () => {
    const Component = () => {
      const { register, trigger } = useForm<{
        test: string;
      }>({
        resolver: () => ({
          values: {},
          errors: {
            test: {
              type: 'test',
            },
          },
        }),
      });

      return (
        <>
          <input {...register('test')} placeholder={'test'} />
          <button onClick={() => trigger('test', { shouldFocus: true })}>
            trigger
          </button>
        </>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(document.activeElement).toEqual(
        screen.getByPlaceholderText('test'),
      );
    });
  });

  it('should focus on first errored input', async () => {
    const Component = () => {
      const { register, trigger } = useForm<{
        test: string;
        test2: string;
      }>();

      return (
        <>
          <input
            {...register('test', { required: true })}
            placeholder={'test'}
          />
          <input
            {...register('test2', { required: true })}
            placeholder={'test2'}
          />
          <button onClick={() => trigger(undefined, { shouldFocus: true })}>
            trigger
          </button>
        </>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(document.activeElement).toEqual(
        screen.getByPlaceholderText('test'),
      );
    });
  });

  it('should return isValid for the entire form', async () => {
    const App = () => {
      const [isValid, setIsValid] = React.useState(true);
      const { register, trigger, formState } = useForm();

      formState.isValid;

      return (
        <div>
          <input
            {...register('firstName', { required: true })}
            placeholder={'firstName'}
          />
          <input
            {...register('lastName', { required: true })}
            placeholder={'lastName'}
          />
          <button
            onClick={async () => {
              setIsValid(await trigger());
            }}
          >
            trigger
          </button>
          <p>{isValid ? 'true' : 'false'}</p>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('false')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: {
        value: '1234',
      },
    });
    fireEvent.change(screen.getByPlaceholderText('lastName'), {
      target: {
        value: '1234',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('true')).toBeVisible();
  });

  it('should return correct valid state when trigger the entire form with build in validation', async () => {
    let isValid;

    function App() {
      const { register, trigger } = useForm();

      const onTrigger = async () => {
        isValid = await trigger();
      };

      return (
        <form>
          <input
            {...register('firstName', { required: true })}
            placeholder="First name"
          />
          <input
            {...register('last.name', { required: true })}
            placeholder="Last name"
          />

          <input type="button" onClick={onTrigger} value="trigger" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(isValid).toBeFalsy();
  });

  it('should be able to trigger an object of fields', async () => {
    let isValid;

    function App() {
      const {
        register,
        trigger,
        formState: { errors },
      } = useForm({
        defaultValues: {
          test: {
            firstName: '',
            lastName: '',
          },
        },
      });

      const onTrigger = async () => {
        isValid = await trigger('test');
      };

      return (
        <form>
          <input
            {...register('test.firstName', { required: true })}
            placeholder="First name"
          />
          {errors?.test?.firstName && <p>firstName</p>}

          <input
            {...register('test.lastName', { required: true })}
            placeholder="Last name"
          />
          {errors?.test?.lastName && <p>lastName</p>}

          <input type="button" onClick={onTrigger} value="trigger" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(isValid).toBeFalsy();

    expect(await screen.findByText('firstName')).toBeVisible();
    expect(screen.getByText('lastName')).toBeVisible();
  });

  it('should only trigger render on targeted input', async () => {
    type FormValue = {
      x: string;
      y: string;
    };

    function Input({
      name,
      control,
    }: {
      name: FieldPath<FormValue>;
      control: Control<FormValue>;
    }) {
      const renderCount = React.useRef(0);
      renderCount.current += 1;

      const {
        fieldState: { error },
      } = useController({
        name,
        control,
        rules: {
          required: true,
        },
      });

      error;

      return <p>{renderCount.current}</p>;
    }

    function App() {
      const { handleSubmit, control, trigger } = useForm<FormValue>();
      const onSubmit = noop;

      return (
        <div>
          <form onSubmit={handleSubmit(onSubmit)}>
            <Input name="x" control={control} />
            <Input name="y" control={control} />

            <button type="button" onClick={() => trigger('x')}>
              Trigger Validation on X
            </button>
          </form>
        </div>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('1')).toBeVisible();
    expect(screen.getByText('1')).toBeVisible();
  });

  it('should skip additional validation when input validation already failed', async () => {
    let count = 0;

    const App = () => {
      const {
        register,
        trigger,
        formState: { isValid },
      } = useForm({
        mode: 'onChange',
      });
      const validate = () => {
        count++;
        return false;
      };

      return (
        <form>
          <p>{isValid ? 'valid' : 'invalid'}</p>
          <input
            {...register('test', {
              validate,
            })}
          />
          <button onClick={() => trigger('test')} type={'button'}>
            submit
          </button>
        </form>
      );
    };

    render(<App />);

    expect(await screen.findByText('invalid')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(count).toEqual(2);
  });
});


================================================
File: /src/__tests__/useForm/handleSubmit.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import isFunction from '../../utils/isFunction';
import noop from '../../utils/noop';

describe('handleSubmit', () => {
  it('should invoke the callback when validation pass', async () => {
    const { result } = renderHook(() => useForm());
    const callback = jest.fn();

    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
    expect(callback).toBeCalled();
  });

  it('should pass default value', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; deep: { nested: string; values: string } }>({
        mode: VALIDATION_MODE.onSubmit,
        defaultValues: {
          test: 'data',
          deep: {
            values: '5',
          },
        },
      }),
    );

    result.current.register('test');
    result.current.register('deep.nested');
    result.current.register('deep.values');

    await act(async () => {
      await result.current.handleSubmit((data: any) => {
        expect(data).toEqual({
          test: 'data',
          deep: {
            nested: undefined,
            values: '5',
          },
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should not pass default value when field is not registered', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; deep: { nested: string; values: string } }>({
        mode: VALIDATION_MODE.onSubmit,
        defaultValues: {
          test: 'data',
          deep: {
            values: '5',
          },
        },
      }),
    );

    await act(async () => {
      await result.current.handleSubmit((data: any) => {
        expect(data).toEqual({
          test: 'data',
          deep: {
            values: '5',
          },
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should not provide reference to _formValues as data', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; deep: { values: string } }>({
        mode: VALIDATION_MODE.onSubmit,
        defaultValues: {
          test: 'data',
          deep: {
            values: '5',
          },
        },
      }),
    );

    await act(async () => {
      await result.current.handleSubmit((data: any) => {
        data.deep.values = '12';
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    await act(async () => {
      await result.current.handleSubmit((data: any) => {
        expect(data.deep).toEqual({ values: '5' });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should not invoke callback when there are errors', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    result.current.register('test', { required: true });

    const callback = jest.fn();

    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
    expect(callback).not.toBeCalled();
  });

  it('should not focus if errors is exist', async () => {
    const focus = jest.fn();
    const { result } = renderHook(() => useForm<{ test: string }>());
    const { ref } = result.current.register('test', { required: true });

    result.current.formState;

    isFunction(ref) &&
      ref({
        focus,
      });

    const callback = jest.fn();
    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(callback).not.toBeCalled();
    expect(focus).toBeCalled();
    expect(result.current.control._formState.errors?.test?.type).toBe(
      'required',
    );
  });

  it('should not focus if shouldFocusError is false', async () => {
    const mockFocus = jest.spyOn(HTMLInputElement.prototype, 'focus');

    const { result } = renderHook(() =>
      useForm<{ test: string }>({ shouldFocusError: false }),
    );

    result.current.register('test', { required: true });
    result.current.formState;

    const callback = jest.fn();
    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(callback).not.toBeCalled();
    expect(mockFocus).not.toBeCalled();
    expect(result.current.control._formState.errors?.test?.type).toBe(
      'required',
    );
  });

  it('should submit form data when inputs are removed', async () => {
    const { result, unmount } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');
    result.current.setValue('test', 'test');

    unmount();

    await act(async () =>
      result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: 'test',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent),
    );
  });

  it('should invoke onSubmit callback and reset nested errors when submit with valid form values', async () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useForm<{
        test: { firstName: string; lastName: string }[];
      }>(),
    );
    const validate = () => {
      return !!result.current
        .getValues()
        .test.some(({ firstName }) => firstName);
    };

    result.current.register('test.0.firstName', {
      validate,
    });
    result.current.register('test.0.lastName', {
      validate,
    });
    result.current.register('test.1.firstName', {
      validate,
    });
    result.current.register('test.1.lastName', {
      validate,
    });

    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(callback).not.toBeCalled();

    result.current.setValue('test.0.firstName', 'test');

    await act(async () => {
      await result.current.handleSubmit(callback)({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(callback).toBeCalled();
  });

  it('should bubble the error up when an error occurs in the provided handleSubmit function by leaving formState flags in a consistent state', async () => {
    const errorMsg = 'this is an error';
    const App = () => {
      const [error, setError] = React.useState('');
      const {
        register,
        handleSubmit,
        formState: { isSubmitting, isSubmitted, isSubmitSuccessful },
      } = useForm();

      const rejectPromiseFn = jest.fn().mockRejectedValue(new Error(errorMsg));

      return (
        <form>
          <input {...register('test')} />
          <p>{error}</p>
          <p>isSubmitting : {isSubmitting ? 'true' : 'false'}</p>
          <p>isSubmitted : {isSubmitted ? 'true' : 'false'}</p>
          <p>isSubmitSuccessful : {isSubmitSuccessful ? 'true' : 'false'}</p>
          <button
            type={'button'}
            onClick={() =>
              handleSubmit(rejectPromiseFn)().catch((err) =>
                setError(err.message),
              )
            }
          >
            Submit
          </button>
        </form>
      );
    };

    render(<App />);
    expect(await screen.findByText('isSubmitting : false')).toBeVisible();
    expect(await screen.findByText('isSubmitted : false')).toBeVisible();
    expect(await screen.findByText('isSubmitSuccessful : false')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText(errorMsg)).toBeVisible();
    expect(await screen.findByText('isSubmitting : false')).toBeVisible();
    expect(await screen.findByText('isSubmitted : true')).toBeVisible();
    expect(await screen.findByText('isSubmitSuccessful : false')).toBeVisible();
  });

  describe('with validationSchema', () => {
    it('should invoke callback when error not found', async () => {
      const resolver = async (data: any) => {
        return {
          values: data,
          errors: {},
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test: string }>({
          mode: VALIDATION_MODE.onSubmit,
          resolver,
        }),
      );

      result.current.register('test', { required: true });

      const callback = jest.fn();

      await act(async () => {
        await result.current.handleSubmit(callback)({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });
      expect(callback).toBeCalled();
    });

    it('should invoke callback with transformed values', async () => {
      const resolver = async () => {
        return {
          values: { test: 'test' },
          errors: {},
        };
      };

      const { result } = renderHook(() =>
        useForm<{ test: string }>({
          mode: VALIDATION_MODE.onSubmit,
          resolver,
        }),
      );

      result.current.register('test', { required: true });

      const callback = jest.fn();

      await act(async () => {
        await result.current.handleSubmit(callback)({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });
      expect(callback.mock.calls[0][0]).toEqual({ test: 'test' });
    });
  });

  describe('with onInvalid callback', () => {
    it('should invoke the onValid callback when validation pass', async () => {
      const { result } = renderHook(() => useForm());
      const onValidCallback = jest.fn();
      const onInvalidCallback = jest.fn();

      await act(async () => {
        await result.current.handleSubmit(
          onValidCallback,
          onInvalidCallback,
        )({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });
      expect(onValidCallback).toBeCalledTimes(1);
      expect(onInvalidCallback).not.toBeCalledTimes(1);
    });

    it('should invoke the onInvalid callback when validation failed', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string;
        }>(),
      );
      result.current.register('test', { required: true });
      const onValidCallback = jest.fn();
      const onInvalidCallback = jest.fn();

      await act(async () => {
        await result.current.handleSubmit(
          onValidCallback,
          onInvalidCallback,
        )({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });

      expect(onValidCallback).not.toBeCalledTimes(1);
      expect(onInvalidCallback).toBeCalledTimes(1);
    });
  });

  it('should not provide internal errors reference to onInvalid callback', async () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );
    result.current.register('test', { required: true });

    await act(async () => {
      await result.current.handleSubmit(noop, (errors) => {
        Object.freeze(errors);
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    await act(async () => {
      expect(() =>
        result.current.setError('test', { message: 'Not enough', type: 'min' }),
      ).not.toThrow();
    });
  });

  it('should be able to submit correctly when errors contains empty array object', async () => {
    const onSubmit = jest.fn();

    const App = () => {
      const { register, control, handleSubmit } = useForm({
        defaultValues: {
          test: [{ name: '1234' }],
        },
        mode: 'onChange',
      });
      const { fields, remove } = useFieldArray({ control, name: 'test' });

      return (
        <form
          onSubmit={handleSubmit(() => {
            onSubmit();
          })}
        >
          {fields.map((field, index) => {
            return (
              <input
                key={field.id}
                {...register(`test.${index}.name`, { required: true })}
              />
            );
          })}

          <button type={'button'} onClick={() => remove(0)}>
            remove
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '',
      },
    });

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(onSubmit).not.toBeCalled();
  });

  it('should be able to submit correctly when errors contains empty array object and errors state is subscribed', async () => {
    const onSubmit = jest.fn();

    const App = () => {
      const {
        register,
        control,
        handleSubmit,
        formState: { errors },
      } = useForm({
        defaultValues: {
          test: [{ name: '1234' }],
        },
        mode: 'onChange',
      });
      const { fields, remove } = useFieldArray({ control, name: 'test' });

      return (
        <>
          <p>Number of errors: {Object.keys(errors).length}</p>
          <form
            onSubmit={handleSubmit(() => {
              onSubmit();
            })}
          >
            {fields.map((field, index) => {
              return (
                <input
                  key={field.id}
                  {...register(`test.${index}.name`, { required: true })}
                />
              );
            })}

            <button type={'button'} onClick={() => remove(0)}>
              remove
            </button>
            <button>submit</button>
          </form>
        </>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '',
      },
    });

    expect(await screen.findByText('Number of errors: 1')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() => expect(onSubmit).toBeCalled());
  });
});


================================================
File: /src/__tests__/useForm/getFieldState.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';

import { Control } from '../../types';
import { useController } from '../../useController';
import { useForm } from '../../useForm';

type FormValues = {
  nested: {
    first: string;
    last: string;
  };
};

const NestedInput = ({ control }: { control: Control<FormValues> }) => {
  const { field } = useController({
    control,
    name: 'nested',
    rules: {
      validate: (data) => {
        return data.first && data.last ? true : 'This is required';
      },
    },
  });

  return (
    <fieldset>
      <input
        value={field.value.first}
        onChange={(e) => {
          field.onChange({
            ...field.value,
            first: e.target.value,
          });
        }}
        onBlur={field.onBlur}
      />
      <input
        value={field.value.last}
        onChange={(e) => {
          field.onChange({
            ...field.value,
            last: e.target.value,
          });
        }}
        onBlur={field.onBlur}
      />
    </fieldset>
  );
};

describe('getFieldState', () => {
  describe('with field name supplied', () => {
    describe('when input is primitive data type', () => {
      it('should display error state', async () => {
        const App = () => {
          const {
            trigger,
            register,
            getFieldState,
            formState: { errors },
          } = useForm({
            defaultValues: {
              test: '',
            },
          });

          errors;

          return (
            <form>
              <input {...register('test', { required: 'This is required' })} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{getFieldState('test')?.error?.message}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('This is required')).toBeVisible();
      });

      it('should display isValid state', async () => {
        const App = () => {
          const {
            trigger,
            register,
            getFieldState,
            formState: { errors },
          } = useForm({
            defaultValues: {
              test: '',
            },
          });

          errors;

          return (
            <form>
              <input {...register('test', { required: 'This is required' })} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{getFieldState('test')?.invalid ? 'error' : 'valid'}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('error')).toBeVisible();
      });

      it('should display isTouched state', async () => {
        const App = () => {
          const {
            register,
            getFieldState,
            formState: { touchedFields },
          } = useForm({
            defaultValues: {
              test: '',
            },
          });

          touchedFields;

          return (
            <form>
              <input {...register('test')} />
              <p>{getFieldState('test')?.isTouched ? 'touched' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.focus(screen.getByRole('textbox'));
        fireEvent.blur(screen.getByRole('textbox'));

        expect(screen.getByText('touched')).toBeVisible();
      });

      it('should display isDirty state', async () => {
        const App = () => {
          const {
            register,
            getFieldState,
            formState: { dirtyFields },
          } = useForm({
            defaultValues: {
              test: '',
            },
          });

          dirtyFields;

          return (
            <form>
              <input {...register('test')} />
              <p>{getFieldState('test')?.isDirty ? 'dirty' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.change(screen.getByRole('textbox'), {
          target: { value: ' test' },
        });

        expect(screen.getByText('dirty')).toBeVisible();
      });

      it('should not have error', () => {
        const App = () => {
          const {
            register,
            getFieldState,
            formState: { dirtyFields },
          } = useForm({
            defaultValues: {
              test: '',
            },
          });

          dirtyFields;

          return (
            <form>
              <input {...register('test')} />
              <p>
                {getFieldState('test').error === undefined
                  ? 'error undefined'
                  : ''}
              </p>
            </form>
          );
        };

        render(<App />);

        expect(screen.getByText('error undefined')).toBeVisible();
      });
    });

    describe('when input is nested data type', () => {
      it('should display error state', async () => {
        const App = () => {
          const {
            trigger,
            getFieldState,
            control,
            formState: { errors },
          } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          errors;

          return (
            <form>
              <NestedInput control={control} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{getFieldState('nested')?.error?.message}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('This is required')).toBeVisible();
      });

      it('should display isValid state', async () => {
        const App = () => {
          const {
            trigger,
            control,
            getFieldState,
            formState: { errors },
          } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          errors;

          return (
            <form>
              <NestedInput control={control} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{getFieldState('nested')?.invalid ? 'error' : 'valid'}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('error')).toBeVisible();
      });

      it('should display isTouched state', async () => {
        const App = () => {
          const {
            control,
            getFieldState,
            formState: { touchedFields },
          } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          touchedFields;

          return (
            <form>
              <NestedInput control={control} />
              <p>{getFieldState('nested')?.isTouched ? 'touched' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.focus(screen.getAllByRole('textbox')[0]);
        fireEvent.blur(screen.getAllByRole('textbox')[0]);

        expect(screen.getByText('touched')).toBeVisible();
      });

      it('should display isDirty state', async () => {
        const App = () => {
          const {
            control,
            getFieldState,
            formState: { dirtyFields },
          } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          dirtyFields;

          return (
            <form>
              <NestedInput control={control} />
              <p>{getFieldState('nested')?.isDirty ? 'dirty' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.change(screen.getAllByRole('textbox')[0], {
          target: { value: ' test' },
        });

        expect(screen.getByText('dirty')).toBeVisible();
      });

      it('should not have error', () => {
        const App = () => {
          const {
            control,
            getFieldState,
            formState: { dirtyFields },
          } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          dirtyFields;

          return (
            <form>
              <NestedInput control={control} />
              <p>
                {getFieldState('nested').error === undefined
                  ? 'error undefined'
                  : ''}
              </p>
            </form>
          );
        };

        render(<App />);

        expect(screen.getByText('error undefined')).toBeVisible();
      });
    });
  });

  describe('with form state and field name supplied', () => {
    describe('when input is primitive data type', () => {
      it('should display error state', async () => {
        const App = () => {
          const { trigger, register, getFieldState, formState } = useForm({
            defaultValues: {
              test: '',
            },
          });

          const { error } = getFieldState('test', formState);

          return (
            <form>
              <input {...register('test', { required: 'This is required' })} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{error?.message}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('This is required')).toBeVisible();
      });

      it('should display isValid state', async () => {
        const App = () => {
          const { trigger, register, getFieldState, formState } = useForm({
            defaultValues: {
              test: '',
            },
          });

          const { invalid } = getFieldState('test', formState);

          return (
            <form>
              <input {...register('test', { required: 'This is required' })} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{invalid ? 'error' : 'valid'}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('error')).toBeVisible();
      });

      it('should display isTouched state', async () => {
        const App = () => {
          const { register, getFieldState, formState } = useForm({
            defaultValues: {
              test: '',
            },
          });

          const { isTouched } = getFieldState('test', formState);

          return (
            <form>
              <input {...register('test')} />
              <p>{isTouched ? 'touched' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.focus(screen.getByRole('textbox'));
        fireEvent.blur(screen.getByRole('textbox'));

        expect(screen.getByText('touched')).toBeVisible();
      });

      it('should display isDirty state', async () => {
        const App = () => {
          const { register, getFieldState, formState } = useForm({
            defaultValues: {
              test: '',
            },
          });

          const { isDirty } = getFieldState('test', formState);

          return (
            <form>
              <input {...register('test')} />
              <p>{isDirty ? 'dirty' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.change(screen.getByRole('textbox'), {
          target: { value: ' test' },
        });

        expect(screen.getByText('dirty')).toBeVisible();
      });

      it('should not have error', () => {
        const App = () => {
          const { register, getFieldState, formState } = useForm({
            defaultValues: {
              test: '',
            },
          });

          const { error } = getFieldState('test', formState);

          return (
            <form>
              <input {...register('test')} />
              <p>{error === undefined ? 'error undefined' : ''}</p>
            </form>
          );
        };

        render(<App />);

        expect(screen.getByText('error undefined')).toBeVisible();
      });
    });

    describe('when input is nested data type', () => {
      it('should display error state', async () => {
        const App = () => {
          const { trigger, getFieldState, control, formState } =
            useForm<FormValues>({
              defaultValues: {
                nested: {
                  first: '',
                  last: '',
                },
              },
            });

          const { error } = getFieldState('nested', formState);

          return (
            <form>
              <NestedInput control={control} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{error?.message}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('This is required')).toBeVisible();
      });

      it('should display isValid state', async () => {
        const App = () => {
          const { trigger, control, getFieldState, formState } =
            useForm<FormValues>({
              defaultValues: {
                nested: {
                  first: '',
                  last: '',
                },
              },
            });

          const { invalid } = getFieldState('nested', formState);

          return (
            <form>
              <NestedInput control={control} />
              <button type={'button'} onClick={() => trigger()}>
                trigger
              </button>
              <p>{invalid ? 'error' : 'valid'}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.click(screen.getByRole('button'));

        expect(await screen.findByText('error')).toBeVisible();
      });

      it('should display isTouched state', async () => {
        const App = () => {
          const { control, getFieldState, formState } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          const { isTouched } = getFieldState('nested', formState);

          return (
            <form>
              <NestedInput control={control} />
              <p>{isTouched ? 'touched' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.focus(screen.getAllByRole('textbox')[0]);
        fireEvent.blur(screen.getAllByRole('textbox')[0]);

        expect(screen.getByText('touched')).toBeVisible();
      });

      it('should display isDirty state', async () => {
        const App = () => {
          const { control, getFieldState, formState } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          const { isDirty } = getFieldState('nested', formState);

          return (
            <form>
              <NestedInput control={control} />
              <p>{isDirty ? 'dirty' : ''}</p>
            </form>
          );
        };

        render(<App />);

        fireEvent.change(screen.getAllByRole('textbox')[0], {
          target: { value: ' test' },
        });

        expect(screen.getByText('dirty')).toBeVisible();
      });

      it('should not have error', () => {
        const App = () => {
          const { control, getFieldState, formState } = useForm<FormValues>({
            defaultValues: {
              nested: {
                first: '',
                last: '',
              },
            },
          });

          const { error } = getFieldState('nested', formState);

          return (
            <form>
              <NestedInput control={control} />
              <p>{error === undefined ? 'error undefined' : ''}</p>
            </form>
          );
        };

        render(<App />);

        expect(screen.getByText('error undefined')).toBeVisible();
      });
    });
  });

  describe('when field is not found', () => {
    it('should return field state', async () => {
      const App = () => {
        const { control, getFieldState, formState } = useForm<FormValues>({
          defaultValues: {
            nested: {
              first: '',
              last: '',
            },
          },
        });

        // @ts-expect-error expected to show type error for field name
        const { isDirty } = getFieldState('nestedMissing', formState);

        // @ts-expect-error expected to show type error for field name
        const { isTouched, error } = getFieldState('nestedMissing');

        return (
          <form>
            <NestedInput control={control} />
            <p>{isDirty ? 'dirty' : 'notDirty'}</p>
            <p>{isTouched ? 'touched' : 'notTouched'}</p>
            <p>{error === undefined ? 'error undefined' : 'error defined'}</p>
          </form>
        );
      };

      render(<App />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: { value: ' test' },
      });

      expect(screen.getByText('notDirty')).toBeVisible();
      expect(screen.getByText('notTouched')).toBeVisible();
      expect(screen.getByText('error undefined')).toBeVisible();
    });
  });
});


================================================
File: /src/__tests__/useForm/unregister.test.tsx
================================================
import { act, renderHook } from '@testing-library/react';

import { useForm } from '../../useForm';

describe('unregister', () => {
  it('should unregister an registered item', async () => {
    const { result } = renderHook(() => useForm<{ input: string }>());

    result.current.register('input');

    await act(async () => {
      await result.current.unregister('input');
    });

    expect(result.current.getValues()).toEqual({});
  });

  it('should unregister an registered item with array name', async () => {
    const { result } = renderHook(() =>
      useForm<{
        input: string;
        input2: string;
      }>(),
    );

    result.current.register('input');
    result.current.register('input');
    result.current.register('input2');

    await act(async () => {
      await result.current.unregister(['input', 'input2']);
    });

    expect(result.current.getValues()).toEqual({});
  });

  it('should unregister all inputs', async () => {
    const { result } = renderHook(() =>
      useForm<{
        input: string;
        input2: string;
      }>(),
    );

    result.current.register('input');
    result.current.register('input');
    result.current.register('input2');

    await act(async () => {
      await result.current.unregister();
    });

    expect(result.current.getValues()).toEqual({});
  });
});


================================================
File: /src/__tests__/useForm/register.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
  waitForElementToBeRemoved,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Controller } from '../../controller';
import { UseFormRegister } from '../../types';
import { useForm } from '../../useForm';
import { FormProvider, useFormContext } from '../../useFormContext';
import isFunction from '../../utils/isFunction';
import isString from '../../utils/isString';
import noop from '../../utils/noop';

describe('register', () => {
  it('should support register passed to ref', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: string }>({
        defaultValues: {
          test: 'testData',
        },
      }),
    );

    const { ref } = result.current.register('test');

    isFunction(ref) &&
      ref({
        target: {
          value: 'testData',
        },
      });

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: 'testData',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  test.each([['text'], ['radio'], ['checkbox']])(
    'should register field for %s type and remain its value after unmount',
    async (type) => {
      const Component = () => {
        const {
          register,
          watch,
          formState: { isDirty },
        } = useForm<{
          test: string;
        }>({
          defaultValues: {
            test: 'test',
          },
        });

        const test = watch('test');

        return (
          <form>
            <input type={type} {...register('test')} />
            <span role="alert">{`${isDirty}`}</span>
            {test}
          </form>
        );
      };

      render(<Component />);

      const ref = screen.getByRole(type === 'text' ? 'textbox' : type);

      ref.remove();

      expect(screen.getByRole('alert').textContent).toBe('false');

      expect(screen.getByText('test')).toBeVisible();
    },
  );

  test.each([['text'], ['radio'], ['checkbox']])(
    'should not register the same %s input',
    async (type) => {
      const callback = jest.fn();
      const Component = () => {
        const { register, handleSubmit } = useForm<{
          test: string;
        }>();
        return (
          <div>
            <input type={type} {...register('test')} />

            <button onClick={handleSubmit(callback)}>submit</button>
          </div>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: /submit/ }));

      await waitFor(() =>
        expect(callback).toHaveBeenCalledWith(
          {
            test: type === 'checkbox' ? false : type === 'radio' ? null : '',
          },
          expect.any(Object),
        ),
      );
    },
  );

  it('should determine checkbox group by type of reference value', async () => {
    const callback = jest.fn();
    const Component = () => {
      const { register, handleSubmit } = useForm<{
        test: string[];
      }>({
        defaultValues: {
          test: [],
        },
      });
      return (
        <div>
          <input type="checkbox" value="A" {...register('test')} />

          <button onClick={handleSubmit(callback)}>submit</button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('checkbox'));

    fireEvent.click(screen.getByRole('button', { name: /submit/ }));

    await waitFor(() =>
      expect(callback).toHaveBeenCalledWith(
        {
          test: ['A'],
        },
        expect.any(Object),
      ),
    );
  });

  it('should re-render if errors occurred with resolver when formState.isValid is defined', async () => {
    const Component = () => {
      const { register, formState } = useForm<{ test: string }>({
        resolver: async (data) => {
          return {
            values: data,
            errors: {
              test: {
                type: 'test',
              },
            },
          };
        },
      });

      return (
        <div>
          <input {...register('test')} />
          <span role="alert">{`${formState.isValid}`}</span>
        </div>
      );
    };

    render(<Component />);

    expect(screen.getByRole('alert').textContent).toBe('false');
  });

  it('should be set default value when item is remounted again', async () => {
    const { result, unmount } = renderHook(() => useForm<{ test: string }>());

    result.current.register('test');

    result.current.setValue('test', 'test');

    unmount();

    const ref = { type: 'text', name: 'test' };

    result.current.register('test');

    expect(ref).toEqual({ type: 'text', name: 'test' });

    expect(result.current.getValues()).toEqual({ test: 'test' });
  });

  // issue: https://github.com/react-hook-form/react-hook-form/issues/2298
  it('should reset isValid formState after reset with valid value in initial render', async () => {
    const Component = () => {
      const { register, reset, formState } = useForm<{
        issue: string;
        test: string;
      }>({
        mode: VALIDATION_MODE.onChange,
      });

      React.useEffect(() => {
        setTimeout(() => {
          reset({ issue: 'test', test: 'test' });
        });
      }, [reset]);

      return (
        <div>
          <input {...register('test', { required: true })} />
          <input type="text" {...register('issue', { required: true })} />
          <button disabled={!formState.isValid}>submit</button>
        </div>
      );
    };

    render(<Component />);

    await waitFor(() => {
      expect(screen.getByRole('button')).not.toBeDisabled();
    });
  });

  it('should update isValid correctly with custom registered input', async () => {
    function Component() {
      const {
        register,
        setValue,
        formState: { isValid },
      } = useForm({
        defaultValues: { a: 'default', b: '' },
        mode: 'onChange',
      });

      React.useEffect(() => {
        register('a', {
          required: 'required',
        });
        register('b', {
          required: 'required',
        });
      }, [register]);

      return (
        <form>
          <input
            placeholder={'inputA'}
            onChange={({ target: { value } }) =>
              setValue('a', value, { shouldDirty: true, shouldValidate: true })
            }
          />
          <input
            placeholder={'inputB'}
            onChange={({ target: { value } }) =>
              setValue('b', value, { shouldDirty: true, shouldValidate: true })
            }
          />
          <div>{String(isValid)}</div>
        </form>
      );
    }

    render(<Component />);

    expect(screen.getByText('false')).toBeVisible();

    fireEvent.input(screen.getByPlaceholderText('inputA'), {
      target: { value: 'test' },
    });

    expect(await screen.findByText('false')).toBeVisible();

    fireEvent.input(screen.getByPlaceholderText('inputB'), {
      target: { value: 'test' },
    });

    expect(await screen.findByText('true')).toBeVisible();
  });

  it('should custom register with value and can be updated', async () => {
    const App = () => {
      const [inputValue, setInput] = React.useState(1);
      const [data, setData] = React.useState('');
      const { handleSubmit, register, setValue } = useForm<{ test: string }>();

      React.useEffect(() => {
        register('test', {
          value: 'bill',
        });
      }, [register]);

      return (
        <form>
          <button
            type={'button'}
            onClick={handleSubmit((data) => {
              setData(data.test);
            })}
          >
            handleSubmit
          </button>
          <button
            type={'button'}
            onClick={() => {
              setValue('test', '1234');
              setInput(inputValue + 1);
            }}
          >
            update
          </button>
          <p>{data}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'handleSubmit' }));

    fireEvent.click(screen.getByRole('button', { name: 'update' }));

    expect(await screen.findByText('bill')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'handleSubmit' }));

    expect(await screen.findByText('1234')).toBeVisible();
  });

  it('should not affect or check against defaultChecked inputs', async () => {
    type FormValues = Partial<{
      radio: string;
      checkbox: string[];
    }>;
    let output: FormValues;

    output = {};

    function Component() {
      const { register, handleSubmit } = useForm<FormValues>();

      return (
        <form
          onSubmit={handleSubmit((data) => {
            output = data;
          })}
        >
          <input {...register('radio')} type="radio" value="Yes" />
          <input
            {...register('radio')}
            type="radio"
            value="No"
            defaultChecked
          />
          <input {...register('checkbox')} type="checkbox" value="Yes" />
          <input
            {...register('checkbox')}
            type="checkbox"
            value="No"
            defaultChecked
          />
          <button />
        </form>
      );
    }

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(output).toEqual({
        checkbox: ['No'],
        radio: 'No',
      }),
    );
  });

  describe('when defaultValue is provided', () => {
    it('should check checkbox by default when value matches', async () => {
      type FormValues = Partial<{
        checkbox: string;
      }>;

      function Component() {
        const { register } = useForm<FormValues>({
          defaultValues: {
            checkbox: 'A',
          },
        });

        return (
          <form>
            <input {...register('checkbox')} type="checkbox" value="A" />
            <button />
          </form>
        );
      }

      render(<Component />);

      expect((screen.getByRole('checkbox') as HTMLInputElement).checked).toBe(
        true,
      );
    });

    it('should not check checkboxes when defaultValue is empty array', async () => {
      type FormValues = Partial<{
        checkbox: string[];
      }>;

      function Component() {
        const { register } = useForm<FormValues>({
          defaultValues: {
            checkbox: [],
          },
        });

        return (
          <form>
            <input {...register('checkbox')} type="checkbox" value="A" />
            <button />
          </form>
        );
      }

      render(<Component />);

      expect((screen.getByRole('checkbox') as HTMLInputElement).checked).toBe(
        false,
      );
    });

    it('should only check checkboxes when array defaultValue includes input value', async () => {
      type FormValues = Partial<{
        checkbox: string[];
      }>;

      function Component() {
        const { register } = useForm<FormValues>({
          defaultValues: {
            checkbox: ['B'],
          },
        });

        return (
          <form>
            <input
              {...register('checkbox')}
              type="checkbox"
              value="A"
              aria-label="checkbox-A"
            />
            <input {...register('checkbox')} type="checkbox" value="B" />
            <button />
          </form>
        );
      }

      render(<Component />);

      expect(
        (screen.getByLabelText('checkbox-A') as HTMLInputElement).checked,
      ).toBe(false);
    });
  });

  it('should remove input value and reference with shouldUnregister: true', () => {
    type FormValue = {
      test: string;
    };
    const watchedValue: FormValue[] = [];
    const Component = () => {
      const { register, watch } = useForm<FormValue>({
        defaultValues: {
          test: 'bill',
        },
      });
      const [show, setShow] = React.useState(true);
      watchedValue.push(watch());

      return (
        <>
          {show && <input {...register('test', { shouldUnregister: true })} />}
          <button onClick={() => setShow(false)}>hide</button>
        </>
      );
    };

    render(<Component />);

    expect(watchedValue.at(-1)).toEqual({ test: 'bill' });

    fireEvent.click(screen.getByRole('button'));

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(watchedValue).toEqual([
      {
        test: 'bill',
      },
      {
        test: 'bill',
      },
      {},
    ]);
  });

  it('should keep defaultValue with shouldUnregister: true when input unmounts', () => {
    type FormValue = {
      test: string;
    };

    const Component = () => {
      const { register } = useForm<FormValue>({
        defaultValues: {
          test: 'bill',
        },
        shouldUnregister: true,
      });
      const [show, setShow] = React.useState(true);

      return (
        <>
          {show && <input {...register('test', { shouldUnregister: true })} />}
          <button onClick={() => setShow(!show)}>hide</button>
        </>
      );
    };

    render(<Component />);

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'bill',
    );

    fireEvent.click(screen.getByRole('button'));

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'bill',
    );
  });

  it('should skip register absent fields which are checkbox/radio inputs', async () => {
    let data: unknown;

    const App = () => {
      const { register, handleSubmit } = useForm({
        defaultValues: {
          test: ['1', '2', '3'],
          nested: {
            test: {},
            test1: [],
          },
        },
      });
      return (
        <form onSubmit={handleSubmit((d) => (data = d))}>
          <input type="checkbox" {...register('test')} value={'1'} />
          <input type="checkbox" {...register('test')} value={'2'} />
          <input type="checkbox" {...register('test')} value={'3'} />
          <button>Submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(data).toEqual({
        nested: {
          test: {},
          test1: [],
        },
        test: ['1', '2', '3'],
      }),
    );

    fireEvent.click(screen.getAllByRole('checkbox')[0]);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(data).toEqual({
        test: ['2', '3'],
        nested: {
          test: {},
          test1: [],
        },
      }),
    );
  });

  describe('register disabled', () => {
    it('should return undefined for disabled inputs', async () => {
      let output = {};
      const defaultValues = {
        test: true,
      };

      function App() {
        const { register, handleSubmit } = useForm({
          defaultValues: defaultValues,
        });

        return (
          <form
            onSubmit={handleSubmit((values) => {
              output = values;
            })}
          >
            {[
              { value: 'test', label: 'test' },
              { value: 'test1', label: 'test1' },
            ].map((item) => (
              <input
                key={item.value}
                type="checkbox"
                {...register('test', {
                  disabled: true,
                })}
              />
            ))}
            <button type="submit">submit</button>
          </form>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(output).toEqual({
        test: undefined,
      });
    });

    it('should omit all inputs which has disabled set to true', async () => {
      let outputData: object = {};
      const watchedData: object[] = [];

      const Component = () => {
        const { register, handleSubmit, watch } = useForm<{
          test?: string;
          test1?: string;
          test2?: string;
          test3?: string;
          test4: string;
        }>();

        watchedData.push(watch());

        return (
          <form
            onSubmit={handleSubmit((data) => {
              outputData = data;
            })}
          >
            <input {...register('test')} disabled />
            <input
              disabled
              value={'test'}
              type={'checkbox'}
              {...register('test1')}
            />
            <input
              disabled
              value={'test'}
              type={'radio'}
              {...register('test2')}
            />
            <select {...register('test3')} disabled />
            <input {...register('test4')} data-testid={'input'} />
            <button>Submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.change(screen.getByTestId('input'), {
        target: { value: '1234' },
      });

      fireEvent.click(screen.getByRole('button'));

      expect(watchedData).toStrictEqual([
        {},
        {
          test: undefined,
          test1: undefined,
          test2: undefined,
          test3: undefined,
          test4: '1234',
        },
      ]);

      await waitFor(() =>
        expect(outputData).toStrictEqual({
          test: undefined,
          test1: undefined,
          test2: undefined,
          test3: undefined,
          test4: '1234',
        }),
      );
    });

    it('should validate value after toggling enabled/disabled on input', async () => {
      const defaultValue = 'Test';
      const validate = jest.fn();
      const submit = jest.fn();
      const onSubmit = (values: unknown) => {
        submit(values);
      };

      const App = () => {
        const [editable, setEditable] = React.useState(false);
        const { register, handleSubmit } = useForm();

        return (
          <form onSubmit={handleSubmit(onSubmit)}>
            <input
              defaultValue={defaultValue}
              {...register('test', { validate, disabled: !editable })}
            />
            <button type="button" onClick={() => setEditable(!editable)}>
              Toggle Edit
            </button>
            <button type="submit">Submit</button>
          </form>
        );
      };

      render(<App />);

      expect(validate).toBeCalledTimes(0);

      fireEvent.click(screen.getByText('Toggle Edit'));
      fireEvent.click(screen.getByText('Submit'));

      expect(validate).toBeCalledWith(defaultValue, { test: 'Test' });
      await waitFor(() =>
        expect(submit).toBeCalledWith({ test: defaultValue }),
      );

      fireEvent.click(screen.getByText('Toggle Edit'));
      fireEvent.click(screen.getByText('Submit'));

      await waitFor(() => expect(submit).toBeCalledWith({ test: undefined }));
    });

    it('should not throw errors with disabled input', async () => {
      const message = 'Must have at least one checked!';

      function Checkbox() {
        const { register } = useFormContext();

        return (
          <>
            <p>
              Must select:
              <input
                type="checkbox"
                value="test"
                {...register('test', {
                  disabled: false,
                  validate: (value) => {
                    return value && value.length > 0 ? true : message;
                  },
                })}
              />
              A
            </p>
          </>
        );
      }

      function App() {
        const formMethods = useForm({
          mode: 'onSubmit',
          defaultValues: { test: '' },
        });
        const { handleSubmit, formState } = formMethods;

        return (
          <>
            <FormProvider {...formMethods}>
              <form onSubmit={handleSubmit(noop)}>
                <Checkbox />
                <button>Submit</button>
                <p>{formState.errors.test?.message}</p>
              </form>
            </FormProvider>
          </>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText(message)).toBeVisible();

      fireEvent.click(screen.getByRole('checkbox'));
      fireEvent.click(screen.getByRole('button'));
      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(screen.queryByText(message)).not.toBeInTheDocument(),
      );
    });

    it('should affect a group of checked attribute with disabled attribute', () => {
      const App = () => {
        const { register } = useForm();
        const options = [
          { checked: false, disabled: false, value: 'test' },
          { checked: true, disabled: true, value: 'test1' },
          { checked: false, disabled: false, value: 'test2' },
        ];

        return (
          <>
            {options.map((option, index) => {
              return (
                <div key={index}>
                  <input
                    {...register('test')}
                    type="checkbox"
                    disabled={option.disabled}
                    value={option.value}
                    defaultChecked={option.checked}
                    data-testid={'checkbox' + index}
                  />
                </div>
              );
            })}
          </>
        );
      };

      render(<App />);

      expect(
        (screen.getByTestId('checkbox0') as HTMLInputElement).checked,
      ).toBeFalsy();
      expect(
        (screen.getByTestId('checkbox1') as HTMLInputElement).checked,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('checkbox2') as HTMLInputElement).checked,
      ).toBeFalsy();
    });

    it('should affect a single checked attribute with disabled attribute', () => {
      const App = () => {
        const { register } = useForm<{
          test: boolean;
          test1: boolean;
          test2: boolean;
        }>({
          defaultValues: {
            test: true,
            test1: true,
          },
        });

        return (
          <div>
            <input
              {...register('test')}
              type="checkbox"
              disabled={true}
              data-testid="checkbox1"
            />
            <input
              {...register('test1')}
              type="checkbox"
              disabled={true}
              data-testid="checkbox2"
            />
            <input
              {...register('test2')}
              type="checkbox"
              disabled={true}
              defaultChecked={true}
              data-testid="checkbox3"
            />
          </div>
        );
      };

      render(<App />);

      expect(
        (screen.getByTestId('checkbox1') as HTMLInputElement).checked,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('checkbox2') as HTMLInputElement).checked,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('checkbox3') as HTMLInputElement).checked,
      ).toBeTruthy();
    });

    it('should work correctly with toggle disabled attribute and validation', async () => {
      type FormValues = {
        test: string;
      };

      function Input({
        disabled,
        register,
      }: {
        disabled: boolean;
        register: UseFormRegister<FormValues>;
      }) {
        const options = {
          disabled,
          validate: (value: string) => {
            return value && value.length > 0
              ? true
              : 'Must have at least one checked!';
          },
        };

        return (
          <input type="checkbox" value="a" {...register('test', options)} />
        );
      }

      const App = () => {
        const [value, setValue] = React.useState({});
        const [disabled, setDisabled] = React.useState(false);
        const {
          register,
          handleSubmit,
          formState: { errors },
        } = useForm<FormValues>();

        return (
          <form onSubmit={handleSubmit(setValue)}>
            <Input register={register} disabled={disabled} />
            {errors.test && <p>error</p>}
            <button type={'button'} onClick={() => setDisabled(!disabled)}>
              setDisabled
            </button>
            <button>submit</button>
            <p>{JSON.stringify(value)}</p>
          </form>
        );
      };

      render(<App />);

      fireEvent.click(screen.getByRole('checkbox'));

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(await screen.findByText('{"test":"a"}')).toBeVisible();

      fireEvent.click(screen.getByRole('button', { name: 'setDisabled' }));

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(await screen.findByText('{}')).toBeVisible();

      fireEvent.click(screen.getByRole('button', { name: 'setDisabled' }));

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(await screen.findByText('{"test":"a"}')).toBeVisible();
    });
  });

  describe('register valueAs', () => {
    it('should return number value with valueAsNumber', async () => {
      let output = {};
      const Component = () => {
        const { register, handleSubmit } = useForm<{
          test: number;
          test1: boolean;
        }>();

        return (
          <form onSubmit={handleSubmit((data) => (output = data))}>
            <input {...register('test', { valueAsNumber: true })} />
            <input
              {...register('test1', {
                setValueAs: (value: string) => value === 'true',
              })}
            />
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.input(screen.getAllByRole('textbox')[0], {
        target: {
          value: '12345',
        },
      });

      fireEvent.input(screen.getAllByRole('textbox')[1], {
        target: {
          value: 'true',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() => expect(output).toEqual({ test: 12345, test1: true }));
    });

    it('should return undefined value with setValueAs', async () => {
      let output = {};
      const Component = () => {
        const { register, handleSubmit } = useForm<{
          test: number;
        }>();

        return (
          <form onSubmit={handleSubmit((data) => (output = data))}>
            <input
              {...register('test', {
                setValueAs: (value: string) =>
                  value === '' ? undefined : +value,
              })}
              defaultValue={12345}
            />
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: '',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      expect(output).toEqual({ test: undefined });
    });

    it('should return NaN when value is valid', async () => {
      let output = {};
      const Component = () => {
        const { register, handleSubmit } = useForm<{
          test: number;
        }>();

        return (
          <form onSubmit={handleSubmit((data) => (output = data))}>
            <input {...register('test', { valueAsNumber: true })} />
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: '',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() => expect(output).toEqual({ test: NaN }));
    });

    it('should validate input before the valueAs', async () => {
      const Component = () => {
        const {
          register,
          formState: { errors },
        } = useForm<{
          test: number;
          test1: number;
        }>({
          mode: 'onChange',
        });

        return (
          <>
            <input
              {...register('test', {
                validate: (data) => {
                  return !isString(data);
                },
              })}
            />
            <span role="alert">{errors.test && 'Not number'}</span>

            <input
              {...register('test1', {
                valueAsNumber: true,
                min: 20,
              })}
            />
            <span role="alert">{errors.test1 && 'Number length'}</span>
          </>
        );
      };

      render(<Component />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '123',
        },
      });

      expect(await screen.findByText('Not number')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: '12',
        },
      });

      expect(await screen.findByText('Number length')).toBeVisible();
    });

    it('should be able to validate against formValues', async () => {
      const App = () => {
        const {
          register,
          formState: { errors },
        } = useForm({
          mode: 'onChange',
          defaultValues: {
            test: '',
            test1: '',
          },
        });

        return (
          <>
            <input
              {...register('test', {
                validate: (data, formValues) => data === formValues.test1,
              })}
            />
            <span role="alert">{errors.test ? 'Not number' : 'No error'}</span>

            <input {...register('test1')} />
          </>
        );
      };

      render(<App />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '1',
        },
      });

      await waitFor(() => screen.findByText('Not number'));

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: '11',
        },
      });

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '11',
        },
      });

      await waitFor(() => screen.findByText('No error'));
    });

    it('should send valueAs fields to schema validation', () => {
      let output: any;

      const Component = () => {
        const { register, trigger } = useForm<{
          test: number;
          test1: any;
          test2: boolean;
        }>({
          resolver: (data) => {
            output = data;
            return {
              values: {
                test: 1,
                test1: 2,
                test2: true,
              },
              errors: {},
            };
          },
        });

        return (
          <form>
            <input {...register('test', { valueAsNumber: true })} />
            <input {...register('test1', { valueAsDate: true })} />
            <input
              {...register('test2', { setValueAs: (data) => data === 'test' })}
            />
            <button type="button" onClick={() => trigger()}>
              trigger
            </button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: { value: 1 },
      });
      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: { value: '1990' },
      });
      fireEvent.change(screen.getAllByRole('textbox')[2], {
        target: { value: 'test' },
      });

      fireEvent.click(screen.getByRole('button'));

      expect(output).toEqual({
        test: 1,

        test1: new Date('1990'),
        test2: true,
      });
    });

    it('should send valueAs fields to in build validator', async () => {
      const Component = () => {
        const {
          register,
          trigger,
          formState: { errors },
        } = useForm({
          mode: 'onChange',
        });

        return (
          <>
            <input
              {...register('test', {
                validate: (value) => {
                  return value === 1;
                },
                valueAsNumber: true,
              })}
            />
            {errors.test && <p>test error</p>}
            <input
              {...register('test1', {
                validate: (value) => {
                  return value === 1;
                },
                setValueAs: (value) => parseInt(value),
              })}
            />
            {errors.test1 && <p>test1 error</p>}
            <button onClick={() => trigger()}>trigger</button>
          </>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('test error')).toBeVisible();
      expect(screen.getByText('test1 error')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '1',
        },
      });

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: '1',
        },
      });

      await waitForElementToBeRemoved(screen.queryByText('test error'));
      expect(screen.queryByText('test1 error')).not.toBeInTheDocument();
    });

    it('should send valueAs fields to resolver', async () => {
      const Component = () => {
        const {
          register,
          trigger,
          formState: { errors },
        } = useForm<{
          test: number;
          test1: number;
        }>({
          mode: 'onChange',
          resolver: async (data) => {
            const valid = !(isNaN(data.test) && isNaN(data.test1));

            return {
              errors: valid
                ? {}
                : {
                    test: {
                      type: 'error',
                      message: 'issue',
                    },
                    test1: {
                      type: 'error',
                      message: 'issue',
                    },
                  },
              values: valid
                ? {
                    test: 1,
                    test1: 2,
                  }
                : {},
            };
          },
        });

        return (
          <>
            <input
              {...register('test', {
                validate: (value) => {
                  return value === 1;
                },
                valueAsNumber: true,
              })}
            />
            {errors.test && <p>test error</p>}
            <input
              {...register('test1', {
                validate: (value) => {
                  return value === 1;
                },
                setValueAs: (value) => parseInt(value),
              })}
            />
            {errors.test && <p>test1 error</p>}
            <button onClick={() => trigger()}>trigger</button>
          </>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('test error')).toBeVisible();
      expect(screen.getByText('test1 error')).toBeVisible();

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '1',
        },
      });

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: '1',
        },
      });

      await waitForElementToBeRemoved(screen.queryByText('test error'));
      expect(screen.queryByText('test1 error')).not.toBeInTheDocument();
    });

    it('should still validate with an error existed', async () => {
      function App() {
        const {
          register,
          handleSubmit,
          setError,
          formState: { errors },
        } = useForm<{ firstName: string }>();
        const { name, ref, onBlur, onChange } = register('firstName');

        return (
          <form
            onSubmit={handleSubmit(() => {
              setError('firstName', {
                type: 'manual',
                message: 'Empty',
              });
            })}
          >
            <input
              placeholder="First Name"
              name={name}
              ref={ref}
              onBlur={onBlur}
              onChange={onChange}
            />
            {errors.firstName && <div>{errors.firstName.message}</div>}
            <input type="submit" />
          </form>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('Empty')).toBeVisible();

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      await waitForElementToBeRemoved(screen.queryByText('Empty'));
    });
  });

  it('should not register nested input', () => {
    const watchedValue: unknown[] = [];
    let inputs: unknown;

    const Checkboxes = ({
      value,
      onChange,
    }: {
      value: boolean[];
      onChange: (value: boolean[]) => void;
    }) => {
      const [checkboxValue, setCheckboxValue] = React.useState(value);

      return (
        <div>
          {value.map((_, index) => (
            <input
              key={index}
              onChange={(e) => {
                const updatedValue = checkboxValue.map((item, i) => {
                  if (index === i) {
                    return e.target.checked;
                  }
                  return item;
                });

                setCheckboxValue(updatedValue);
                onChange(updatedValue);
              }}
              type="checkbox"
              checked={checkboxValue[index]}
            />
          ))}
        </div>
      );
    };

    function App() {
      const { control, watch } = useForm({
        defaultValues: {
          test: [true, false, false],
        },
      });
      inputs = control._fields;
      watchedValue.push(watch());

      return (
        <form>
          <Controller
            name="test"
            control={control}
            render={({ field }) => (
              <Checkboxes onChange={field.onChange} value={field.value} />
            )}
          />
          <input type="submit" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getAllByRole('checkbox')[0]);

    expect(watchedValue).toEqual([
      { test: [true, false, false] },
      { test: [false, false, false] },
    ]);

    expect(inputs).toEqual({
      test: {
        _f: {
          mount: true,
          name: 'test',
          ref: {
            name: 'test',
          },
          value: [false, false, false],
        },
      },
    });
  });

  describe('when setValueAs is presented with inputs', () => {
    it('should not update inputs correctly with useForm defaultValues', () => {
      const App = () => {
        const { register } = useForm({
          defaultValues: {
            test: '1234',
          },
        });
        return (
          <form>
            <input
              {...register('test', { setValueAs: (value) => value + '5' })}
            />
          </form>
        );
      };

      render(<App />);

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '1234',
      );
    });

    it('should not update inputs correctly with reset', () => {
      const App = () => {
        const { register, reset } = useForm();

        React.useEffect(() => {
          reset({
            test: '1234',
          });
        }, [reset]);

        return (
          <form>
            <input
              {...register('test', { setValueAs: (value) => value + '5' })}
            />
          </form>
        );
      };

      render(<App />);

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '1234',
      );
    });

    it('should populate input as string and submit as datetime object ', async () => {
      let submitData: unknown;

      const App = () => {
        const { register, handleSubmit } = useForm<{
          test: Date | string;
        }>({
          defaultValues: {
            test: '2020-10-10',
          },
        });

        return (
          <form
            onSubmit={handleSubmit((data) => {
              submitData = data;
            })}
          >
            <input {...register('test', { valueAsDate: true })} />
            <button>Submit</button>
          </form>
        );
      };

      render(<App />);

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '2020-10-10',
      );

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(submitData).toEqual({
          test: new Date('2020-10-10'),
        }),
      );
    });
  });

  it('should not throw error when register with non input ref', () => {
    const App = () => {
      const { register } = useForm();

      return (
        <div {...register('test')}>
          <h1>test</h1>
        </div>
      );
    };

    render(<App />);
  });

  it('should be able to register input/textarea/select when embedded deeply', async () => {
    let submitData: unknown;

    const Select = React.forwardRef<HTMLDivElement>((_, ref) => {
      return (
        <div ref={ref}>
          <select data-testid="select">
            <option value={''}></option>
            <option value={'select'}>select</option>
          </select>
        </div>
      );
    });

    Select.displayName = 'Select';

    const Input = React.forwardRef<HTMLDivElement>((_, ref) => {
      return (
        <div ref={ref}>
          <input data-testid="input" />
        </div>
      );
    });

    Input.displayName = 'Input';

    const Textarea = React.forwardRef<HTMLDivElement>((_, ref) => {
      return (
        <div ref={ref}>
          <textarea data-testid="textarea" />
        </div>
      );
    });

    Textarea.displayName = 'Textarea';

    const App = () => {
      const { register, handleSubmit } = useForm({
        defaultValues: {
          input: 'input',
          select: 'select',
          textarea: 'textarea',
        },
      });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            submitData = data;
          })}
        >
          <Input {...register('input')} />
          <Select {...register('select')} />
          <Textarea {...register('textarea')} />
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(submitData).toEqual({
        input: 'input',
        select: 'select',
        textarea: 'textarea',
      }),
    );

    expect((screen.getByTestId('input') as HTMLInputElement).value).toEqual(
      'input',
    );
    expect((screen.getByTestId('select') as HTMLSelectElement).value).toEqual(
      'select',
    );
    expect(
      (screen.getByTestId('textarea') as HTMLTextAreaElement).value,
    ).toEqual('textarea');
  });

  it('should should trigger deps validation', async () => {
    const App = () => {
      const { register, getValues, formState } = useForm<{
        firstName: string;
        lastName: string;
      }>({
        mode: 'onChange',
      });

      return (
        <div>
          <input
            {...register('firstName', {
              validate: (value) => {
                return getValues('lastName') === value;
              },
            })}
          />
          {formState.errors.firstName && <p>error</p>}
          <input {...register('lastName', { deps: ['firstName'] })} />
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByText('error')).toBeVisible();

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: {
        value: 'test',
      },
    });

    await waitForElementToBeRemoved(screen.queryByText('error'));
  });

  it('should should trigger deps validation with schema validation', async () => {
    const App = () => {
      const { register, formState } = useForm<{
        firstName: string;
        lastName: string;
      }>({
        mode: 'onChange',
        resolver: (values) => {
          if (values.firstName === values.lastName) {
            return {
              errors: {},
              values,
            };
          } else {
            return {
              errors: {
                firstName: {
                  type: 'error',
                },
                lastName: {
                  type: 'error',
                },
              },
              values,
            };
          }
        },
      });

      return (
        <div>
          <input {...register('firstName')} />
          {formState.errors.firstName && <p>firstName error</p>}
          <input {...register('lastName', { deps: ['firstName'] })} />
          {formState.errors.lastName && <p>lastName error</p>}
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByText('firstName error')).toBeVisible();

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: {
        value: 'test1',
      },
    });

    expect(await screen.findByText('lastName error')).toBeVisible();

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: {
        value: 'test',
      },
    });

    await waitFor(() =>
      expect(screen.queryByText(/error/)).not.toBeInTheDocument(),
    );
  });

  it('should trigger custom onChange event', async () => {
    const onChange = jest.fn();

    const App = () => {
      const { register } = useForm();

      return (
        <form>
          <input {...register('test', { onChange })} />
        </form>
      );
    };

    render(<App />);

    fireEvent.blur(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'value',
      },
    });

    expect(onChange).toBeCalledTimes(0);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'value',
      },
    });

    expect(onChange).toBeCalledTimes(1);
    expect(onChange).toBeCalledWith(
      expect.objectContaining({
        bubbles: true,
        cancelable: false,
        currentTarget: null,
        type: 'change',
      }),
    );
  });

  it('should trigger custom onBlur event', async () => {
    const onBlur = jest.fn();

    const App = () => {
      const { register } = useForm();

      return (
        <form>
          <input {...register('test', { onBlur })} />
        </form>
      );
    };

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'value',
      },
    });

    expect(onBlur).toBeCalledTimes(0);

    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    expect(onBlur).toBeCalledTimes(1);
    expect(onBlur).toBeCalledWith(
      expect.objectContaining({
        bubbles: true,
        cancelable: false,
        currentTarget: null,
        type: 'blur',
      }),
    );
  });

  it('should not programmatically set input file value with FileList', async () => {
    function App() {
      const { register, watch } = useForm();
      const moreDetail = watch('toggle');

      return (
        <form>
          <input type="checkbox" {...register('toggle')} />

          {moreDetail && (
            <div>
              <label>Interests</label>
              <input
                type="file"
                {...register('Interests')}
                placeholder={'test'}
              />
            </div>
          )}
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('checkbox'));

    expect(await screen.findByPlaceholderText('test')).toBeVisible();

    fireEvent.click(screen.getByRole('checkbox'));

    await waitFor(() =>
      expect(screen.queryByPlaceholderText('test')).not.toBeInTheDocument(),
    );

    fireEvent.click(screen.getByRole('checkbox'));

    expect(await screen.findByPlaceholderText('test')).toBeVisible();
  });

  it('should set value before custom onChange', () => {
    const test = jest.fn();

    const App = () => {
      const { register, getValues } = useForm();

      return (
        <input
          {...register('test', {
            onChange: () => {
              test(getValues());
            },
          })}
        />
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });

    expect(test).toBeCalledWith({
      test: 'test',
    });
  });
});


================================================
File: /src/__tests__/useForm/clearErrors.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { useForm } from '../../useForm';

describe('clearErrors', () => {
  it('should remove error', () => {
    const { result } = renderHook(() => useForm<{ input: string }>());
    act(() => {
      result.current.register('input');
      result.current.setError('input', {
        type: 'test',
        message: 'message',
      });
    });

    act(() => result.current.clearErrors('input'));

    expect(result.current.formState.errors).toEqual({});
  });

  it('should remove nested error', () => {
    const { result } = renderHook(() =>
      useForm<{ input: { nested: string } }>(),
    );
    result.current.formState.errors;
    act(() =>
      result.current.setError('input.nested', {
        type: 'test',
      }),
    );
    expect(result.current.formState.errors.input?.nested).toBeDefined();
    act(() => result.current.clearErrors('input.nested'));
    expect(result.current.formState.errors.input?.nested).toBeUndefined();
  });

  it('should remove deep nested error and set it to undefined', async () => {
    let currentErrors = {};

    const Component = () => {
      const {
        register,
        formState: { errors },
        trigger,
        clearErrors,
      } = useForm<{
        test: { data: string };
      }>();

      currentErrors = errors;
      return (
        <div>
          <input type="text" {...register('test.data', { required: true })} />
          <button type={'button'} onClick={() => trigger()}>
            submit
          </button>
          <button type={'button'} onClick={() => clearErrors(['test.data'])}>
            clear
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(currentErrors).toEqual({
        test: {
          data: {
            message: '',
            ref: screen.getByRole('textbox'),
            type: 'required',
          },
        },
      }),
    );

    fireEvent.click(screen.getByRole('button', { name: 'clear' }));

    expect(currentErrors).toEqual({});
  });

  it('should remove specified errors', () => {
    const { result } = renderHook(() =>
      useForm<{
        input: string;
        input1: string;
        input2: string;
        nest: { data: string; data1: string };
      }>(),
    );

    result.current.formState.errors;

    const error = {
      type: 'test',
      message: 'message',
    };

    act(() => {
      result.current.register('input');
      result.current.register('input1');
      result.current.register('input2');
      result.current.setError('input', error);
      result.current.setError('input1', error);
      result.current.setError('input2', error);

      result.current.register('nest.data');
      result.current.register('nest.data1');
      result.current.setError('nest.data', error);
      result.current.setError('nest.data1', error);
    });

    const errors = {
      input: {
        ...error,
        ref: {
          name: 'input',
        },
      },
      input1: {
        ...error,
        ref: {
          name: 'input1',
        },
      },
      input2: {
        ...error,
        ref: {
          name: 'input2',
        },
      },
      nest: {
        data: {
          ...error,
          ref: {
            name: 'nest.data',
          },
        },
        data1: {
          ...error,
          ref: {
            name: 'nest.data1',
          },
        },
      },
    };
    expect(result.current.formState.errors).toEqual(errors);

    act(() => result.current.clearErrors(['input', 'input1', 'nest.data']));
    expect(result.current.formState.errors).toEqual({
      input2: errors.input2,
      nest: {
        data1: errors.nest.data1,
      },
    });
  });

  it('should remove all error', () => {
    const { result } = renderHook(() =>
      useForm<{ input: string; input1: string; input2: string }>(),
    );

    result.current.formState.errors;

    const error = {
      type: 'test',
      message: 'message',
    };
    act(() => result.current.setError('input', error));
    act(() => result.current.setError('input1', error));
    act(() => result.current.setError('input2', error));
    expect(result.current.formState.errors).toEqual({
      input: {
        ...error,
        ref: undefined,
        types: undefined,
      },
      input1: {
        ...error,
        ref: undefined,
        types: undefined,
      },
      input2: {
        ...error,
        ref: undefined,
        types: undefined,
      },
    });

    act(() => result.current.clearErrors());
    expect(result.current.formState.errors).toEqual({});
  });

  it('should prevent the submission if there is a custom error', async () => {
    const submit = jest.fn();
    const { result } = renderHook(() =>
      useForm<{ data: string; whatever: string }>(),
    );

    result.current.register('data');

    act(() => {
      result.current.setError('whatever', { type: 'server' });
    });

    await act(async () => await result.current.handleSubmit(submit)());
    expect(submit).not.toBeCalled();

    act(() => {
      result.current.clearErrors('whatever');
    });

    await act(async () => await result.current.handleSubmit(submit)());
    expect(submit).toBeCalled();
  });

  it('should update isValid to true with setError', async () => {
    const App = () => {
      const {
        formState: { isValid },
        setError,
        clearErrors,
      } = useForm({
        mode: 'onChange',
      });

      return (
        <div>
          <button
            onClick={() => {
              setError('test', { type: 'test' });
            }}
          >
            setError
          </button>

          <button
            onClick={() => {
              clearErrors();
            }}
          >
            clearError
          </button>
          {isValid ? 'yes' : 'no'}
        </div>
      );
    };

    render(<App />);

    expect(await screen.findByText('yes')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'setError' }));

    expect(await screen.findByText('no')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'clearError' }));

    expect(await screen.findByText('no')).toBeVisible();
  });

  it('should be able to clear root error', () => {
    const App = () => {
      const { clearErrors } = useForm();

      React.useEffect(() => {
        clearErrors('root');
        clearErrors('root.other');
      }, [clearErrors]);

      return null;
    };

    render(<App />);
  });
});


================================================
File: /src/__tests__/useForm/formState.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Controller } from '../../controller';
import { Control, FormState, UseFormGetFieldState } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

describe('formState', () => {
  describe('isValid', () => {
    it('should return isValid correctly with resolver', async () => {
      let isValidValue = false;

      const Component = () => {
        const {
          register,
          formState: { isValid },
        } = useForm<{ test: string }>({
          mode: 'onChange',
          resolver: async (data) => {
            return {
              values: data.test ? data : {},
              errors: data.test
                ? {}
                : {
                    test: {
                      message: 'issue',
                      type: 'test',
                    },
                  },
            };
          },
        });

        isValidValue = isValid;
        return <input {...register('test')} />;
      };

      render(<Component />);

      expect(isValidValue).toBeFalsy();

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      await waitFor(() => expect(isValidValue).toBeTruthy());
    });

    it('should return true for onBlur mode by default', async () => {
      const App = () => {
        const {
          formState: { isValid },
        } = useForm<{ test: string }>({
          mode: VALIDATION_MODE.onBlur,
        });

        return <p>{isValid ? 'valid' : 'invalid'}</p>;
      };

      render(<App />);

      expect(await screen.findByText('valid')).toBeVisible();
    });

    it('should return true for onChange mode by default', async () => {
      const App = () => {
        const {
          formState: { isValid },
        } = useForm<{ test: string }>({
          mode: VALIDATION_MODE.onChange,
        });

        return <p>{isValid ? 'valid' : 'invalid'}</p>;
      };

      render(<App />);

      expect(await screen.findByText('valid')).toBeVisible();
    });

    it('should return true for all mode by default', async () => {
      const App = () => {
        const {
          formState: { isValid },
        } = useForm<{ test: string }>({
          mode: VALIDATION_MODE.all,
        });

        return <p>{isValid ? 'valid' : 'invalid'}</p>;
      };

      render(<App />);

      expect(await screen.findByText('valid')).toBeVisible();
    });

    it('should return false when default value is not valid value', async () => {
      const { result } = renderHook(() => {
        const methods = useForm<{ input: string; issue: string }>({
          mode: VALIDATION_MODE.onChange,
        });

        methods.formState.isValid;

        return methods;
      });

      await act(async () => {
        result.current.register('issue', { required: true });
        result.current.setValue('issue', '', { shouldValidate: true });
      });

      expect(result.current.formState.isValid).toBeFalsy();
    });

    it('should return false when custom register with validation', async () => {
      const { result } = renderHook(() =>
        useForm<{ input: string; issue: string }>({
          mode: VALIDATION_MODE.onChange,
        }),
      );

      result.current.formState.isValid;

      await act(async () => {
        result.current.register('issue', { required: true });
      });

      expect(result.current.formState.isValid).toBeFalsy();
    });

    it('should update valid when toggle Controller', async () => {
      const App = () => {
        const {
          control,
          watch,
          formState: { isValid },
        } = useForm({
          mode: 'onChange',
          shouldUnregister: true,
        });
        const test = watch('test');

        return (
          <div>
            <p>{isValid ? 'valid' : 'invalid'}</p>
            <Controller
              control={control}
              rules={{ required: true }}
              render={({ field }) => (
                <select {...field} data-testid="select">
                  <option value={''}></option>
                  <option value={'test'}>test</option>
                  <option value={'test1'}>test1</option>
                </select>
              )}
              name={'test'}
            />

            {test === 'test1' && (
              <>
                <Controller
                  control={control}
                  render={({ field }) => <input {...field} />}
                  rules={{ required: true }}
                  name={'first.test'}
                />
                <Controller
                  control={control}
                  render={({ field }) => <input {...field} />}
                  rules={{ required: true }}
                  name={'first.test1'}
                />
              </>
            )}
          </div>
        );
      };

      render(<App />);

      expect(screen.getByText('invalid')).toBeVisible();

      fireEvent.change(screen.getByTestId('select'), {
        target: {
          value: 'test',
        },
      });

      expect(await screen.findByText('valid')).toBeVisible();

      fireEvent.change(screen.getByTestId('select'), {
        target: {
          value: 'test1',
        },
      });

      expect(await screen.findByText('invalid')).toBeVisible();

      fireEvent.change(screen.getByTestId('select'), {
        target: {
          value: 'test',
        },
      });

      expect(await screen.findByText('valid')).toBeVisible();

      fireEvent.change(screen.getByTestId('select'), {
        target: {
          value: 'test1',
        },
      });

      expect(await screen.findByText('invalid')).toBeVisible();
    });
  });

  it('should be a proxy object that returns undefined for unknown properties', () => {
    const { result } = renderHook(() => useForm());

    // @ts-expect-error it's expected for an undefined property to be a typescript error
    expect(result.current.formState.nonExistentProperty).toBeUndefined();
  });

  it('should be a proxy object that properly implements the has trap', () => {
    const { result } = renderHook(() => useForm());

    expect('nonExistentProperty' in result.current.formState).toBeFalsy();
  });

  it('should be a proxy object that hasOwnProperty works on', () => {
    const { result } = renderHook(() => useForm());

    expect(result.current.formState).toHaveProperty('hasOwnProperty');
  });

  describe('when using with reset API', () => {
    type FormValues = {
      foo: string;
      foo1: string;
    };

    it('should render isValid as true with reset at useEffect with valid data', async () => {
      function Component() {
        const {
          register,
          control,
          formState: { isValid },
          reset,
        } = useForm<FormValues>({
          mode: 'onBlur',
          defaultValues: { foo: '', foo1: '' },
        });

        React.useEffect(() => {
          reset({ foo: 'test', foo1: 'test2' });
        }, [reset]);

        return (
          <div>
            <h2>Form with controlled input</h2>
            <Controller
              name="foo"
              rules={{ required: true }}
              control={control}
              render={({ field }) => <input {...field} />}
            />
            <input {...register('foo1', { required: true })} />
            {isValid ? 'valid' : 'nope'}
          </div>
        );
      }

      render(<Component />);

      expect(await screen.findByText('valid')).toBeVisible();
    });

    it('should render isValid as false with reset at useEffect with valid data', async () => {
      function Component() {
        const {
          register,
          control,
          formState: { isValid },
          reset,
        } = useForm<FormValues>({
          mode: 'onBlur',
          defaultValues: { foo: '', foo1: '' },
        });

        React.useEffect(() => {
          reset({ foo: 'test', foo1: '' });
        }, [reset]);

        return (
          <div>
            <h2>Form with controlled input</h2>
            <Controller
              name="foo"
              rules={{ required: true }}
              control={control}
              render={({ field }) => <input {...field} />}
            />
            <input {...register('foo1', { required: true })} />
            {isValid ? 'valid' : 'nope'}
          </div>
        );
      }

      render(<Component />);

      expect(await screen.findByText('nope')).toBeVisible();
    });
  });

  it('should not update form state when there is a promise reject', async () => {
    const rejectPromiseFn = jest
      .fn()
      .mockRejectedValue(new Error('this is an error'));

    const App = () => {
      const {
        register,
        handleSubmit,
        formState: { isSubmitSuccessful, isSubmitted },
      } = useForm();

      return (
        <form>
          <input {...register('test')} />
          <p>{isSubmitted ? 'isSubmitted' : 'no'}</p>
          <p>
            {isSubmitSuccessful
              ? 'isSubmitSuccessful'
              : 'isNotSubmitSuccessful'}
          </p>
          <button
            type={'button'}
            onClick={() => handleSubmit(rejectPromiseFn)().catch(noop)}
          >
            Submit
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(screen.getByText('isNotSubmitSuccessful')).toBeVisible();
  });

  it('should update isValid even with mode set to onSubmit', async () => {
    const App = () => {
      const {
        register,
        handleSubmit,
        formState: { isValid, errors },
      } = useForm({
        defaultValues: {
          test: '',
        },
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input {...register('test', { required: true })} />
          {errors.test && <p>error</p>}

          <p>{isValid ? 'valid' : 'invalid'}</p>

          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    await waitFor(() => screen.getByText('invalid'));
    expect(screen.queryByText('error')).not.toBeInTheDocument();
    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'value',
      },
    });

    await waitFor(() => screen.getByText('valid'));
    expect(screen.queryByText('error')).not.toBeInTheDocument();
    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '',
      },
    });

    fireEvent.click(screen.getByRole('button'));
    await waitFor(() =>
      expect(screen.queryByText('error')).toBeInTheDocument(),
    );
    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'value',
      },
    });
    await waitFor(() =>
      expect(screen.queryByText('error')).not.toBeInTheDocument(),
    );
  });

  it('should update correct isValid formState with dynamic fields', async () => {
    const Component = () => {
      const {
        register,
        control,
        formState: { isValid },
      } = useForm<{
        list: {
          firstName: string;
          lastName: string;
        }[];
        test: string;
        test1: string;
        test2: string;
        test3: string;
      }>({
        mode: 'onChange',
      });
      const { append, fields } = useFieldArray({
        control,
        name: 'list',
      });

      return (
        <form>
          <Controller
            render={({ field }) => (
              <input {...field} placeholder={field.name} />
            )}
            name={'test'}
            rules={{ required: true }}
            control={control}
            defaultValue={''}
          />
          <input
            {...register('test1', { required: true })}
            placeholder={'test1'}
          />
          <input {...register('test2')} placeholder={'test2'} />
          <Controller
            render={({ field }) => (
              <input {...field} placeholder={field.name} />
            )}
            name={'test3'}
            control={control}
            defaultValue={''}
          />
          {fields.map((field, index) => {
            return (
              <div key={field.id}>
                <Controller
                  render={({ field }) => (
                    <input {...field} placeholder={field.name} />
                  )}
                  name={`list.${index}.firstName` as const}
                  control={control}
                  rules={{ required: true }}
                />
                <input
                  {...register(`list.${index}.lastName` as const, {
                    required: true,
                  })}
                  placeholder={`list.${index}.lastName`}
                />
              </div>
            );
          })}
          <button
            type={'button'}
            onClick={() =>
              append({
                firstName: '',
                lastName: '',
              })
            }
          >
            append
          </button>
          <p>{isValid ? 'valid' : 'inValid'}</p>
        </form>
      );
    };

    render(<Component />);

    expect(await screen.findByText('inValid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('test'), {
      target: { value: '1' },
    });
    fireEvent.change(screen.getByPlaceholderText('test1'), {
      target: { value: '1' },
    });

    expect(await screen.findByText('valid')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('inValid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('list.0.firstName'), {
      target: { value: '1' },
    });
    fireEvent.change(screen.getByPlaceholderText('list.0.lastName'), {
      target: { value: '1' },
    });

    expect(await screen.findByText('valid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('list.0.lastName'), {
      target: { value: '' },
    });

    expect(await screen.findByText('inValid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('list.0.lastName'), {
      target: { value: '1' },
    });

    expect(await screen.findByText('valid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('list.0.firstName'), {
      target: { value: '' },
    });

    expect(await screen.findByText('inValid')).toBeVisible();

    fireEvent.change(screen.getByPlaceholderText('list.0.firstName'), {
      target: { value: '1' },
    });

    expect(await screen.findByText('valid')).toBeVisible();
  });

  it('should remind isSubmitting when form is invalid', async () => {
    const submittingState: boolean[] = [];

    function App() {
      const {
        register,
        formState: { isSubmitting },
        handleSubmit,
      } = useForm();

      submittingState.push(isSubmitting);

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input
            {...register('value', { required: true })}
            defaultValue="Any default value!"
          />
          <button>Submit</button>
        </form>
      );
    }

    render(<App />);

    await act(async () => {
      fireEvent.click(screen.getByRole('button'));
    });

    expect(submittingState).toEqual([false, true, false]);
  });

  describe('when defaultValue supplied', () => {
    it('should update isValid to true for validation with inline defaultValue', async () => {
      function App() {
        const {
          register,
          formState: { isValid },
        } = useForm({
          mode: 'onChange',
        });

        return (
          <form>
            <input
              {...register('value', { required: true })}
              defaultValue="Any default value!"
            />
            <p>isValid = {isValid ? 'true' : 'false'}</p>
          </form>
        );
      }

      render(<App />);

      expect(await screen.findByText('isValid = true')).toBeVisible();
    });

    it('should update isValid to true for Controller validation', async () => {
      function App() {
        const {
          control,
          formState: { isValid },
        } = useForm({
          mode: 'onChange',
        });

        return (
          <form>
            <Controller
              control={control}
              render={({ field }) => <input {...field} />}
              name={'test'}
              defaultValue="Any default value!"
            />
            <p>isValid = {isValid ? 'true' : 'false'}</p>
            <button>Submit</button>
          </form>
        );
      }

      render(<App />);

      expect(await screen.findByText('isValid = true')).toBeVisible();
    });
  });

  it('should not update dirty fields during blur event', async () => {
    let dirtyFieldsState = {};

    const App = () => {
      const {
        handleSubmit,
        register,
        formState: { dirtyFields },
      } = useForm();

      dirtyFieldsState = dirtyFields;

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input
            {...register('test', { setValueAs: (value) => value + '1' })}
          />
          <input type="submit" />
        </form>
      );
    };

    render(<App />);

    fireEvent.blur(screen.getByRole('textbox'));

    expect(dirtyFieldsState).toEqual({});
  });

  it('should update isDirty with getFieldState at child component', () => {
    type FormValues = {
      test?: string;
    };

    function Output({
      getFieldState,
      formState,
    }: {
      getFieldState: UseFormGetFieldState<FormValues>;
      formState: FormState<FormValues>;
    }) {
      const { isDirty } = getFieldState('test', formState);

      return <p>{isDirty.toString()}</p>;
    }

    const TextInput = ({ control }: { control: Control<FormValues> }) => {
      const { field } = useController({
        name: 'test',
        control,
      });

      return <input {...field} type="text" />;
    };

    function App() {
      const { formState, getFieldState, control } = useForm<FormValues>({
        values: {},
      });
      formState.isDirty;

      return (
        <form>
          <TextInput control={control} />
          <Output getFieldState={getFieldState} formState={formState} />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '123456',
      },
    });

    waitFor(() => {
      screen.getByText('true');
    });
  });

  it('should recompute isDirty after toggling disabled', async () => {
    let isDirty: null | boolean = null;

    const App = () => {
      const defaultValues = { name: 'initial', disableName: false };
      const { formState, register, watch } = useForm({ defaultValues });

      isDirty = formState.isDirty;

      const disableName = watch('disableName', defaultValues.disableName);

      return (
        <form>
          <input type="text" {...register('name', { disabled: disableName })} />
          <input type="checkbox" {...register('disableName')} />
        </form>
      );
    };

    render(<App />);

    const checkbox = screen.getByRole('checkbox');

    fireEvent.click(checkbox);

    expect(isDirty).toBe(true);

    fireEvent.click(checkbox);

    expect(isDirty).toBe(false);
  });

  it('should prevent dirty from updating when the form is disabled', async () => {
    function App() {
      const {
        register,
        control,
        formState: { isDirty, dirtyFields },
      } = useForm<{
        test: { firstName: string; lastName: string }[];
      }>({
        disabled: true,
        defaultValues: {
          test: [{ firstName: 'Bill', lastName: 'Luo' }],
        },
      });
      const { fields } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form>
          <ul>
            {fields.map((item, index) => {
              return (
                <li key={item.id}>
                  <input
                    {...register(`test.${index}.firstName`, { required: true })}
                  />
                  <Controller
                    render={({ field }) => <input {...field} />}
                    name={`test.${index}.lastName`}
                    control={control}
                  />
                </li>
              );
            })}
          </ul>
          <p>{isDirty ? 'dirty' : 'notDirty'}</p>
          <p>{Object.keys(dirtyFields).length}</p>
        </form>
      );
    }

    render(<App />);

    await screen.getByText('notDirty');
    await screen.getByText('0');
  });

  describe('when delay config is set', () => {
    const message = 'required.';

    it('should only show error after 500ms with register', async () => {
      jest.useFakeTimers();

      const App = () => {
        const {
          register,
          formState: { errors },
        } = useForm<{
          test: string;
        }>({
          delayError: 500,
          mode: 'onChange',
        });

        return (
          <div>
            <input
              {...register('test', {
                maxLength: 4,
              })}
            />
            {errors.test && <p>{message}</p>}
          </div>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '123456',
        },
      });

      expect(screen.queryByText(message)).not.toBeInTheDocument();

      jest.advanceTimersByTime(500);

      expect(await screen.findByText(message)).toBeVisible();
    });

    it('should only show error after 500ms with Controller', async () => {
      const App = () => {
        const {
          control,
          formState: { errors },
        } = useForm<{
          test: string;
        }>({
          delayError: 500,
          mode: 'onChange',
        });

        return (
          <div>
            <Controller
              render={({ field }) => <input {...field} />}
              rules={{
                maxLength: 4,
              }}
              control={control}
              name="test"
              defaultValue=""
            />
            {errors.test && <p>{message}</p>}
          </div>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '123456',
        },
      });

      expect(screen.queryByText(message)).not.toBeInTheDocument();

      act(() => {
        jest.advanceTimersByTime(500);
      });

      expect(await screen.findByText(message)).toBeVisible();
    });

    it('should prevent error from showing once input is validated', async () => {
      jest.useFakeTimers();

      const App = () => {
        const {
          register,
          formState: { errors, isDirty },
        } = useForm<{
          test: string;
        }>({
          delayError: 500,
          mode: 'onChange',
        });

        return (
          <div>
            <p>Dirty: {isDirty.toString()}</p>
            <input
              {...register('test', {
                maxLength: 4,
              })}
            />
            {errors.test && <p>{message}</p>}
          </div>
        );
      };

      render(<App />);

      const input = screen.getByRole('textbox');

      fireEvent.change(input, {
        target: {
          value: '123456',
        },
      });

      expect(await screen.findByText('Dirty: true')).toBeVisible();
      expect(screen.queryByText(message)).not.toBeInTheDocument();

      fireEvent.change(input, {
        target: {
          value: '123',
        },
      });
      expect(screen.queryByText(message)).not.toBeInTheDocument();

      await act(async () => {
        jest.advanceTimersByTime(500);
      });

      expect(screen.queryByText(message)).not.toBeInTheDocument();
    });

    describe('when delayError is provided', () => {
      it('should only show error after 500ms with register and render formState instantly', async () => {
        jest.useFakeTimers();

        const message = 'required.';

        const App = () => {
          const {
            register,
            formState: { errors, isValid },
          } = useForm<{
            test: string;
          }>({
            delayError: 500,
            mode: 'onChange',
          });

          return (
            <div>
              {isValid ? 'valid' : 'inValid'}
              <input
                {...register('test', {
                  required: true,
                  maxLength: 4,
                })}
              />
              {errors.test && <p>{message}</p>}
            </div>
          );
        };

        render(<App />);

        fireEvent.change(screen.getByRole('textbox'), {
          target: {
            value: '123',
          },
        });

        expect(screen.queryByText(message)).not.toBeInTheDocument();

        expect(await screen.findByText('valid')).toBeVisible();

        await act(async () => {
          fireEvent.change(screen.getByRole('textbox'), {
            target: {
              value: '',
            },
          });
        });

        await act(async () => {
          await waitFor(() => screen.getByText('inValid'));
        });

        expect(screen.queryByText(message)).toBeNull();

        act(() => {
          jest.advanceTimersByTime(500);
        });

        expect(await screen.findByText(message)).toBeVisible();
      });
    });
  });

  it('should return updated value with NaN data type', async () => {
    function App() {
      const { register, formState } = useForm({
        mode: 'onChange',
        defaultValues: {
          value: '',
        },
      });

      return (
        <form>
          {formState.errors.value && <p>error</p>}
          <input
            {...register('value', {
              min: 0,
              valueAsNumber: true,
              validate: (value) => !Number.isNaN(value),
            })}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '2a',
      },
    });

    await waitFor(() => {
      screen.getByText('error');
    });
  });

  it('should only trigger validation on blur', async () => {
    function App() {
      const { register, formState } = useForm({
        mode: 'onBlur',
        defaultValues: {
          value: '',
        },
      });

      return (
        <form>
          {formState.errors.value && <p>error</p>}
          <input
            {...register('value', {
              min: 0,
              valueAsNumber: true,
              validate: (value) => !Number.isNaN(value),
            })}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '2a',
      },
    });

    await waitFor(() => {
      expect(screen.queryByText('error')).toBeNull();
    });

    fireEvent.blur(screen.getByRole('textbox'), {
      target: {
        value: '2a',
      },
    });

    await waitFor(() => {
      screen.getByText('error');
    });
  });
});


================================================
File: /src/__tests__/useForm/resolver.test.tsx
================================================
import React from 'react';
import { act, fireEvent, render, screen } from '@testing-library/react';

import { useForm } from '../../useForm';
import noop from '../../utils/noop';
import sleep from '../../utils/sleep';

describe('resolver', () => {
  it('should update context within the resolver', async () => {
    type FormValues = {
      test: string;
    };

    const App = () => {
      const [test, setTest] = React.useState('');
      const [data, setData] = React.useState({});
      const { handleSubmit } = useForm<FormValues>({
        resolver: (_, context) => {
          return {
            errors: {},
            values: context as FormValues,
          };
        },
        context: {
          test,
        },
      });

      return (
        <>
          <input
            value={test}
            onChange={(e) => {
              setTest(e.target.value);
            }}
          />
          <button onClick={handleSubmit((data) => setData(data))}>Test</button>
          <p>{JSON.stringify(data)}</p>
        </>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });
    fireEvent.click(screen.getByRole('button'));

    expect(
      await screen.findByText('{"test":"test"}', undefined, { timeout: 3000 }),
    ).toBeVisible();
  });

  it('should support resolver schema switching', async () => {
    type FormValues = {
      test: string;
    };

    const fakeResolver = (schema: boolean) => async () => {
      return schema
        ? {
            values: { test: 'ok' },
            errors: {},
          }
        : {
            values: {},
            errors: {
              test: {
                type: 'test',
                value: { message: 'wrong', type: 'test' },
              },
            },
          };
    };

    const App = () => {
      const [schema, setSchema] = React.useState(false);
      const [submit, setSubmit] = React.useState(false);
      const {
        register,
        handleSubmit,
        formState: { errors },
      } = useForm<FormValues>({
        resolver: fakeResolver(schema),
      });

      return (
        <form
          onSubmit={handleSubmit(() => {
            setSubmit(true);
          })}
        >
          <input {...register('test')} />
          {errors.test && <p>Error</p>}
          {submit && <p>Submitted</p>}
          <button onClick={() => setSchema(!schema)}>Toggle</button>
          <button>Submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

    expect(await screen.findByText('Error')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'Toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

    expect(await screen.findByText('Submitted')).toBeVisible();
  });

  it('should be called with the shouldUseNativeValidation option to true', async () => {
    const test = jest.fn();
    const resolver = (a: any, b: any, c: any) => {
      test(a, b, c);
      return {
        errors: {},
        values: {},
      };
    };

    const App = () => {
      const { register, handleSubmit } = useForm({
        resolver: async (data, context, options) =>
          resolver(data, context, options),
        shouldUseNativeValidation: true,
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input {...register('test')} />
          <button>Submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(test.mock.calls[0][2]).toEqual(
      expect.objectContaining({ shouldUseNativeValidation: true }),
    );
  });

  it('should avoid the problem of race condition', async () => {
    jest.useFakeTimers();

    const test = jest.fn();
    let errorsObject = {};

    const resolver = async (a: any, b: any, c: any) => {
      test(a, b, c);

      if (a.test !== 'OK') {
        await sleep(100);
        return {
          errors: {
            test: {
              type: 'test',
              value: { message: 'wrong', type: 'test' },
            },
          },
          values: {},
        };
      }

      return {
        errors: {},
        values: { test: a.test },
      };
    };

    const App = () => {
      const {
        register,
        formState: { errors },
      } = useForm({
        resolver,
        mode: 'onChange',
      });
      errorsObject = errors;

      return (
        <form>
          <input type="text" {...register('test')} />
        </form>
      );
    };

    render(<App />);

    const inputElm = screen.getByRole('textbox');

    fireEvent.change(inputElm, {
      target: {
        value: 'O',
      },
    });

    fireEvent.change(inputElm, {
      target: {
        value: 'OK',
      },
    });

    await act(async () => {
      jest.advanceTimersByTime(200);
    });

    expect(errorsObject).toEqual({});
  });
});


================================================
File: /src/__tests__/useForm/setError.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { DeepMap, ErrorOption, FieldError, GlobalError } from '../../types';
import { useForm } from '../../useForm';

describe('setError', () => {
  const tests: [string, ErrorOption, DeepMap<any, FieldError>][] = [
    [
      'should only set an error when it is not existed',
      { type: 'test' },
      {
        input: {
          type: 'test',
          message: undefined,
          ref: undefined,
        },
      },
    ],
    [
      'should set error message',
      { type: 'test', message: 'test' },
      {
        input: {
          type: 'test',
          message: 'test',
          ref: undefined,
          types: undefined,
        },
      },
    ],
    [
      'should set multiple error type',
      {
        types: { test1: 'test1', test2: 'test2' },
      },
      {
        input: {
          types: {
            test1: 'test1',
            test2: 'test2',
          },
          ref: undefined,
        },
      },
    ],
  ];

  it.each(tests)('%s', (_, input, output) => {
    const { result } = renderHook(() => useForm<{ input: string }>());

    result.current.formState.errors;

    act(() => {
      result.current.setError('input', input);
    });
    expect(result.current.formState.errors).toEqual(output);
    expect(result.current.formState.isValid).toBeFalsy();
  });

  it('should update isValid with setError', async () => {
    const App = () => {
      const {
        formState: { isValid },
        setError,
      } = useForm({
        mode: 'onChange',
      });

      return (
        <div>
          <button
            type={'button'}
            onClick={() => {
              setError('test', { type: 'test' });
            }}
          >
            setError
          </button>
          {isValid ? 'yes' : 'no'}
        </div>
      );
    };

    render(<App />);

    expect(await screen.findByText('yes')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('no')).toBeVisible();
  });

  it('should allow to set global error', async () => {
    const onSubmit = jest.fn();

    type Errors = {
      root: {
        customError: GlobalError;
        serverError: GlobalError;
      };
    };

    type FormValues = {
      test: string;
    };

    const App = () => {
      const {
        formState: { errors },
        handleSubmit,
        setError,
      } = useForm<FormValues & Errors>({
        mode: 'onChange',
      });

      return (
        <form
          onSubmit={handleSubmit(() => {
            onSubmit();
            setError('root.serverError', {
              type: '404',
              message: 'not found',
            });
          })}
        >
          <button
            type={'button'}
            onClick={() => {
              setError('root.customError', {
                type: 'custom',
                message: 'custom error',
              });
            }}
          >
            setError
          </button>

          <p>{errors?.root?.customError?.message}</p>
          <p>{errors?.root?.serverError?.message}</p>

          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'setError' }));

    await waitFor(() => {
      screen.findByText('custom error');
    });

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() => {
      expect(onSubmit).toBeCalled();
      expect(screen.queryByText('custom error')).not.toBeInTheDocument();
    });

    await waitFor(() => {
      screen.findByText('not found');
    });
  });

  it('should allow sequential calls to set with child after ancestor', async () => {
    const { result } = renderHook(() =>
      useForm<{ input: { first: string; last: string } }>(),
    );
    result.current.formState.errors;

    act(() => {
      result.current.setError('input', {
        type: 'test',
        message: 'Some error that depends on both fields',
      });
    });

    expect(result.current.formState.errors).toEqual({
      input: {
        type: 'test',
        message: 'Some error that depends on both fields',
        ref: undefined,
      },
    });

    act(() => {
      result.current.setError('input.first', {
        type: 'test',
        message: 'Name must be capitalized',
      });
    });

    expect(result.current.formState.errors).toEqual({
      input: {
        type: 'test',
        message: 'Some error that depends on both fields',
        ref: undefined,
        first: {
          type: 'test',
          message: 'Name must be capitalized',
          ref: undefined,
        },
      },
    });
  });

  it('should allow sequential calls to set with ancestor after child', async () => {
    const { result } = renderHook(() =>
      useForm<{ input: { first: string; last: string } }>(),
    );

    result.current.formState.errors;

    act(() => {
      result.current.setError('input.first', {
        type: 'test',
        message: 'Name must be capitalized',
      });
    });

    expect(result.current.formState.errors).toEqual({
      input: {
        first: {
          type: 'test',
          message: 'Name must be capitalized',
          ref: undefined,
        },
      },
    });

    act(() => {
      result.current.setError('input', {
        type: 'test',
        message: 'Some error that depends on both fields',
      });
    });

    expect(result.current.formState.errors).toEqual({
      input: {
        type: 'test',
        message: 'Some error that depends on both fields',
        ref: undefined,
        first: {
          type: 'test',
          message: 'Name must be capitalized',
          ref: undefined,
        },
      },
    });
  });
});


================================================
File: /src/__tests__/useForm/__snapshots__/watch.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`watch should watch correctly with useFieldArray with action and then fallback to onChange 1`] = `
[
  {
    "names": [],
  },
  {
    "names": [],
  },
  {
    "names": [
      {
        "name": "123",
      },
    ],
  },
  {
    "names": [
      {
        "name": "123",
      },
    ],
  },
  {
    "names": [
      {
        "name": "123",
      },
      {
        "name": "456",
      },
    ],
  },
  {
    "names": [
      {
        "name": "123",
      },
      {
        "name": "456",
      },
    ],
  },
  {
    "names": [
      {
        "name": "123",
      },
      {
        "name": "456",
      },
    ],
  },
  {
    "names": [
      {
        "name": "123",
      },
      {
        "name": "456",
      },
    ],
  },
]
`;


================================================
File: /src/__tests__/useForm/watch.test.tsx
================================================
import React, { useEffect } from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
} from '@testing-library/react';

import { Controller } from '../../controller';
import { Control, FieldValues } from '../../types';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import { useWatch } from '../../useWatch';
import isFunction from '../../utils/isFunction';
import noop from '../../utils/noop';

describe('watch', () => {
  it('should return undefined when input gets unregister', async () => {
    const Component = () => {
      const { register, watch, unregister } = useForm<{ test: string }>();
      const data = watch('test');

      return (
        <>
          <input {...register('test')} />
          <span>{data}</span>
          <button type="button" onClick={() => unregister('test')}>
            hide
          </button>
        </>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    expect(screen.getByText('test')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(screen.queryByText('test')).not.toBeInTheDocument();
  });

  it('should watch individual input', async () => {
    const { result } = renderHook(() => {
      return useForm<{ test: string }>({
        defaultValues: {
          test: 'data',
        },
      });
    });

    expect(result.current.watch('test')).toBe('data');

    result.current.register('test');

    await act(async () => {
      result.current.setValue('test', 'data1');
    });

    act(() => {
      expect(result.current.watch('test')).toBe('data1');
    });
  });

  it('should watch input when mode is under onChange', async () => {
    const { result } = renderHook(() => {
      return useForm<{ test: string }>({
        defaultValues: {
          test: 'data',
        },
        mode: 'onChange',
      });
    });

    expect(result.current.watch('test')).toBe('data');

    result.current.register('test');

    await act(async () => {
      result.current.setValue('test', 'data1');
    });

    act(() => {
      expect(result.current.watch('test')).toBe('data1');
    });
  });

  it('should watch input when mode is under all', async () => {
    const { result } = renderHook(() => {
      return useForm<{ test: string }>({
        defaultValues: {
          test: 'data',
        },
        mode: 'all',
      });
    });

    expect(result.current.watch('test')).toBe('data');

    result.current.register('test');

    await act(async () => {
      result.current.setValue('test', 'data1');
    });

    act(() => {
      expect(result.current.watch('test')).toBe('data1');
    });
  });

  it('should return default value if field is undefined', () => {
    renderHook(() => {
      const { watch } = useForm<{ test: string }>({
        defaultValues: { test: 'test' },
      });

      expect(watch()).toEqual({ test: 'test' });
    });
  });

  it('should return default value for single input', () => {
    const results: unknown[] = [];
    const App = () => {
      const { watch } = useForm<{ test: string }>();

      results.push(watch('test', 'default'));

      return null;
    };

    render(<App />);

    expect(results).toEqual(['default']);
  });

  it('should return array of default value for array of inputs', () => {
    const results: unknown[] = [];
    const App = () => {
      const { watch } = useForm<{ test: string; test1: string }>();

      results.push(
        watch(['test', 'test1'], {
          test: 'default',
          test1: 'test',
        }),
      );

      return null;
    };

    render(<App />);

    expect(results).toEqual([['default', 'test']]);
  });

  it('should watch array of inputs', () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; test1: string }>(),
    );

    expect(result.current.watch(['test', 'test1'])).toEqual([
      undefined,
      undefined,
    ]);

    const { ref } = result.current.register('test');
    isFunction(ref) &&
      ref({
        name: 'test',
        value: 'data1',
      });

    const { ref: ref1 } = result.current.register('test1');
    isFunction(ref1) &&
      ref1({
        name: 'test1',
        value: 'data2',
      });

    expect(result.current.watch(['test', 'test1'])).toEqual(['data1', 'data2']);
  });

  it('should watch every fields', () => {
    const { result } = renderHook(() =>
      useForm<{ test: string; test1: string }>(),
    );

    const { ref } = result.current.register('test');
    isFunction(ref) &&
      ref({
        name: 'test',
        value: 'data1',
      });

    const { ref: ref1 } = result.current.register('test1');
    isFunction(ref1) &&
      ref1({
        name: 'test1',
        value: 'data2',
      });

    expect(result.current.watch()).toEqual({ test: 'data1', test1: 'data2' });
  });

  it('should watch the entire field array with callback', () => {
    const output: any[] = [];

    const Component = () => {
      const { watch, register } = useForm<{
        test: string;
        test1: string;
      }>();

      React.useEffect(() => {
        const subscription = watch((data) => {
          data.test;
          data.test1;
          output.push(data);
        });

        return () => {
          subscription.unsubscribe();
        };
      }, [watch]);

      return <input {...register('test')} />;
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test1',
      },
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test2',
      },
    });

    expect(output).toEqual([
      {
        test: 'test',
      },
      {
        test: 'test1',
      },
      {
        test: 'test2',
      },
    ]);
  });

  it('should watch correctly with useFieldArray with action and then fallback to onChange', () => {
    type FormValues = {
      names: {
        name: string;
      }[];
    };

    const output: object[] = [];

    const Component = () => {
      const { control, handleSubmit, watch } = useForm<FormValues>({
        defaultValues: {
          names: [],
        },
      });
      const { fields, append } = useFieldArray({
        control,
        name: 'names',
      });

      const handleAddElement = () => {
        append({ name: 'test' });
      };

      output.push(watch());

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((item, index) => {
            return (
              <div key={item.id}>
                <Controller
                  control={control}
                  name={`names.${index}.name` as const}
                  render={({ field }) => <input {...field} />}
                />
              </div>
            );
          })}
          <button type="button" onClick={handleAddElement}>
            Append
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(output.at(-1)).toEqual({
      names: [],
    });

    const appendButton = screen.getByRole('button');

    fireEvent.click(appendButton);

    fireEvent.click(appendButton);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: { value: '123' },
    });

    expect(output.at(-1)).toEqual({
      names: [
        {
          name: '123',
        },
        {
          name: 'test',
        },
      ],
    });

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: { value: '456' },
    });

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(output).toMatchSnapshot();
  });

  it('should have dirty marked when watch is enabled', async () => {
    function Component() {
      const {
        register,
        formState: { isDirty },
        watch,
      } = useForm<{
        lastName: string;
      }>({
        defaultValues: { lastName: '' },
      });
      watch('lastName');

      return (
        <form>
          <input {...register('lastName')} />
          <p>{isDirty ? 'True' : 'False'}</p>
        </form>
      );
    }

    render(<Component />);

    expect(screen.getByText('False')).toBeVisible();

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });

    expect(screen.getByText('True')).toBeVisible();

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: '' },
    });

    expect(await screen.findByText('False')).toBeVisible();
  });

  it('should return deeply nested field values with defaultValues', async () => {
    let data;

    function App() {
      const { register, watch } = useForm<{
        test: {
          firstName: string;
          lastName: string;
        };
      }>({
        defaultValues: {
          test: { lastName: '', firstName: '' },
        },
      });
      data = watch();

      return (
        <form>
          <input {...register('test.lastName')} />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1234',
      },
    });

    expect(data).toEqual({
      test: {
        firstName: '',
        lastName: '1234',
      },
    });
  });

  it('should remove input value after input is unmounted with shouldUnregister: true', () => {
    const watched: unknown[] = [];
    const App = () => {
      const [show, setShow] = React.useState(true);
      const { watch, register } = useForm({
        shouldUnregister: true,
      });

      watched.push(watch());

      return (
        <div>
          {show && <input {...register('test')} />}
          <button
            onClick={() => {
              setShow(false);
            }}
          >
            toggle
          </button>
        </div>
      );
    };

    render(<App />);

    expect(watched).toEqual([{}]);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1',
      },
    });

    expect(watched).toEqual([
      {},
      {
        test: '1',
      },
    ]);

    fireEvent.click(screen.getByRole('button'));

    expect(watched).toEqual([
      {},
      {
        test: '1',
      },
      {
        test: '1',
      },
      {},
    ]);
  });

  it('should flush additional render for shouldUnregister: true', async () => {
    const watchedData: unknown[] = [];

    const App = () => {
      const { watch, reset, register } = useForm({
        shouldUnregister: true,
      });

      React.useEffect(() => {
        reset({
          test: '1234',
          data: '1234',
        });
      }, [reset]);

      const result = watch();

      watchedData.push(result);

      return (
        <div>
          <input {...register('test')} />
          {result.test && <p>{result.test}</p>}
        </div>
      );
    };

    render(<App />);

    expect(await screen.findByText('1234')).toBeVisible();

    expect(watchedData).toEqual([{}, {}, { test: '1234' }]);
  });

  it('should not be able to overwrite global watch state', () => {
    function Watcher<T extends FieldValues>({
      control,
    }: {
      control: Control<T>;
    }) {
      useWatch({
        control,
      });
      return null;
    }

    function App() {
      const { register, watch, control } = useForm({
        defaultValues: {
          firstName: '',
        },
      });
      const { firstName } = watch();

      return (
        <form>
          <p>{firstName}</p>
          <Watcher control={control} />
          <input {...register('firstName')} />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'bill',
      },
    });

    screen.getByText('bill');
  });

  it('should call the callback on every append', () => {
    interface FormValues {
      names: {
        firstName: string;
      }[];
    }
    const mockedFn = jest.fn();

    function App() {
      const { watch, control } = useForm<FormValues>({
        defaultValues: { names: [] },
      });

      const { fields, append } = useFieldArray({
        control,
        name: 'names',
      });

      useEffect(() => {
        const subscription = watch((_value, { name }) => {
          mockedFn(name, _value);
        });

        return () => {
          subscription.unsubscribe();
        };
      }, [watch]);

      const addItem = (index: number) => {
        append({ firstName: '' }, { focusName: `names.${index}.firstName` });
      };

      return (
        <form>
          <button type="button" onClick={() => addItem(fields.length)}>
            append
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));
    expect(mockedFn).toHaveBeenCalledTimes(1);

    fireEvent.click(screen.getByRole('button'));
    expect(mockedFn).toHaveBeenCalledTimes(2);
  });
});


================================================
File: /src/__tests__/useForm/reset.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { Controller } from '../../controller';
import { Control, UseFormRegister, UseFormReturn } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import { useWatch } from '../../useWatch';
import noop from '../../utils/noop';

jest.useFakeTimers();

describe('reset', () => {
  it('should reset the form and re-render the form', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    result.current.register('test');
    result.current.setValue('test', 'data');

    expect(result.current.formState.isSubmitted).toBeFalsy();
    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: 'data',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(result.current.formState.isSubmitted).toBeTruthy();
    act(() => result.current.reset());
    expect(result.current.formState.isSubmitted).toBeFalsy();
  });

  it('should reset form value', () => {
    let methods: any;
    const App = () => {
      methods = useForm<{
        test: string;
      }>();
      return (
        <form>
          <input {...methods.register('test')} />
        </form>
      );
    };
    render(<App />);

    act(() =>
      methods.reset({
        test: 'test',
      }),
    );

    expect(methods.getValues()).toEqual({
      test: 'test',
    });
  });

  it('should reset the form with callback action', () => {
    const App = () => {
      const { register, reset } = useForm({
        defaultValues: {
          test: '',
        },
      });

      React.useEffect(() => {
        reset((formValues) => {
          return {
            ...formValues,
            test: 'test',
          };
        });
      }, [reset]);

      return (
        <form>
          <input {...register('test')} />
        </form>
      );
    };

    render(<App />);

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );
  });

  it('should set array value of multiple checkbox inputs correctly', async () => {
    const App = () => {
      const { register } = useForm<{
        test: string[];
      }>({
        defaultValues: {
          test: ['1', '2'],
        },
      });

      return (
        <>
          <input type="checkbox" value={'1'} {...register('test')} />
          <input type="checkbox" value={'2'} {...register('test')} />
        </>
      );
    };

    render(<App />);

    screen
      .getAllByRole('checkbox')
      .forEach((checkbox) =>
        expect((checkbox as HTMLInputElement).checked).toBeTruthy(),
      );
  });

  it('should reset the form if ref is HTMLElement and parent element is not form', async () => {
    const mockReset = jest.spyOn(window.HTMLFormElement.prototype, 'reset');
    let methods: UseFormReturn<{
      test: string;
    }>;
    const App = () => {
      methods = useForm<{
        test: string;
      }>();
      return <input {...methods.register('test')} />;
    };
    render(<App />);

    act(() => methods.reset());

    expect(mockReset).not.toHaveBeenCalled();
  });

  it('should set default value if values is specified to first argument', async () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');

    act(() => result.current.reset({ test: 'test' }));

    expect(result.current.control._defaultValues).toEqual({
      test: 'test',
    });
  });

  it('should reset unmountFieldsState value when shouldUnregister set to false', () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');

    act(() => result.current.reset({ test: 'test' }));
  });

  it('should not reset unmountFieldsState value by default', () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string;
      }>(),
    );

    result.current.register('test');

    act(() => result.current.reset({ test: 'test' }));
  });

  it('should not reset form values when keepValues is specified', () => {
    const App = () => {
      const { register, reset } = useForm();

      return (
        <>
          <input {...register('test')} />
          <button
            type={'button'}
            onClick={() =>
              reset(undefined, {
                keepValues: true,
              })
            }
          >
            reset
          </button>
        </>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );
  });

  it('should not reset form defaultValues when keepDefaultValues is specified', async () => {
    const App = () => {
      const {
        register,
        reset,
        formState: { isDirty },
      } = useForm({
        defaultValues: {
          test: 'test1',
        },
      });

      return (
        <>
          <input {...register('test')} />
          <p>{isDirty ? 'dirty' : ''}</p>
          <button
            type={'button'}
            onClick={() =>
              reset(undefined, {
                keepValues: true,
              })
            }
          >
            reset
          </button>
        </>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test2',
      },
    });

    expect(await screen.findByText('dirty')).toBeVisible();

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test1',
      },
    });

    expect(screen.queryByText('dirty')).not.toBeInTheDocument();
  });

  it('should update dirty and dirtyFields when keepDefaultValues and updatedValues is provided', async () => {
    function App() {
      const {
        register,
        reset,
        formState: { isDirty, dirtyFields },
      } = useForm({
        defaultValues: {
          firstName: 'test',
        },
      });

      return (
        <form>
          <input {...register('firstName')} placeholder="First Name" />
          <p>{isDirty ? 'dirty' : 'pristine'}</p>
          <p>{JSON.stringify(dirtyFields)}</p>

          <button
            type="button"
            onClick={() => {
              reset(
                {
                  firstName: 'other',
                },
                {
                  keepDefaultValues: true,
                },
              );
            }}
          >
            test
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('dirty')).toBeVisible();
    expect(screen.getByText('{"firstName":true}')).toBeVisible();
  });

  it('should not reset if keepStateOption is specified', async () => {
    let formState = {};
    const onSubmit = jest.fn();

    const App = () => {
      const {
        register,
        handleSubmit,
        reset,
        formState: { touchedFields, errors, isDirty },
      } = useForm<{ test: string }>({
        defaultValues: {
          test: '',
        },
      });

      formState = { touchedFields, errors, isDirty };

      return (
        <form onSubmit={handleSubmit(onSubmit)}>
          <input {...register('test', { required: true, minLength: 3 })} />
          <button>submit</button>
          <button
            onClick={() => {
              reset(
                { test: '' },
                {
                  keepErrors: true,
                  keepDirty: true,
                  keepIsSubmitted: true,
                  keepIsSubmitSuccessful: true,
                  keepTouched: true,
                  keepSubmitCount: true,
                },
              );
            }}
            type={'button'}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.blur(screen.getByRole('textbox'));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() => expect(onSubmit).toHaveBeenCalled());
    await waitFor(() =>
      expect(formState).toEqual({
        errors: {},
        isDirty: true,
        touchedFields: {
          test: true,
        },
      }),
    );

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));

    expect(formState).toEqual({
      errors: {},
      isDirty: true,
      touchedFields: {
        test: true,
      },
    });
  });

  it('should reset field array fine with empty value', async () => {
    let data: unknown;
    const App = () => {
      const { control, register, reset, handleSubmit } = useForm<{
        test: {
          firstName: string;
          lastName: string;
        }[];
      }>();
      const { fields } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form
          onSubmit={handleSubmit((d) => {
            data = d;
          })}
        >
          {fields.map((field, index) => (
            <div key={field.id}>
              <input {...register(`test.${index}.firstName` as const)} />
              <Controller
                control={control}
                name={`test.${index}.lastName` as const}
                render={({ field }) => <input {...field} />}
              />
            </div>
          ))}

          <button>submit</button>

          <button type={'button'} onClick={() => reset()}>
            reset
          </button>
          <button
            type={'button'}
            onClick={() =>
              reset({
                test: [{ firstName: 'test', lastName: 'test' }],
              })
            }
          >
            reset with value
          </button>
        </form>
      );
    };

    render(<App />);

    const resetButton = screen.getByRole('button', { name: 'reset' });
    const submitButton = screen.getByRole('button', { name: 'submit' });

    fireEvent.click(resetButton);
    fireEvent.click(submitButton);

    await waitFor(() => expect(data).toEqual({}));

    fireEvent.click(screen.getByRole('button', { name: 'reset with value' }));
    fireEvent.click(submitButton);

    await waitFor(() =>
      expect(data).toEqual({
        test: [{ firstName: 'test', lastName: 'test' }],
      }),
    );
  });

  it('should return reset nested value', () => {
    const getValuesResult: unknown[] = [];

    function App() {
      const [, update] = React.useState({});
      const { register, reset, getValues } = useForm<{
        names: { name: string }[];
      }>({
        defaultValues: {
          names: [{ name: 'test' }],
        },
      });

      React.useEffect(() => {
        reset({ names: [{ name: 'Bill' }, { name: 'Luo' }] });
      }, [reset]);

      getValuesResult.push(getValues());

      return (
        <form>
          <input {...register('names.0.name')} placeholder="Name" />
          <button type={'button'} onClick={() => update({})}>
            update
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(getValuesResult).toEqual([
      {
        names: [
          {
            name: 'test',
          },
        ],
      },
      {
        names: [
          {
            name: 'Bill',
          },
          {
            name: 'Luo',
          },
        ],
      },
      {
        names: [
          {
            name: 'Bill',
          },
          {
            name: 'Luo',
          },
        ],
      },
    ]);
  });

  it('should keep defaultValues after reset with shouldKeepDefaultValues', async () => {
    type FormValues = { test: string; test1: string };
    const ControlledInput = ({ control }: { control: Control<FormValues> }) => {
      const { field } = useController({
        name: 'test',
        control,
      });

      return <input {...field} />;
    };

    function App() {
      const { control, register, reset } = useForm<FormValues>({
        defaultValues: { test: 'test', test1: 'test1' },
      });
      const resetData = () => {
        reset(undefined, { keepDefaultValues: true });
      };

      return (
        <form>
          <ControlledInput control={control} />
          <input {...register('test1')} />
          <input type="button" onClick={resetData} value="Reset" />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: { value: 'data' },
    });

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: { value: 'data' },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('test');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('test1');
  });

  describe('when reset optional props set to keepDirtyValues', () => {
    describe('with uncontrolled components', () => {
      let updatedDirtyFields: Record<string, boolean> = {};
      let updatedDirty = false;
      let submittedValue: unknown = {};

      function App() {
        const [showButton, setShowButton] = React.useState(false);
        const {
          reset,
          register,
          handleSubmit,
          formState: { dirtyFields, isDirty },
        } = useForm();

        updatedDirtyFields = dirtyFields;
        updatedDirty = isDirty;

        React.useEffect(() => {
          setTimeout(() => {
            reset(
              {
                firstName: 'bill',
                lastName: 'luo',
              },
              { keepDirtyValues: true },
            );
            setShowButton(true);
          }, 500);
        }, [reset]);

        return (
          <form
            onSubmit={handleSubmit((data) => {
              submittedValue = data;
            })}
          >
            <input {...register('firstName')} placeholder="First Name" />
            <input {...register('lastName')} placeholder="Last Name" />

            {showButton && (
              <button
                type="button"
                onClick={() => {
                  reset();
                }}
              >
                reset
              </button>
            )}
            <button>submit</button>
          </form>
        );
      }

      it('should only update new reset values', async () => {
        render(<App />);

        await waitFor(() =>
          expect(
            (screen.getByPlaceholderText('First Name') as HTMLInputElement)
              .value,
          ).toEqual('bill'),
        );

        fireEvent.click(screen.getByRole('button', { name: 'reset' }));

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        expect(
          (screen.getByPlaceholderText('First Name') as HTMLInputElement).value,
        ).toEqual('bill');

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'bill',
            lastName: 'luo',
          }),
        );
      });

      it('should only update none dirty fields and keep other values updated', async () => {
        render(<App />);

        fireEvent.change(screen.getByPlaceholderText('First Name'), {
          target: {
            value: 'test',
          },
        });

        await waitFor(() =>
          expect(
            (screen.getByPlaceholderText('Last Name') as HTMLInputElement)
              .value,
          ).toEqual('luo'),
        );

        expect(updatedDirtyFields).toEqual({
          firstName: true,
        });
        expect(updatedDirty).toBeTruthy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'test',
            lastName: 'luo',
          }),
        );

        fireEvent.click(screen.getByRole('button', { name: 'reset' }));

        expect(
          (screen.getByPlaceholderText('First Name') as HTMLInputElement).value,
        ).toEqual('bill');

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'bill',
            lastName: 'luo',
          }),
        );
      });

      it('should treat previously-undirty fields as dirty when keepDefaultValues is set', async () => {
        let updatedDirtyFields: Record<string, boolean> = {};
        let updatedDirty = false;

        function App() {
          const {
            reset,
            register,
            handleSubmit,
            formState: { dirtyFields, isDirty },
          } = useForm({ defaultValues: { firstName: '', lastName: '' } });

          function resetKeepDefaults() {
            reset(
              {
                firstName: 'bill',
                lastName: 'luo',
              },
              {
                keepDefaultValues: true,
                keepDirtyValues: true,
              },
            );
          }

          updatedDirtyFields = dirtyFields;
          updatedDirty = isDirty;

          return (
            <form
              onSubmit={handleSubmit((data) => {
                submittedValue = data;
              })}
            >
              <input {...register('firstName')} placeholder="First Name" />
              <input {...register('lastName')} placeholder="Last Name" />

              <button
                type="button"
                onClick={() => {
                  resetKeepDefaults();
                }}
              >
                reset keep defaults
              </button>
              <button>submit</button>
            </form>
          );
        }

        render(<App />);

        fireEvent.click(
          screen.getByRole('button', { name: 'reset keep defaults' }),
        );

        await waitFor(() =>
          expect(
            (screen.getByPlaceholderText('Last Name') as HTMLInputElement)
              .value,
          ).toEqual('luo'),
        );

        expect(
          (screen.getByPlaceholderText('First Name') as HTMLInputElement).value,
        ).toEqual('bill');

        // Both fields were updated, the defaults were kept, so both should be dirty
        expect(updatedDirtyFields).toEqual({
          firstName: true,
          lastName: true,
        });

        expect(updatedDirty).toBeTruthy();
      });
    });

    describe('with controlled components', () => {
      let updatedDirtyFields: Record<string, boolean> = {};
      let updatedDirty = false;
      let submittedValue: unknown = {};

      function App() {
        const [showButton, setShowButton] = React.useState(false);
        const {
          reset,
          control,
          handleSubmit,
          formState: { dirtyFields, isDirty },
        } = useForm({
          defaultValues: {
            firstName: '',
            lastName: '',
          },
        });

        updatedDirtyFields = dirtyFields;
        updatedDirty = isDirty;

        React.useEffect(() => {
          setTimeout(() => {
            reset(
              {
                firstName: 'bill',
                lastName: 'luo',
              },
              { keepDirtyValues: true },
            );
            setShowButton(true);
          }, 500);
        }, [reset]);

        return (
          <form
            onSubmit={handleSubmit((data) => {
              submittedValue = data;
            })}
          >
            <Controller
              control={control}
              render={({ field }) => {
                return <input {...field} placeholder="First Name" />;
              }}
              name={'firstName'}
            />
            <Controller
              control={control}
              render={({ field }) => {
                return <input {...field} placeholder="Last Name" />;
              }}
              name={'lastName'}
            />

            {showButton && (
              <button
                type="button"
                onClick={() => {
                  reset();
                }}
              >
                reset
              </button>
            )}

            <button>submit</button>
          </form>
        );
      }

      it('should only update new reset values', async () => {
        render(<App />);

        await waitFor(() =>
          expect(
            (screen.getByPlaceholderText('First Name') as HTMLInputElement)
              .value,
          ).toEqual('bill'),
        );

        fireEvent.click(screen.getByRole('button', { name: 'reset' }));

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        expect(
          (screen.getByPlaceholderText('First Name') as HTMLInputElement).value,
        ).toEqual('bill');

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'bill',
            lastName: 'luo',
          }),
        );
      });

      it('should only update none dirty fields and keep other values updated', async () => {
        render(<App />);

        fireEvent.change(screen.getByPlaceholderText('First Name'), {
          target: {
            value: 'test',
          },
        });

        await waitFor(() =>
          expect(
            (screen.getByPlaceholderText('Last Name') as HTMLInputElement)
              .value,
          ).toEqual('luo'),
        );

        expect(updatedDirtyFields).toEqual({
          firstName: true,
        });
        expect(updatedDirty).toBeTruthy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'test',
            lastName: 'luo',
          }),
        );

        fireEvent.click(screen.getByRole('button', { name: 'reset' }));

        expect(
          (screen.getByPlaceholderText('First Name') as HTMLInputElement).value,
        ).toEqual('bill');

        expect(updatedDirtyFields).toEqual({});
        expect(updatedDirty).toBeFalsy();

        fireEvent.click(screen.getByRole('button', { name: 'submit' }));

        await waitFor(() =>
          expect(submittedValue).toEqual({
            firstName: 'bill',
            lastName: 'luo',
          }),
        );
      });
    });
  });

  it('should allow to reset unmounted field array', () => {
    type FormValues = {
      test: { name: string }[];
    };

    const FieldArray = ({
      control,
      register,
    }: {
      control: Control<FormValues>;
      register: UseFormRegister<FormValues>;
    }) => {
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <div>
          {fields.map((field, index) => {
            return (
              <input
                key={field.id}
                {...register(`test.${index}.name` as const)}
              />
            );
          })}
          <button
            onClick={() => {
              append({ name: '' });
            }}
          >
            append
          </button>
        </div>
      );
    };

    const App = () => {
      const [show, setShow] = React.useState(true);
      const { control, register, reset } = useForm<FormValues>();

      return (
        <div>
          {show && <FieldArray control={control} register={register} />}
          <button
            onClick={() => {
              setShow(!show);
            }}
          >
            toggle
          </button>
          <button
            onClick={() => {
              reset({
                test: [{ name: 'test' }],
              });
            }}
          >
            reset
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    expect(screen.getAllByRole('textbox').length).toEqual(2);

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));
    fireEvent.click(screen.getByRole('button', { name: 'reset' }));
    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    expect(screen.getAllByRole('textbox').length).toEqual(1);
  });

  it('should only return register input when reset is invoked with shouldUnregister:true', async () => {
    let submittedData = {};

    const App = () => {
      const { reset, handleSubmit } = useForm({
        defaultValues: {
          test: 'bill',
        },
        shouldUnregister: true,
      });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            submittedData = data;
          })}
        >
          <button>submit</button>
          <button
            type={'button'}
            onClick={() => {
              reset({
                test: '1234',
              });
            }}
          >
            reset
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(submittedData).toEqual({});

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(submittedData).toEqual({});
  });

  it('should update controlled input correctly with shouldUnregister set to true', () => {
    function App() {
      const { register, reset, control } = useForm({
        defaultValues: { uncontrolled: '', control: '' },
        shouldUnregister: true,
      });

      return (
        <form>
          <input {...register('uncontrolled')} />
          <Controller
            render={({ field }) => (
              <input
                ref={field.ref}
                value={field.value}
                onChange={field.onChange}
              />
            )}
            name="control"
            control={control}
          />

          <button
            type="button"
            onClick={() => {
              reset({ uncontrolled: 'uncontrolled', control: 'control' });
            }}
          >
            reset
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('uncontrolled');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('control');
  });

  it('should keep input values when keepValues is set to true', () => {
    function App() {
      const { register, handleSubmit, reset } = useForm();
      const [show, setShow] = React.useState(true);

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input {...register('firstName')} placeholder="First Name" />
          {show && <input {...register('lastName')} placeholder="Last Name" />}
          <button
            type="button"
            onClick={() => {
              reset({}, { keepValues: true });
            }}
          >
            reset
          </button>
          <button
            type="button"
            onClick={() => {
              setShow(!show);
            }}
          >
            toggle
          </button>
          <input type="submit" />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: { value: 'test' },
    });
    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: { value: 'test' },
    });
    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));
    fireEvent.click(screen.getByRole('button', { name: 'reset' }));
    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('test');
  });

  it('should not update isMounted when isValid is subscribed', async () => {
    const mounted: unknown[] = [];

    const App = () => {
      const { control, reset } = useForm();

      mounted.push(control._state.mount);

      React.useEffect(() => {
        reset({});
      }, [reset]);

      return <form />;
    };

    render(<App />);

    expect(mounted).toEqual([false, true]);
  });

  it('should update isMounted when isValid is subscribed', async () => {
    const mounted: unknown[] = [];
    let tempControl: Control = {} as Control;

    const App = () => {
      const {
        control,
        reset,
        formState: { isValid },
      } = useForm();

      mounted.push(control._state.mount);
      tempControl = control;

      React.useEffect(() => {
        reset({});
      }, [reset]);

      return (
        <form>
          <p>{isValid ? 'true' : 'false'}</p>
        </form>
      );
    };

    render(<App />);

    expect(await screen.findByText('false')).toBeVisible();

    expect(mounted).toEqual([false, false]);

    expect(tempControl._state.mount).toBeTruthy();
  });

  it('should reset values but keep defaultValues', async () => {
    const App = () => {
      const { register, control, reset } = useForm({
        defaultValues: {
          test: 'test',
          test1: 'test1',
        },
      });

      return (
        <>
          <input {...register('test')} />
          <Controller
            control={control}
            render={({ field }) => <input {...field} />}
            name={'test1'}
          />
          <button
            onClick={() => {
              reset(
                {
                  test: 'changed1',
                  test1: 'changed2',
                },
                { keepDefaultValues: true },
              );
            }}
          >
            reset
          </button>
          <p>{JSON.stringify(control._defaultValues)}</p>
        </>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(
      await screen.findByText('{"test":"test","test1":"test1"}'),
    ).toBeVisible();
    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('changed1');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('changed2');
  });

  it('should reset field array async', () => {
    let tempFields: unknown[] = [];

    function App() {
      const { control, reset } = useForm<{
        names: {
          test: string;
        }[];
      }>({
        defaultValues: {
          names: [],
        },
      });
      const { fields, append } = useFieldArray({
        control,
        name: 'names',
      });

      tempFields = fields;

      return (
        <form>
          <button
            type="button"
            onClick={() => {
              setTimeout(() => {
                reset();
              }, 100);
            }}
          >
            reset
          </button>
          <button
            type="button"
            onClick={() =>
              append({
                test: '1',
              })
            }
          >
            append
          </button>
          <ul>
            {fields.map((item, index) => (
              <Controller
                key={item.id}
                render={({ field }) => <input {...field} />}
                name={`names.${index}.test`}
                control={control}
              />
            ))}
          </ul>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));

    act(() => {
      jest.advanceTimersByTime(100);
    });

    expect(tempFields).toEqual([]);
  });

  it('should reset the form after submitted', async () => {
    function App() {
      const {
        register,
        control,
        handleSubmit,
        reset,
        formState: { isDirty, dirtyFields },
      } = useForm({
        defaultValues: {
          something: 'anything',
          test: [{ firstName: 'Bill', lastName: 'Luo' }],
        },
      });
      const { fields } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            reset({ ...data });
          })}
        >
          <p>is dirty? {isDirty ? 'yes' : 'no'}</p>
          <p>{JSON.stringify(dirtyFields)}</p>
          <input {...register('something')} />
          <ul>
            {fields.map((item, index) => {
              return (
                <li key={item.id}>
                  <input
                    defaultValue={`${item.firstName}`}
                    {...register(`test.${index}.firstName`)}
                  />

                  <Controller
                    render={({ field }) => <input {...field} />}
                    name={`test.${index}.lastName`}
                    control={control}
                    defaultValue={item.lastName}
                  />
                </li>
              );
            })}
          </ul>

          <button>Submit</button>
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: { value: '1' },
    });
    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: { value: '2' },
    });
    fireEvent.change(screen.getAllByRole('textbox')[2], {
      target: { value: '3' },
    });

    expect(screen.getByText(/yes/i)).toBeVisible();
    expect(
      screen.getByText(
        `{"something":true,"test":[{"firstName":true,"lastName":true}]}`,
      ),
    ).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText(/no/i)).toBeVisible();

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('1');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('2');
    expect(
      (screen.getAllByRole('textbox')[2] as HTMLInputElement).value,
    ).toEqual('3');
  });

  it('should keep isSubmitted and isSubmitSuccessful value when flags are set', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    expect(result.current.formState.isSubmitted).toBeFalsy();
    expect(result.current.formState.isSubmitSuccessful).toBeFalsy();

    await act(() =>
      result.current.reset(undefined, {
        keepIsSubmitted: true,
        keepIsSubmitSuccessful: true,
      }),
    );
    expect(result.current.formState.isSubmitted).toBeFalsy();
    expect(result.current.formState.isSubmitSuccessful).toBeFalsy();

    result.current.register('test');
    result.current.setValue('test', 'data');

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: 'data',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });

    expect(result.current.formState.isSubmitted).toBeTruthy();
    expect(result.current.formState.isSubmitSuccessful).toBeTruthy();

    act(() =>
      result.current.reset(undefined, {
        keepIsSubmitted: true,
        keepIsSubmitSuccessful: true,
      }),
    );

    expect(result.current.formState.isSubmitted).toBeTruthy();
    expect(result.current.formState.isSubmitSuccessful).toBeTruthy();
  });

  it('should keep track on updated defaultValues', async () => {
    function App() {
      const {
        handleSubmit,
        reset,
        formState: { defaultValues },
      } = useForm({
        defaultValues: { firstName: 'Bill', lastName: 'Luo' },
      });

      return (
        <form
          onSubmit={handleSubmit(() => {
            reset({ firstName: 'Bill1', lastName: 'Luo1' });
          })}
        >
          <button>Submit</button>
          <p>{defaultValues?.firstName}</p>
          <p>{defaultValues?.lastName}</p>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(screen.getByText('Bill1')).toBeVisible();
      expect(screen.getByText('Luo1')).toBeVisible();
    });
  });

  it('should return defaultValues in useWatch and watch when using calling reset with empty object', async () => {
    const defaultValues = {
      something: 'anything',
    };

    function App() {
      const { control, reset, register, watch } = useForm({
        defaultValues,
      });
      const watchValue = watch('something');
      const useWatchValue = useWatch({
        control,
        name: 'something',
      });

      return (
        <form>
          <input {...register('something')} />
          <button
            type="button"
            onClick={() => {
              reset({});
            }}
          >
            reset
          </button>
          <p>watch: {watchValue}</p>
          <p>useWatch: {useWatchValue}</p>
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: '1' },
    });

    expect(screen.getByText('watch: 1')).toBeVisible();
    expect(screen.getByText('useWatch: 1')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(screen.getByText('watch: anything')).toBeVisible();
    expect(screen.getByText('useWatch: anything')).toBeVisible();
  });

  it('should keep mounted value after reset with keep dirty values', async () => {
    function App() {
      const {
        getValues,
        reset,
        register,
        formState: { isValid },
      } = useForm({
        mode: 'onChange',
      });

      return (
        <form>
          <input
            {...register('value', { required: true })}
            defaultValue="Any default value!"
          />
          <p>{getValues().test}</p>
          <p>isValid = {isValid ? 'true' : 'false'}</p>
          <button
            type="button"
            onClick={() => reset({ test: '34' }, { keepDirtyValues: true })}
          >
            reset
          </button>
        </form>
      );
    }

    render(<App />);

    expect(await screen.findByText('isValid = true')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('34');
    });
  });

  it('should keep dirty array value after reset with keepDirtyValues', async () => {
    function App() {
      const {
        getValues,
        reset,
        setValue,
        formState: { isDirty },
      } = useForm<{
        array: string[];
      }>({
        mode: 'onChange',
        defaultValues: {
          array: [],
        },
      });

      return (
        <form>
          <input defaultValue="users#0" />
          <p>{`users#${getValues().array.length}`}</p>
          <p>isDirty = {isDirty ? 'true' : 'false'}</p>
          <button
            data-testid="dirtyButton"
            type="button"
            onClick={() => setValue('array', ['1'], { shouldDirty: true })}
          >
            dirty
          </button>
          <button
            data-testid="resetButton"
            type="button"
            onClick={() => reset({ array: [] }, { keepDirtyValues: true })}
          >
            reset
          </button>
        </form>
      );
    }

    render(<App />);

    expect(await screen.findByText('isDirty = false')).toBeVisible();
    await waitFor(() => {
      screen.getByText('users#0');
    });

    fireEvent.click(screen.getByTestId('dirtyButton'));
    expect(await screen.findByText('isDirty = true')).toBeVisible();
    await waitFor(() => {
      screen.getByText('users#1');
    });

    fireEvent.click(screen.getByTestId('resetButton'));

    await waitFor(() => {
      screen.getByText('users#1');
    });
  });

  it('should not mutate data outside of library', () => {
    const defaultValues = {
      test: 'ok',
    };

    const App = () => {
      const { register, reset, resetField } = useForm();

      return (
        <form>
          <input {...register('test')} />
          <button type="button" onClick={() => reset(defaultValues)}>
            reset
          </button>
          <button
            type="button"
            onClick={() => resetField('test', { defaultValue: 'error' })}
          >
            resetField
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));
    fireEvent.click(screen.getByRole('button', { name: 'resetField' }));

    expect(defaultValues.test).toBe('ok');
  });
});


================================================
File: /src/__tests__/useForm/setValue.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Controller } from '../../controller';
import { Control } from '../../types';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import get from '../../utils/get';
import isFunction from '../../utils/isFunction';
import noop from '../../utils/noop';
import sleep from '../../utils/sleep';

jest.useFakeTimers();

describe('setValue', () => {
  it('should not setValue for unmounted state with shouldUnregister', () => {
    const { result } = renderHook(() => useForm<{ test1: string }>());

    result.current.register('test1');
    result.current.setValue('test1', 'data');
  });

  it('should empty string when value is null or undefined when registered field is HTMLElement', () => {
    const { result } = renderHook(() =>
      useForm<{ test?: string | null }>({
        defaultValues: {
          test: 'test',
        },
      }),
    );

    const elm = document.createElement('input');
    elm.type = 'text';
    elm.name = 'test';

    result.current.register('test');

    result.current.setValue('test', null);

    expect(elm).not.toHaveValue();

    act(() => {
      result.current.unregister('test');
    });

    expect(elm).not.toHaveValue();
  });

  it('should set value of radio input correctly', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    result.current.register('test');

    result.current.setValue('test', '1');

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: '1',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of file input correctly if value is FileList', async () => {
    const { result } = renderHook(() => useForm<{ test: FileList }>());

    result.current.register('test');

    const file = new File([''], '', { type: 'image/png', lastModified: 1 });
    const fileList = {
      0: file,
      1: file,
      length: 2,
    } as unknown as FileList;

    act(() => result.current.setValue('test', fileList));

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: fileList,
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of multiple checkbox input correctly', async () => {
    const { result } = renderHook(() => useForm<{ test: string[] }>());

    const { ref } = result.current.register('test');

    const elm = document.createElement('input');
    elm.type = 'checkbox';
    elm.name = 'test';
    elm.value = '2';

    document.body.append(elm);
    isFunction(ref) && ref(elm);

    const { ref: ref1 } = result.current.register('test');

    const elm1 = document.createElement('input');
    elm1.type = 'checkbox';
    elm1.name = 'test';
    elm1.value = '1';

    document.body.append(elm1);

    isFunction(ref1) && ref1(elm1);

    result.current.setValue('test', ['1']);

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: ['1'],
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of single checkbox input correctly', async () => {
    const { result } = renderHook(() => useForm<{ test: string }>());

    result.current.register('test');

    result.current.setValue('test', '1');

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: '1',
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of multiple checkbox input correctly as a child', async () => {
    const { result } = renderHook(() =>
      useForm<{ parent: { test: string[] } }>(),
    );

    const { ref } = result.current.register('parent.test');

    const elm = document.createElement('input');
    elm.type = 'checkbox';
    elm.name = 'test';
    elm.value = '2';

    document.body.append(elm);
    isFunction(ref) && ref(elm);

    const { ref: ref1 } = result.current.register('parent.test');

    const elm1 = document.createElement('input');
    elm1.type = 'checkbox';
    elm1.name = 'test';
    elm1.value = '1';

    document.body.append(elm1);

    isFunction(ref1) && ref1(elm1);

    result.current.setValue('parent', { test: ['1'] });
    expect(elm1).toBeChecked();

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          parent: {
            test: ['1'],
          },
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of single checkbox input correctly as a child', async () => {
    const { result } = renderHook(() =>
      useForm<{ parent: { test: string } }>(),
    );

    const { ref } = result.current.register('parent.test');

    const elm = document.createElement('input');
    elm.type = 'checkbox';
    elm.name = 'test';
    elm.value = '1';

    document.body.append(elm);
    isFunction(ref) && ref(elm);

    result.current.setValue('parent', { test: '1' });
    expect(elm).toBeChecked();

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          parent: {
            test: '1',
          },
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should set value of multiple select correctly', async () => {
    const { result } = renderHook(() => useForm<{ test: string[] }>());
    const { ref } = result.current.register('test');

    isFunction(ref) &&
      ref({
        type: 'checkbox',
        refs: [{}, {}],
      });

    result.current.setValue('test', ['1']);

    await act(async () => {
      await result.current.handleSubmit((data) => {
        expect(data).toEqual({
          test: ['1'],
        });
      })({
        preventDefault: noop,
        persist: noop,
      } as React.SyntheticEvent);
    });
  });

  it('should update nested controlled input', () => {
    function App() {
      const { setValue, control } = useForm({
        defaultValues: {
          test: {
            deep: {
              field: 'test',
            },
          },
        },
      });

      return (
        <form>
          <Controller
            name="test.deep.field"
            control={control}
            render={({ field }) => <input {...field} />}
          />

          <button
            type="button"
            onClick={() => {
              setValue('test.deep', {
                field: 'updateValue',
              });
            }}
          >
            setValue
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'updateValue',
    );
  });

  it('should set object array value', () => {
    const { result } = renderHook(() =>
      useForm<{
        test: {
          one: string;
          two: string;
          three: string;
        }[];
      }>(),
    );

    result.current.register('test.0.one');
    result.current.register('test.0.two');
    result.current.register('test.0.three');

    act(() => {
      result.current.setValue('test', [
        {
          one: 'ONE',
          two: 'TWO',
          three: 'THREE',
        },
      ]);
    });

    expect(result.current.getValues()).toEqual({
      test: [
        {
          one: 'ONE',
          two: 'TWO',
          three: 'THREE',
        },
      ],
    });
  });

  it('should set unmountFieldsState value when shouldUnregister is set to false', async () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string;
        checkbox: string[];
        test1: { one: string; two: string; three: string }[];
      }>(),
    );

    act(() => {
      result.current.setValue('test', '1');
      result.current.setValue('checkbox', ['1', '2']);
      result.current.setValue('test1.0', {
        one: 'ONE',
        two: 'TWO',
        three: 'THREE',
      });
    });
  });

  it('should set nested value correctly ', () => {
    const { result } = renderHook(() =>
      useForm<{
        test1: string[];
        test2: {
          key1: string;
          key2: number;
        };
        test3: {
          key1: string;
          key2: number;
        }[];
      }>(),
    );

    result.current.register('test1');
    result.current.register('test2');
    result.current.register('test3');

    act(() => {
      result.current.setValue('test1', ['1', '2', '3']);
      result.current.setValue('test2', { key1: '1', key2: 2 });
      result.current.setValue('test3', [
        { key1: '1', key2: 2 },
        { key1: '3', key2: 4 },
      ]);
    });

    expect(result.current.control._fields['test1']).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test1', value: ['1', '2', '3'] },
        name: 'test1',
      },
    });
    expect(result.current.control._fields['test2']).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test2', value: { key1: '1', key2: 2 } },
        name: 'test2',
      },
    });
    expect(result.current.control._fields['test3']).toEqual({
      _f: {
        mount: true,
        ref: {
          name: 'test3',
          value: [
            { key1: '1', key2: 2 },
            { key1: '3', key2: 4 },
          ],
        },
        name: 'test3',
      },
    });
  });

  it('should work with array fields', () => {
    const { result } = renderHook(() =>
      useForm<{
        test: string[];
        test1: {
          test: string;
        }[];
      }>(),
    );

    result.current.register('test1.0.test');
    result.current.register('test.0');
    result.current.register('test.1');
    result.current.register('test.2');

    act(() => result.current.setValue('test', ['1', '2', '3']));

    expect(get(result.current.control._fields, 'test.0')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.0', value: '1' },
        name: 'test.0',
      },
    });
    expect(get(result.current.control._fields, 'test.1')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.1', value: '2' },
        name: 'test.1',
      },
    });
    expect(get(result.current.control._fields, 'test.2')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.2', value: '3' },
        name: 'test.2',
      },
    });
  });

  it('should worked with nested array fields with object', () => {
    const { result } = renderHook(() =>
      useForm<{
        test: {
          test: string;
        }[];
      }>(),
    );

    result.current.register('test.0.test');
    result.current.register('test.1.test');
    result.current.register('test.2.test');

    act(() =>
      result.current.setValue('test', [
        { test: '1' },
        { test: '2' },
        { test: '3' },
      ]),
    );

    expect(get(result.current.control._fields, 'test.0.test')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.0.test', value: '1' },
        name: 'test.0.test',
      },
    });
    expect(get(result.current.control._fields, 'test.1.test')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.1.test', value: '2' },
        name: 'test.1.test',
      },
    });
    expect(get(result.current.control._fields, 'test.2.test')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.2.test', value: '3' },
        name: 'test.2.test',
      },
    });
  });

  it('should work with object fields', () => {
    const { result } = renderHook(() =>
      useForm<{
        test1: {
          test: string;
        }[];
        test: {
          bill: string;
          luo: string;
          test: string;
        };
      }>(),
    );

    result.current.register('test1.0.test');
    result.current.register('test.bill');
    result.current.register('test.luo');
    result.current.register('test.test');

    act(() =>
      result.current.setValue('test', { bill: '1', luo: '2', test: '3' }),
    );
    expect(get(result.current.control._fields, 'test.bill')).toEqual({
      _f: {
        ref: { name: 'test.bill', value: '1' },
        mount: true,
        name: 'test.bill',
      },
    });
    expect(get(result.current.control._fields, 'test.luo')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.luo', value: '2' },
        name: 'test.luo',
      },
    });
    expect(get(result.current.control._fields, 'test.test')).toEqual({
      _f: {
        mount: true,
        ref: { name: 'test.test', value: '3' },
        name: 'test.test',
      },
    });
  });

  it('should work for nested fields which are not registered', () => {
    const { result } = renderHook(() => useForm());

    result.current.register('test.test');
    result.current.register('test1.test');

    act(() => {
      result.current.setValue('test', {
        test: 'test',
        test1: 'test1',
        test2: 'test2',
      });
    });

    expect(result.current.control._fields['test']).toEqual({
      test: {
        _f: {
          mount: true,
          name: 'test.test',
          ref: {
            name: 'test.test',
            value: 'test',
          },
        },
      },
    });
  });

  describe('with watch', () => {
    it('should get watched value', () => {
      const { result } = renderHook(() => {
        const { register, watch, setValue } = useForm<{ test: string }>();

        register('test');

        React.useEffect(() => {
          setValue('test', 'abc');
        }, [setValue]);

        return watch('test');
      });

      expect(result.current).toBe('abc');
    });
  });

  describe('with validation', () => {
    it('should be called trigger method if shouldValidate variable is true', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string;
        }>(),
      );

      result.current.register('test', {
        minLength: {
          value: 5,
          message: 'min',
        },
      });

      result.current.formState.dirtyFields;
      result.current.formState.errors;

      await act(async () =>
        result.current.setValue('test', 'abc', {
          shouldValidate: true,
        }),
      );

      expect(result.current.formState.errors?.test?.message).toBe('min');
    });

    it('should validate input correctly with existing error', async () => {
      const Component = () => {
        const {
          register,
          setError,
          setValue,
          formState: { errors },
        } = useForm({
          defaultValues: {
            test: '',
          },
        });

        return (
          <>
            <input {...register('test', { required: true })} />
            <button
              onClick={() => {
                setError('test', { type: 'somethingWrong', message: 'test' });
              }}
            >
              setError
            </button>
            <button
              onClick={() => {
                setValue('test', 'bill', {
                  shouldValidate: true,
                });
              }}
            >
              update
            </button>
            <p>{errors?.test?.message}</p>
          </>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'setError' }));

      expect(await screen.findByText('test')).toBeVisible();

      fireEvent.click(screen.getByRole('button', { name: 'update' }));

      await waitFor(() =>
        expect(screen.queryByText('test')).not.toBeInTheDocument(),
      );
    });

    it('should not be called trigger method if options is empty', async () => {
      const { result } = renderHook(() => useForm<{ test: string }>());

      result.current.register('test', {
        minLength: {
          value: 5,
          message: 'min',
        },
      });

      result.current.setValue('test', 'abc');

      expect(result.current.formState.errors?.test).toBeUndefined();
    });

    it('should be called trigger method if shouldValidate variable is true and field value is array', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string[];
        }>(),
      );

      const rules = {
        minLength: {
          value: 5,
          message: 'min',
        },
      };

      result.current.register('test.0', rules);
      result.current.register('test.1', rules);
      result.current.register('test.2', rules);

      result.current.formState.errors;

      await act(async () =>
        result.current.setValue('test', ['abc1', 'abc2', 'abc3'], {
          shouldValidate: true,
        }),
      );

      expect(result.current.formState.errors?.test?.[0]?.message).toBe('min');
      expect(result.current.formState.errors?.test?.[1]?.message).toBe('min');
      expect(result.current.formState.errors?.test?.[2]?.message).toBe('min');
    });

    it('should not be called trigger method if options is empty and field value is array', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string[];
        }>(),
      );

      const rules = {
        minLength: {
          value: 5,
          message: 'min',
        },
      };

      result.current.register('test.0', rules);
      result.current.register('test.1', rules);
      result.current.register('test.2', rules);

      act(() => result.current.setValue('test', ['test', 'test1', 'test2']));

      expect(result.current.formState.errors?.test).toBeUndefined();
    });
  });

  describe('with dirty', () => {
    it.each(['isDirty', 'dirtyFields'])(
      'should be dirtyFields when %s is defined when shouldDirty is true',
      (property) => {
        const { result } = renderHook(() => useForm<{ test: string }>());

        result.current.formState[property as 'dirtyFields' | 'isDirty'];
        result.current.formState.isDirty;
        result.current.formState.dirtyFields;

        result.current.register('test');

        act(() =>
          result.current.setValue('test', 'test', { shouldDirty: true }),
        );

        expect(result.current.formState.isDirty).toBeTruthy();
        expect(result.current.formState.dirtyFields).toEqual({ test: true });
      },
    );

    it.each([
      ['isDirty', ['test1', 'test2', 'test3'], [true, true, true]],
      ['dirty', ['test1', 'test2', 'test3'], [true, true, true]],
      ['isDirty', ['test1', '', 'test3'], [true, undefined, true]],
      ['dirty', ['test1', '', 'test3'], [true, undefined, true]],
    ])(
      'should be dirtyFields when %s is defined when shouldDirty is true with array fields',
      (property, values, dirtyFields) => {
        const { result } = renderHook(() =>
          useForm<{
            test: string[];
          }>({
            defaultValues: {
              test: ['', '', ''],
            },
          }),
        );

        result.current.formState[property as 'isDirty' | 'dirtyFields'];
        result.current.formState.isDirty;
        result.current.formState.dirtyFields;

        result.current.register('test.0');
        result.current.register('test.1');
        result.current.register('test.2');

        act(() =>
          result.current.setValue('test', values, {
            shouldDirty: true,
          }),
        );

        expect(result.current.formState.isDirty).toBeTruthy();
        expect(result.current.formState.dirtyFields).toEqual({
          test: dirtyFields,
        });
      },
    );

    it.each(['isDirty', 'dirtyFields'])(
      'should not be dirtyFields when %s is defined when shouldDirty is false',
      (property) => {
        const { result } = renderHook(() =>
          useForm<{
            test: string;
          }>(),
        );

        result.current.formState[property as 'isDirty' | 'dirtyFields'];

        result.current.register('test');

        act(() =>
          result.current.setValue('test', 'test', { shouldDirty: false }),
        );

        expect(result.current.formState.isDirty).toBeFalsy();
        expect(result.current.formState.dirtyFields).toEqual({});
      },
    );

    it.each(['isDirty', 'dirtyFields'])(
      'should set name to dirtyFieldRef if field value is different with default value when formState.dirtyFields is defined',
      (property) => {
        const { result } = renderHook(() =>
          useForm<{ test: string }>({
            defaultValues: { test: 'default' },
          }),
        );
        result.current.formState[property as 'dirtyFields' | 'isDirty'];
        result.current.formState.isDirty;
        result.current.formState.dirtyFields;

        result.current.register('test');

        act(() => result.current.setValue('test', '1', { shouldDirty: true }));

        expect(result.current.formState.isDirty).toBeTruthy();
        expect(result.current.formState.dirtyFields.test).toBeTruthy();
      },
    );

    it.each(['isDirty', 'dirtyFields'])(
      'should unset name from dirtyFieldRef if field value is not different with default value when formState.dirtyFields is defined',
      (property) => {
        const { result } = renderHook(() =>
          useForm<{ test: string }>({
            defaultValues: { test: 'default' },
          }),
        );
        result.current.formState[property as 'isDirty' | 'dirtyFields'];
        result.current.formState.isDirty;
        result.current.formState.dirtyFields;

        result.current.register('test');

        act(() => result.current.setValue('test', '1', { shouldDirty: true }));

        expect(result.current.formState.isDirty).toBeTruthy();
        expect(result.current.formState.dirtyFields.test).toBeTruthy();

        act(() =>
          result.current.setValue('test', 'default', { shouldDirty: true }),
        );

        expect(result.current.formState.isDirty).toBeFalsy();
        expect(result.current.formState.dirtyFields.test).toBeUndefined();
      },
    );
  });

  describe('with touched', () => {
    it('should update touched with shouldTouched config', () => {
      const App = () => {
        const {
          setValue,
          register,
          formState: { touchedFields },
        } = useForm();

        return (
          <>
            <p>{Object.keys(touchedFields).map((field: string) => field)}</p>
            <input {...register('test')} />
            <button
              onClick={() => {
                setValue('test', 'data', { shouldTouch: true });
              }}
            >
              Test
            </button>
          </>
        );
      };
      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(screen.getByText('test')).toBeVisible();
    });
  });

  describe('with strict mode', () => {
    it('should be able to set input value async', async () => {
      function App() {
        const { control, setValue } = useForm();

        React.useEffect(() => {
          sleep(1000);
          setValue('name', 'test');
        }, [setValue]);

        return (
          <div className="App">
            <form>
              <Controller
                defaultValue=""
                name="name"
                control={control}
                render={({ field }) => {
                  return (
                    <div>
                      <input />
                      <p>{field.value}</p>
                    </div>
                  );
                }}
              />
            </form>
          </div>
        );
      }

      render(
        <React.StrictMode>
          <App />
        </React.StrictMode>,
      );

      jest.advanceTimersByTime(10000);

      expect(await screen.findByText('test')).toBeVisible();
    });
  });

  it('should set hidden input value correctly and reflect on the submission data', async () => {
    let submitData: Record<string, string> | undefined = undefined;

    const Component = () => {
      const { register, handleSubmit, setValue } = useForm<{
        test: string;
      }>();

      return (
        <div>
          <input type="hidden" defaultValue="test" {...register('test')} />
          <button
            onClick={() => {
              setValue('test', 'changed');
            }}
          >
            change
          </button>
          <button
            onClick={handleSubmit((data) => {
              submitData = data;
            })}
          >
            submit
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'change' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(submitData).toEqual({
        test: 'changed',
      }),
    );
  });

  it('should validate the input and return correct isValid formState', async () => {
    const { result } = renderHook(() =>
      useForm<{ test: { data: string; data1: string } }>({
        mode: VALIDATION_MODE.onChange,
      }),
    );

    result.current.formState.isValid;

    await act(async () => {
      await result.current.register('test.data', { required: true });
      await result.current.register('test.data1', { required: true });
    });

    await act(async () => {
      await result.current.trigger();
    });

    await act(async () => {
      result.current.setValue('test.data', 'test', { shouldValidate: true });
    });

    expect(result.current.formState.isValid).toBeFalsy();

    await act(async () => {
      await result.current.setValue('test.data1', 'test', {
        shouldValidate: true,
      });
    });

    expect(result.current.formState.isValid).toBeTruthy();
  });

  it('should setValue with valueAs', async () => {
    let result: Record<string, string>;

    function App() {
      const { register, handleSubmit, setValue } = useForm();

      React.useEffect(() => {
        setValue('setStringDate', '2021-04-23');
      }, [setValue]);

      return (
        <form
          onSubmit={handleSubmit((data) => {
            result = data;
          })}
        >
          <input
            type="date"
            {...register('setStringDate', { valueAsDate: true })}
          />
          <input type="submit" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(result).toEqual({
        setStringDate: new Date('2021-04-23'),
      }),
    );
  });

  it('should set value for field array name correctly', () => {
    const inputId = 'name';

    const App = () => {
      const { control, setValue } = useForm<{
        names: { name: string; id?: string }[];
      }>();

      const { fields } = useFieldArray({ control, name: 'names' });

      React.useEffect(() => {
        setValue('names', [{ name: 'initial value' }]);
      }, [setValue]);

      const onChangeValue = () => {
        setValue('names.0', { name: 'updated value', id: 'test' });
      };

      return (
        <>
          {fields.map((item, index) => (
            <Controller
              key={item.id}
              control={control}
              name={`names.${index}.name` as const}
              render={({ field }) => <input data-testid={inputId} {...field} />}
            />
          ))}
          <button onClick={onChangeValue}>Update</button>
        </>
      );
    };

    render(<App />);

    expect(screen.getByTestId(inputId)).toHaveValue('initial value');

    fireEvent.click(screen.getByText('Update'));

    expect(screen.getByTestId(inputId)).toHaveValue('updated value');
  });

  it('should set field array correctly without affect the parent field array', async () => {
    const fieldsValue: unknown[] = [];
    type FormValues = {
      test: { name: string; nestedArray: { name: string }[] }[];
    };

    const Child = ({
      control,
      index,
    }: {
      control: Control<FormValues>;
      index: number;
    }) => {
      useFieldArray({
        control,
        name: `test.${index}.nestedArray`,
      });

      return null;
    };

    const App = () => {
      const { setValue, control } = useForm<FormValues>({
        defaultValues: {
          test: [{ name: 'bill', nestedArray: [] }],
        },
      });
      const { fields } = useFieldArray({
        control,
        name: 'test',
      });

      fieldsValue.push(fields);

      return (
        <div>
          {fields.map((field, index) => (
            <Child key={field.id} control={control} index={index} />
          ))}
          <button
            onClick={() => {
              setValue('test.0.nestedArray' as `test.0.nestedArray`, [
                { name: 'append' },
              ]);
            }}
          >
            setValue
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    fireEvent.click(screen.getByRole('button'));

    expect(fieldsValue.length).toEqual(1);
  });

  it('should not register deeply nested inputs', () => {
    let fields: unknown;
    let data: unknown;

    const App = () => {
      const { setValue, control, getValues } = useForm();
      useFieldArray({
        control,
        name: 'test',
      });
      const [, setShow] = React.useState(false);
      fields = control._fields;

      return (
        <>
          <button
            onClick={() => {
              setValue('test', [
                {
                  name: 'append',
                  nestedArray: [{ field1: 'append', field2: 'append' }],
                },
              ]);
              setShow(true);
            }}
          >
            setValue
          </button>
          <button
            onClick={() => {
              data = getValues();
            }}
          >
            getValues
          </button>
        </>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'setValue' }));

    expect(fields).toEqual({});

    fireEvent.click(screen.getByRole('button', { name: 'getValues' }));

    expect(data).toEqual({
      test: [
        {
          name: 'append',
          nestedArray: [
            {
              field1: 'append',
              field2: 'append',
            },
          ],
        },
      ],
    });
  });

  describe('when set field to null', () => {
    it('should be able to set correctly with register', () => {
      let result: unknown;

      type FormData = {
        user: { name: string } | null;
      };

      function App() {
        const { setValue, watch, register } = useForm<FormData>({
          defaultValues: {
            user: {
              name: 'John Doe',
            },
          },
        });

        result = watch();

        register('user');

        return (
          <div>
            <button onClick={() => setValue('user', null)}>
              Set user to null
            </button>
          </div>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(result).toEqual({
        user: null,
      });
    });

    it('should be able to set correctly without register', () => {
      let result: unknown;

      type FormData = {
        user: { name: string } | null;
      };

      function App() {
        const { setValue, watch } = useForm<FormData>({
          defaultValues: {
            user: {
              name: 'John Doe',
            },
          },
        });

        result = watch();

        return (
          <div>
            <button onClick={() => setValue('user', null)}>
              Set user to null
            </button>
          </div>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(result).toEqual({
        user: null,
      });
    });
  });

  it('should only be able to update value of array which is not registered', async () => {
    const App = () => {
      const { setValue, watch } = useForm({
        defaultValues: {
          test: ['1', '2', '3'],
        },
      });

      React.useEffect(() => {
        setValue('test', ['2', '2']);
      }, [setValue]);

      const result = watch('test');

      return <p>{JSON.stringify(result)}</p>;
    };

    render(<App />);

    expect(await screen.findByText('["2","2"]')).toBeVisible();
  });

  it('should only be able to update value of object which is not registered', async () => {
    const App = () => {
      const { setValue, watch } = useForm<{
        test: {
          data: string;
          data1: string;
          data2: string;
        };
      }>({
        defaultValues: {
          test: {
            data: '1',
            data1: '2',
          },
        },
      });

      React.useEffect(() => {
        setValue('test', {
          data: '2',
          data1: '2',
          data2: '3',
        });
      }, [setValue]);

      const result = watch('test');

      return <p>{JSON.stringify(result)}</p>;
    };

    render(<App />);

    expect(
      await screen.findByText('{"data":"2","data1":"2","data2":"3"}'),
    ).toBeVisible();
  });

  it('should update nested object which contain date object without register', () => {
    const watchedValue: unknown[] = [];
    const defaultValues = {
      userData: {
        userId: 'abc',
        date: new Date('2021-06-15'),
      },
    };

    function App() {
      const { setValue, watch } = useForm({
        defaultValues,
      });

      const setUserData = () => {
        setValue('userData', {
          userId: '1234',
          date: new Date('2021-12-17'),
        });
      };

      watchedValue.push(watch('userData'));

      return (
        <div>
          <form>
            <button type="button" onClick={() => setUserData()}>
              Update
            </button>
          </form>
        </div>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(watchedValue).toEqual([
      {
        date: new Date('2021-06-15T00:00:00.000Z'),
        userId: 'abc',
      },
      {
        date: new Date('2021-12-17T00:00:00.000Z'),
        userId: '1234',
      },
    ]);
  });

  it('should update isDirty even input is not registered', async () => {
    const App = () => {
      const {
        setValue,
        formState: { isDirty },
      } = useForm({
        defaultValues: {
          test: '',
        },
      });

      React.useEffect(() => {
        setValue('test', '1234', { shouldDirty: true });
      }, [setValue]);

      return <p>{isDirty ? 'dirty' : 'not'}</p>;
    };

    render(<App />);

    expect(await screen.findByText('dirty')).toBeVisible();
  });

  it('should update both dirty and touched state', () => {
    const App = () => {
      const {
        register,
        formState: { dirtyFields, touchedFields },
        setValue,
      } = useForm({
        defaultValues: {
          firstName: '',
        },
      });

      return (
        <form>
          <label>First Name</label>
          <input type="text" {...register('firstName')} />
          {dirtyFields.firstName && <p>dirty</p>}
          {touchedFields.firstName && <p>touched</p>}

          <button
            type="button"
            onClick={() =>
              setValue('firstName', 'test', {
                shouldValidate: true,
                shouldDirty: true,
                shouldTouch: true,
              })
            }
          >
            setValue
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(screen.getByText('dirty')).toBeVisible();
    expect(screen.getByText('touched')).toBeVisible();
  });
});


================================================
File: /src/__tests__/isPlainObject.test.ts
================================================
import isPlainObject from '../utils/isPlainObject';
import noop from '../utils/noop';

describe('isPlainObject', function () {
  it('should identify plan object or not', function () {
    function test() {
      return {
        test: noop,
      };
    }

    expect(isPlainObject(Object.create({}))).toBeTruthy();
    expect(isPlainObject(Object.create(Object.prototype))).toBeTruthy();
    expect(isPlainObject({ foo: 'bar' })).toBeTruthy();
    expect(isPlainObject({})).toBeTruthy();
    expect(isPlainObject(Object.create(null))).toBeFalsy();
    expect(!isPlainObject(/foo/)).toBeTruthy();
    expect(!isPlainObject(function () {})).toBeTruthy();
    expect(!isPlainObject(['foo', 'bar'])).toBeTruthy();
    expect(!isPlainObject([])).toBeTruthy();
    expect(!isPlainObject(test)).toBeTruthy();
  });
});


================================================
File: /src/__tests__/logic/validateField.test.tsx
================================================
import getCheckboxValue from '../../logic/getCheckboxValue';
import getRadioValue from '../../logic/getRadioValue';
import validateField from '../../logic/validateField';

jest.mock('../../logic/getRadioValue');
jest.mock('../../logic/getCheckboxValue');

describe('validateField', () => {
  it('should return required true when input not filled with required', async () => {
    (getRadioValue as jest.Mock).mockImplementation(() => ({
      value: '2',
    }));
    (getCheckboxValue as jest.Mock).mockImplementation(() => ({
      value: false,
      isValid: false,
    }));

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: true,
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'text', value: '', name: 'test' },
        message: '',
        type: 'required',
      },
    });

    const input = document.createElement('input');

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: input,
            required: true,
            valueAsNumber: true,
          },
        },
        {},
        false,
      ),
    ).toEqual({
      test: {
        ref: input,
        message: '',
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: 'required',
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'text', value: '', name: 'test' },
        message: 'required',
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            valueAsNumber: true,
            mount: true,
            name: 'test',
            ref: { name: 'test' },
            required: 'required',
          },
        },
        {
          test: 2,
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: 'required',
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'text', value: '', name: 'test' },
        message: 'required',
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: {
              value: true,
              message: 'required',
            },
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'text', value: '', name: 'test' },
        message: 'required',
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: {
              value: true,
              message: 'required',
            },
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'text', value: '', name: 'test' },
        message: 'required',
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: {
              value: false,
              message: 'required',
            },
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'radio', name: 'test' },
            required: true,
          },
        },
        {
          test: false,
        },
        false,
      ),
    ).toEqual({
      test: {
        message: '',
        type: 'required',
        ref: { type: 'radio', name: 'test' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '', name: 'test' },
            required: 'test',
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        message: 'test',
        type: 'required',
        ref: { type: 'text', name: 'test', value: '' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'radio', value: '', name: 'test' },
            required: 'test',
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        message: 'test',
        type: 'required',
        ref: { type: 'radio', name: 'test', value: '' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'checkbox', name: 'test' },
            required: 'test',
          },
        },
        {
          test: false,
        },
        false,
      ),
    ).toEqual({
      test: {
        message: 'test',
        type: 'required',
        ref: { type: 'checkbox', name: 'test' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', value: '0', name: 'test' },
            required: true,
            value: '0',
          },
        },
        {
          test: '0',
        },
        false,
      ),
    ).toEqual({});

    (getCheckboxValue as jest.Mock).mockImplementation(() => ({
      value: 'test',
      isValid: true,
    }));

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'checkbox', name: 'test' },
            required: 'test',
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            valueAsNumber: true,
            ref: { name: 'test', value: '' },
            required: true,
            value: NaN,
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'required',
        message: '',
        ref: {
          name: 'test',
          value: '',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { name: 'test', type: 'file', value: '' },
            required: true,
            value: {},
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'required',
        message: '',
        ref: {
          type: 'file',
          name: 'test',
          value: '',
        },
      },
    });
  });

  it('should return max error', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 10 },
            value: 10,
            required: true,
            max: 0,
          },
        },
        {
          test: 10,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: '',
        ref: { type: 'number', name: 'test', valueAsNumber: 10 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 10 },
            value: 10,
            required: true,
            max: {
              value: 0,
              message: 'max',
            },
          },
        },
        {
          test: 10,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: 'max',
        ref: { type: 'number', name: 'test', valueAsNumber: 10 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 10 },
            required: true,
            max: {
              value: 0,
              message: 'max',
            },
            value: 10,
          },
        },
        {
          test: 10,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: 'max',
        ref: { type: 'number', name: 'test', valueAsNumber: 10 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 8 },
            value: 8,
            required: true,
            max: 8,
          },
        },
        {
          test: 8,
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 10 },
            value: 10,
            max: 8,
          },
        },
        {
          test: 10,
        },
        true,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: '',
        ref: { type: 'number', name: 'test', valueAsNumber: 10 },
        types: {
          max: true,
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'custom', name: 'test', valueAsNumber: NaN },
            value: '',
            required: true,
          },
        },
        {
          test: '',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'required',
        message: '',
        ref: { type: 'custom', name: 'test', valueAsNumber: NaN },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'custom',
              name: 'test',
              valueAsNumber: NaN,
            },
            value: undefined,
            required: true,
          },
        },
        {
          test: undefined,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'required',
        message: '',
        ref: {
          type: 'custom',
          name: 'test',
          value: undefined,
          valueAsNumber: NaN,
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'custom',
              name: 'test',
              valueAsNumber: NaN,
            },
            value: null,
            required: true,
          },
        },
        {
          test: null,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'required',
        message: '',
        ref: { type: 'custom', name: 'test', valueAsNumber: NaN },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'custom', name: 'test' },
            required: true,
            value: 'ok',
          },
        },
        {
          test: 'ok',
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'date',
              name: 'test',
            },
            value: '2019-2-13',
            required: true,
            max: '2019-1-12',
          },
        },
        {
          test: '2019-2-13',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: '',
        ref: {
          type: 'date',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'week',
              name: 'test',
            },
            value: '2022-W18',
            required: true,
            max: {
              value: '2022-W17',
              message: 'max',
            },
          },
        },
        {
          test: '2022-W18',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: 'max',
        ref: {
          type: 'week',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'time',
              name: 'test',
            },
            value: '14:00',
            required: true,
            max: {
              value: '13:00',
              message: 'max',
            },
          },
        },
        {
          test: '14:00',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: 'max',
        ref: {
          type: 'time',
          name: 'test',
        },
      },
    });
  });

  it('should return min error', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: -1 },
            value: -1,
            required: true,
            min: 0,
          },
        },
        {
          test: -1,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: '',
        ref: { type: 'number', name: 'test', valueAsNumber: -1 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: -1 },
            value: -1,
            required: true,
            min: {
              value: 0,
              message: 'min',
            },
          },
        },
        {
          test: -1,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: { type: 'number', name: 'test', valueAsNumber: -1 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: -1 },
            value: -1,
            required: true,
            min: {
              value: 0,
              message: 'min',
            },
          },
        },
        {
          test: -1,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: { type: 'number', name: 'test', valueAsNumber: -1 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'number', name: 'test', valueAsNumber: 10 },
            value: 10,
            required: true,
            min: 12,
          },
        },
        {
          test: 10,
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: '',
        ref: { type: 'number', name: 'test', valueAsNumber: 10 },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'date',
              name: 'test',
              valueAsDate: new Date('2019-2-12'),
            },
            value: '2019-2-12',
            required: true,
            min: '2019-3-12',
          },
        },
        {
          test: '2019-2-12',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: '',
        ref: {
          type: 'date',
          name: 'test',
          valueAsDate: new Date('2019-2-12'),
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'date',
              name: 'test',
            },
            value: '2019-2-12',
            required: true,
            min: {
              value: '2019-3-12',
              message: 'min',
            },
          },
        },
        {
          test: '2019-2-12',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: {
          type: 'date',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'date',
              name: 'test',
              valueAsDate: new Date('2019-2-12'),
            },
            value: '2019-2-12',
            required: true,
            min: {
              value: '2019-3-12',
              message: 'min',
            },
          },
        },
        {
          test: '2019-2-12',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: {
          type: 'date',
          name: 'test',
          valueAsDate: new Date('2019-2-12'),
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'week',
              name: 'test',
            },
            value: '2022-W15',
            required: true,
            min: {
              value: '2022-W17',
              message: 'min',
            },
          },
        },
        {
          test: '2022-W15',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: {
          type: 'week',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'time',
              name: 'test',
            },
            value: '12:00',
            required: true,
            min: {
              value: '13:00',
              message: 'min',
            },
          },
        },
        {
          test: '12:00',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: 'min',
        ref: {
          type: 'time',
          name: 'test',
        },
      },
    });
  });

  it('should return min and max error for custom input', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: '', name: 'test' },
            value: '1',
            required: true,
            min: '4',
          },
        },
        {
          test: '1',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'min',
        message: '',
        ref: { type: '', name: 'test' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: '', name: 'test' },
            value: '4',
            required: true,
            max: '2',
          },
        },
        {
          test: '4',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: '',
        ref: { type: '', name: 'test' },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: '',
              name: 'test',
              valueAsDate: new Date('2019-2-12'),
            },
            value: '2019-2-12',
            required: true,
            max: '2019-1-12',
          },
        },
        {
          test: '2019-2-12',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'max',
        message: '',
        ref: {
          type: '',
          name: 'test',
          valueAsDate: new Date('2019-2-12'),
        },
      },
    });
  });

  it('should return max length error ', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            maxLength: 12,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: '',
        type: 'maxLength',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            maxLength: {
              value: 12,
              message: 'maxLength',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'maxLength',
        type: 'maxLength',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            maxLength: {
              value: 12,
              message: 'maxLength',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'maxLength',
        type: 'maxLength',
      },
    });
  });

  it('should return min length error ', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            minLength: 200,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: '',
        type: 'minLength',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            minLength: {
              value: 200,
              message: 'minLength',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'minLength',
        type: 'minLength',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            minLength: {
              value: 200,
              message: 'minLength',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'minLength',
        type: 'minLength',
      },
    });
  });

  it('should return pattern error when not matching', async () => {
    const emailRegex =
      /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            pattern: emailRegex,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: '',
        type: 'pattern',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            required: true,
            value: 'This is a long text input',
            pattern: {
              value: emailRegex,
              message: 'regex failed',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'regex failed',
        type: 'pattern',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            pattern: {
              value: emailRegex,
              message: 'regex failed',
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        message: 'regex failed',
        type: 'pattern',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'test@test.com',
            required: true,
            pattern: emailRegex,
          },
        },
        {
          test: 'test@test.com',
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: null,
            required: false,
            pattern: emailRegex,
          },
        },
        {
          test: null,
        },
        false,
      ),
    ).toEqual({});
  });

  it('should validate for custom validation', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            validate: (value) => value.toString().length > 3,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({});

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            validate: (value) => value.toString().length < 3,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          type: 'text',
          name: 'test',
        },
        type: 'validate',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            required: true,
            validate: {
              test: (value) => value.toString().length < 3,
              test1: (value) => value.toString().length > 10,
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          type: 'text',
          name: 'test',
        },
        type: 'test',
        message: '',
      },
    });

    (getRadioValue as jest.Mock).mockImplementation(() => {
      return {
        isValid: false,
        value: 'test',
      };
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input!',
            validate: {
              test: (value) => value.toString().length < 3,
              test1: (value) => value.toString().length > 10,
            },
          },
        },
        {
          test: 'This is a long text input!',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'test',
        message: '',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'radio',
              name: 'test',
            },
            value: 'This is a long text input!',
            validate: {
              test: (value) => value.toString().length < 3,
              test1: (value) => value.toString().length > 10,
            },
            refs: [{ type: 'data' } as HTMLInputElement],
          },
        },
        {
          test: 'This is a long text input!',
        },
        false,
      ),
    ).toEqual({
      test: {
        ref: { type: 'data' },
        type: 'test',
        message: '',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'radio',
              name: 'test',
            },
            value: 'This is a long text input!',
            validate: {
              test: () => true,
            },
            refs: [
              {
                type: 'data',
              } as HTMLInputElement,
            ],
          },
        },
        {
          test: 'This is a long text input!',
        },
        false,
      ),
    ).toEqual({});
  });

  it('should return error message when it is defined', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            validate: {
              test: (value) => {
                if (value.toString().length > 3) {
                  return 'max 3';
                }
                return true;
              },
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'test',
        message: 'max 3',
        ref: {
          type: 'text',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            validate: {
              test: (value) => {
                if (value.toString().length > 3) {
                  return 'max 3';
                }
                return true;
              },
            },
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'test',
        message: 'max 3',
        ref: {
          type: 'text',
          name: 'test',
        },
      },
    });
  });

  it('should return result or empty string when validate has error', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            validate: (value) => value.toString().length < 3 || 'bill',
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'validate',
        message: 'bill',
        ref: {
          type: 'text',
          name: 'test',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            validate: (value) => value.toString().length < 3 || 'bill',
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({
      test: {
        type: 'validate',
        message: 'bill',
        ref: {
          type: 'text',
          name: 'test',
        },
      },
    });
  });

  it('if undefined returned from validate, no error is reported', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
            validate: () => undefined,
          },
        },
        {
          test: 'This is a long text input',
        },
        false,
      ),
    ).toEqual({});
  });

  it('should do nothing when validate is not an object nor function', async () => {
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: {
              type: 'text',
              name: 'test',
            },
            value: 'This is a long text input',
          },
        },
        { test: 'This is a long text input' },
        false,
      ),
    ).toEqual({});
  });

  it('should return all validation errors', async () => {
    (getRadioValue as jest.Mock).mockImplementation(() => ({
      value: '',
    }));

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: '',
            required: true,
            minLength: 10,
            pattern: /d/i,
            validate: (value) => value === 'test',
          },
        },
        {
          test: '',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'required',
        types: {
          required: true,
          validate: true,
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: '123',
            required: true,
            minLength: 10,
            pattern: /d/i,
            validate: (value) => value === 'test',
          },
        },
        {
          test: '123',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'minLength',
        types: {
          minLength: true,
          pattern: true,
          validate: true,
        },
      },
    });
  });

  it('should handle pattern with g flag', async () => {
    const reusedRe = /a/g;

    (getRadioValue as jest.Mock).mockImplementation(() => ({
      value: '',
    }));
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: 'a',
            required: true,
            minLength: 10,
            pattern: reusedRe,
            validate: (value) => value === 'test',
          },
        },
        {
          test: 'a',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'minLength',
        types: {
          minLength: true,
          validate: true,
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: 'a',
            required: true,
            minLength: 10,
            pattern: reusedRe,
            validate: (value) => value === 'test',
          },
        },
        {
          test: 'a',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'minLength',
        types: {
          minLength: true,
          validate: true,
        },
      },
    });
  });

  it('should return all validation error messages', async () => {
    (getRadioValue as jest.Mock).mockImplementation(() => ({
      value: '',
    }));
    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: '',
            required: 'test',
            minLength: {
              value: 10,
              message: 'minLength',
            },
            pattern: {
              value: /d/i,
              message: 'pattern',
            },
            validate: {
              test: (value) => value === 'test',
              test1: (value) => value == 'test' || 'Luo',
              test2: (value) => value == 'test' || 'Bill',
            },
          },
        },
        {
          test: '',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: 'test',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'required',
        types: {
          required: 'test',
          test: true,
          test1: 'Luo',
          test2: 'Bill',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: 'bil',
            required: 'test',
            minLength: {
              value: 10,
              message: 'minLength',
            },
            pattern: {
              value: /d/i,
              message: 'pattern',
            },
            validate: {
              test: (value) => value === 'test',
              test1: (value) => value == 'test' || 'Luo',
              test2: (value) => value == 'test' || 'Bill',
            },
          },
        },
        {
          test: 'bil',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: 'minLength',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'minLength',
        types: {
          minLength: 'minLength',
          pattern: 'pattern',
          test: true,
          test1: 'Luo',
          test2: 'Bill',
        },
      },
    });

    expect(
      await validateField(
        {
          _f: {
            mount: true,
            name: 'test',
            ref: { type: 'text', name: 'test' },
            value: 'bil',
            required: 'test',
            minLength: {
              value: 10,
              message: 'minLength',
            },
            pattern: {
              value: /d/i,
              message: 'pattern',
            },
            validate: {
              test: (value) => value === 'test',
              test1: (value) => value == 'test' || 'Luo',
              test2: (value) => value == 'test' || 'Bill',
            },
          },
        },
        {
          test: 'bil',
        },
        true,
      ),
    ).toEqual({
      test: {
        message: 'minLength',
        ref: {
          name: 'test',
          type: 'text',
        },
        type: 'minLength',
        types: {
          minLength: 'minLength',
          pattern: 'pattern',
          test: true,
          test1: 'Luo',
          test2: 'Bill',
        },
      },
    });
  });

  describe('with Browser native validation', () => {
    it('should invoke setCustomValidity for invalid input', () => {
      const setCustomValidity = jest.fn();
      const reportValidity = jest.fn();

      validateField(
        {
          _f: {
            name: 'test',
            ref: {
              setCustomValidity,
              reportValidity,
              name: 'test',
              value: '',
            },
            value: '',
            required: true,
            mount: true,
          },
        },
        {
          test: '',
        },
        false,
        true,
      );

      expect(setCustomValidity).toBeCalledWith('');
      expect(reportValidity).toBeCalled();
    });

    it('should invoke setCustomValidity for invalid input with its message', () => {
      const setCustomValidity = jest.fn();
      const reportValidity = jest.fn();

      validateField(
        {
          _f: {
            name: 'test',
            ref: {
              setCustomValidity,
              reportValidity,
              name: 'test',
              value: '',
            },
            value: '',
            required: 'something is wrong',
            mount: true,
          },
        },
        {
          test: '',
        },
        false,
        true,
      );

      expect(setCustomValidity).toBeCalledWith('something is wrong');
      expect(reportValidity).toBeCalled();
    });

    it('should invoke setCustomValidity with empty string for a valid input', () => {
      const setCustomValidity = jest.fn();
      const reportValidity = jest.fn();

      validateField(
        {
          _f: {
            name: 'test',
            ref: {
              setCustomValidity,
              reportValidity,
              name: 'test',
              value: 'test',
            },
            value: 'test',
            required: true,
            mount: true,
          },
        },
        {
          test: 'test',
        },
        false,
        true,
      );

      expect(setCustomValidity).toBeCalledWith('');
      expect(reportValidity).toBeCalled();
    });

    it('should abort validation early when input is disabled', async () => {
      expect(
        await validateField(
          {
            _f: {
              name: 'test',
              ref: {
                name: 'test',
                value: '',
              },
              value: '',
              required: 'something is wrong',
              disabled: true,
            },
          },
          {
            test: '',
          },
          false,
        ),
      ).toEqual({});
    });
  });

  it('should validate field array with required attribute', async () => {
    expect(
      await validateField(
        {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
              value: '',
            },
            value: undefined,
            required: true,
            mount: true,
          },
        },
        {
          test: undefined,
        },
        false,
        false,
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          value: '',
        },
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
              value: '',
            },
            value: [],
            required: true,
            mount: true,
          },
        },
        [],
        false,
        false,
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          value: '',
        },
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
              value: '',
            },
            value: null,
            required: true,
            mount: true,
          },
        },
        {
          test: null,
        },
        false,
        false,
        true,
      ),
    ).toEqual({
      test: {
        message: '',
        ref: {
          name: 'test',
          value: '',
        },
        type: 'required',
      },
    });

    expect(
      await validateField(
        {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
              value: '',
            },
            value: [],
            required: true,
            mount: true,
          },
        },
        {
          test: [{}],
        },
        false,
        false,
        true,
      ),
    ).toEqual({});
  });
});


================================================
File: /src/__tests__/logic/getFieldValue.test.ts
================================================
import getFieldValue from '../../logic/getFieldValue';
import { Field } from '../../types';

jest.mock('../../logic/getRadioValue', () => ({
  __esModule: true,
  default: () => ({
    value: 2,
  }),
}));

jest.mock('../../logic/getCheckboxValue', () => ({
  __esModule: true,
  default: () => ({
    value: 'testValue',
  }),
}));

describe('getFieldValue', () => {
  it('should return correct value when type is radio', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          type: 'radio',
          name: 'test',
        },
      }),
    ).toBe(2);
  });

  it('should return the correct value when type is checkbox', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          name: 'test',
          type: 'checkbox',
        },
      }),
    ).toBe('testValue');
  });

  it('should return it value for other types', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          type: 'text',
          name: 'bill',
          value: 'value',
        },
      }),
    ).toBe('value');
  });

  it('should return empty string when radio input value is not found', () => {
    expect(getFieldValue({ ref: {} } as Field['_f'])).toEqual(undefined);
  });

  it('should return files for input type file', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          type: 'file',
          name: 'test',
          files: null,
        },
      }),
    ).toEqual(null);
  });

  it('should return undefined when input is not found', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          name: 'file',
          files: null,
        },
      }),
    ).toEqual(undefined);
  });

  it('should not return value when the input is disabled', () => {
    expect(
      getFieldValue({
        name: 'test',
        ref: {
          name: 'radio',
          disabled: true,
          type: 'radio',
        },
      }),
    ).toEqual(undefined);
  });
});


================================================
File: /src/__tests__/logic/appendErrors.test.ts
================================================
import appendErrors from '../../logic/appendErrors';

describe('appendErrors', () => {
  it('should return empty object when validateAllFieldCriteria is false', () => {
    const errors = {
      test: {
        type: 'required',
        message: 'test',
      },
    };
    expect(appendErrors('test', false, errors, 'min', 'test')).toEqual({});
  });

  it('should return error object when validateAllFieldCriteria is true', () => {
    const errors = {
      test: {
        type: 'required',
        message: 'test',
        types: {},
      },
    };

    expect(appendErrors('test', true, errors, 'required', 'test')).toEqual({
      message: 'test',
      type: 'required',
      types: {
        required: 'test',
      },
    });

    errors.test.types = { required: 'test' };
    expect(appendErrors('test', true, errors, 'min', 'test')).toEqual({
      message: 'test',
      type: 'required',
      types: {
        required: 'test',
        min: 'test',
      },
    });

    errors.test.types = { ...errors.test.types, min: 'test' };
    expect(appendErrors('test', true, errors, 'max', 'test')).toEqual({
      message: 'test',
      type: 'required',
      types: {
        required: 'test',
        min: 'test',
        max: 'test',
      },
    });

    errors.test.types = { ...errors.test.types, max: 'test' };
    expect(appendErrors('test', true, errors, 'undefined', undefined)).toEqual({
      message: 'test',
      type: 'required',
      types: {
        required: 'test',
        min: 'test',
        max: 'test',
        undefined: true,
      },
    });

    errors.test.types = {
      ...errors.test.types,
      undefined: true,
    };
    expect(
      appendErrors('test', true, errors, 'invalid_string', [
        'uppercase',
        'lowercase',
        'number',
      ]),
    ).toEqual({
      message: 'test',
      type: 'required',
      types: {
        required: 'test',
        min: 'test',
        max: 'test',
        undefined: true,
        invalid_string: ['uppercase', 'lowercase', 'number'],
      },
    });
  });
});


================================================
File: /src/__tests__/logic/getFocusFieldName.test.ts
================================================
import getFocusFieldName from '../../logic/getFocusFieldName';

describe('getFocusFieldName', () => {
  it('should return expected focus name', () => {
    expect(getFocusFieldName('test', 0, { shouldFocus: false })).toEqual('');
    expect(
      getFocusFieldName('test', 0, { shouldFocus: true, focusName: 'test' }),
    ).toEqual('test');
    expect(
      getFocusFieldName('test', 0, { shouldFocus: true, focusIndex: 1 }),
    ).toEqual('test.1.');
    expect(getFocusFieldName('test', 0)).toEqual('test.0.');
  });
});


================================================
File: /src/__tests__/logic/getRadioValue.test.ts
================================================
import getRadioValue from '../../logic/getRadioValue';

describe('getRadioValue', () => {
  it('should return default value if not valid or empty options', () => {
    expect(getRadioValue(undefined)).toEqual({
      isValid: false,
      value: null,
    });
  });

  it('should return valid to true when value found', () => {
    expect(
      getRadioValue([
        { name: 'bill', checked: false, value: '1' } as HTMLInputElement,
        { name: 'bill', checked: true, value: '2' } as HTMLInputElement,
      ]),
    ).toEqual({
      isValid: true,
      value: '2',
    });
  });

  it('should return disabled input correctly', () => {
    expect(
      getRadioValue([
        {
          name: 'bill',
          checked: false,
          value: '1',
          disabled: true,
        } as HTMLInputElement,
        { name: 'bill', checked: true, value: '2' } as HTMLInputElement,
      ]),
    ).toEqual({
      isValid: true,
      value: '2',
    });

    expect(
      getRadioValue([
        {
          name: 'bill',
          checked: false,
          value: '1',
        } as HTMLInputElement,
        {
          name: 'bill',
          checked: true,
          disabled: true,
          value: '2',
        } as HTMLInputElement,
      ]),
    ).toEqual({
      isValid: false,
      value: null,
    });
  });
});


================================================
File: /src/__tests__/logic/getValidateError.test.ts
================================================
import getValidateError from '../../logic/getValidateError';
import noop from '../../utils/noop';

describe('getValidateError', () => {
  it('should return field error in correct format', () => {
    expect(
      getValidateError(
        'This is a required field',
        {
          name: 'test1',
          value: '',
        },
        'required',
      ),
    ).toEqual({
      type: 'required',
      message: 'This is a required field',
      ref: {
        name: 'test1',
        value: '',
      },
    });

    expect(
      getValidateError(
        false,
        {
          name: 'test1',
          value: '',
        },
        'required',
      ),
    ).toEqual({
      type: 'required',
      message: '',
      ref: {
        name: 'test1',
        value: '',
      },
    });
  });

  it('should return undefined when called with non string result', () => {
    expect(getValidateError(undefined, noop)).toBeUndefined();
  });
});


================================================
File: /src/__tests__/logic/getNodeParentName.test.ts
================================================
import getNodeParentName from '../../logic/getNodeParentName';

describe('getNodeParentName', () => {
  it('should return parent name when name is field array', () => {
    expect(getNodeParentName('test.0')).toBe('test');
    expect(getNodeParentName('test1.1')).toBe('test1');
    expect(getNodeParentName('test.0.data.0')).toBe('test');
    expect(getNodeParentName('test.data.0')).toBe('test.data');
    expect(getNodeParentName('test.1st')).toBe('test.1st');
  });

  it('should return empty string when name is not field array', () => {
    expect(getNodeParentName('test')).toBe('test');
    expect(getNodeParentName('test0')).toBe('test0');
    expect(getNodeParentName('te1st')).toBe('te1st');
  });
});


================================================
File: /src/__tests__/logic/schemaErrorLookup.test.ts
================================================
import schemaErrorLookup from '../../logic/schemaErrorLookup';

describe('errorsLookup', () => {
  it('should be able to look up the error', () => {
    expect(
      schemaErrorLookup<{
        test: {
          deep: string;
        };
      }>(
        {
          test: {
            type: 'test',
            message: 'error',
            deep: {
              type: 'deep',
              message: 'error',
            },
          },
        },
        {},
        'test.deep.whatever',
      ),
    ).toEqual({
      error: {
        type: 'deep',
        message: 'error',
      },
      name: 'test.deep',
    });

    expect(
      schemaErrorLookup(
        {
          test: {
            type: 'test',
            message: 'error',
          },
        },
        {},
        'test.0.whatever',
      ),
    ).toEqual({
      error: {
        type: 'test',
        message: 'error',
      },
      name: 'test',
    });

    expect(
      schemaErrorLookup(
        {
          test: {
            type: 'test',
            message: 'error',
          },
        },
        {},
        'test',
      ),
    ).toEqual({
      error: {
        type: 'test',
        message: 'error',
      },
      name: 'test',
    });

    expect(
      schemaErrorLookup<{
        test: {
          deep: string;
        };
        test1: {
          nested: {
            deepNested: string;
          };
        };
      }>(
        {
          test: {
            type: 'test',
            message: 'error',
          },
          test1: {
            type: 'test',
            message: 'error',
            nested: {
              type: 'test',
              message: 'error',
              deepNested: {
                type: 'deepNested',
                message: 'error',
              },
            },
          },
        },
        {},
        'test1.nested.deepNested.whatever',
      ),
    ).toEqual({
      error: { message: 'error', type: 'deepNested' },
      name: 'test1.nested.deepNested',
    });
  });

  it('should return undefined when not found', () => {
    expect(
      schemaErrorLookup(
        {
          test: {
            type: 'test',
            message: 'error',
          },
        },
        {},
        'test1234',
      ),
    ).toEqual({ error: undefined, name: 'test1234' });

    expect(
      schemaErrorLookup(
        {
          test: {
            type: 'test',
            message: 'error',
          },
        },
        {},
        'testX.1.test',
      ),
    ).toEqual({
      name: 'testX.1.test',
    });

    expect(
      schemaErrorLookup<{
        test: {
          test: string;
          test1: string;
        };
      }>(
        {
          test: {
            test: {
              type: 'test',
              message: 'error',
            },
            test1: {
              type: 'test',
              message: 'error',
            },
          },
        },
        {},
        'test.test2',
      ),
    ).toEqual({
      name: 'test.test2',
    });
  });

  it('should prevent error from reported when field is identified', () => {
    expect(
      schemaErrorLookup<{
        test: {
          test: string;
          test1: string;
        };
      }>(
        {
          test: {
            test: {
              type: 'test',
              message: 'error',
            },
            test1: {
              type: 'test',
              message: 'error',
            },
          },
        },
        {
          test: {
            test1: {
              _f: {
                ref: {},
                name: 'test',
              },
            },
          },
        },
        'test.test1.whatever',
      ),
    ).toEqual({
      name: 'test.test1.whatever',
    });

    expect(
      schemaErrorLookup<{
        test: {
          test: string;
          test1: string;
        };
      }>(
        {
          test: {
            test: {
              type: 'test',
              message: 'error',
            },
            test1: {
              type: 'test',
              message: 'error',
            },
          },
        },
        {
          test: {
            test1: {
              _f: {
                ref: {},
                name: 'test',
              },
            },
          },
        },
        'test.testXYZ',
      ),
    ).toEqual({
      name: 'test.testXYZ',
    });
  });
});


================================================
File: /src/__tests__/logic/skipValidation.test.ts
================================================
import skipValidation from '../../logic/skipValidation';

describe('should skip validation', () => {
  it('when is onChange mode and blur event', () => {
    expect(
      skipValidation(
        false,
        false,
        false,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: true,
          isOnBlur: true,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });

  it('when is onSubmit mode and re-validate on Submit', () => {
    expect(
      skipValidation(
        false,
        false,
        false,
        {
          isOnChange: false,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });

  it('when is onSubmit mode and not submitted yet', () => {
    expect(
      skipValidation(
        false,
        false,
        false,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });

  it('when on blur mode, not blur event and error gets clear', () => {
    expect(
      skipValidation(
        false,
        false,
        false,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: true,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });

  it('when re-validate mode is blur, not blur event and has error ', () => {
    expect(
      skipValidation(
        false,
        false,
        true,
        {
          isOnChange: true,
          isOnBlur: true,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });

  it('when is re-validate mode on submit and have error', () => {
    expect(
      skipValidation(
        false,
        false,
        true,
        {
          isOnChange: false,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnTouch: false,
        },
      ),
    ).toBeTruthy();
  });
});

describe('should validate the input', () => {
  it('when form is submitted and there is error', () => {
    expect(
      skipValidation(
        false,
        false,
        true,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnTouch: false,
        },
      ),
    ).toBeFalsy();
  });

  it('when mode is under all', () => {
    expect(
      skipValidation(
        false,
        false,
        false,
        {
          isOnChange: false,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: false,
          isOnAll: true,
        },
      ),
    ).toBeFalsy();
  });

  it('when user blur input and there is no more error', () => {
    expect(
      skipValidation(
        true,
        false,
        false,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: true,
          isOnTouch: false,
        },
      ),
    ).toBeFalsy();
  });

  it('when user blur and there is an error', () => {
    expect(
      skipValidation(
        true,
        false,
        false,
        {
          isOnChange: true,
          isOnBlur: false,
        },
        {
          isOnChange: false,
          isOnBlur: true,
          isOnTouch: false,
        },
      ),
    ).toBeFalsy();
  });
});


================================================
File: /src/__tests__/logic/getRuleValue.test.ts
================================================
import getRuleValue from '../../logic/getRuleValue';

describe('getRuleValue', () => {
  it('should return associated rule value', () => {
    expect(getRuleValue('1990/09/09')).toEqual('1990/09/09');
    expect(getRuleValue('2')).toEqual('2');
    expect(getRuleValue(2)).toEqual(2);

    expect(getRuleValue(/test/)).toEqual('test');

    expect(getRuleValue({ value: '2', message: 'data' })).toEqual('2');
    expect(getRuleValue({ value: '1990/09/09', message: 'data' })).toEqual(
      '1990/09/09',
    );
    expect(getRuleValue({ value: 2, message: 'data' })).toEqual(2);
    expect(getRuleValue({ value: /test/, message: 'data' })).toEqual('test');
  });

  it('should return undefined when no value is set', () => {
    expect(getRuleValue(undefined)).toBeUndefined();
  });
});


================================================
File: /src/__tests__/logic/getDirtyFields.test.ts
================================================
import getDirtyFields from '../../logic/getDirtyFields';

describe('getDirtyFields', () => {
  it('should return all the dirty fields', () => {
    expect(
      getDirtyFields(
        {},
        {
          test: {
            test1: 'bill',
            test2: 'luo',
          },
          test1: ['1', '2', '3'],
          test2: [
            {
              test1: 'bill',
              test2: 'luo',
            },
          ],
        },
      ),
    ).toEqual({
      test: {
        test1: true,
        test2: true,
      },
      test1: [true, true, true],
      test2: [
        {
          test1: true,
          test2: true,
        },
      ],
    });

    expect(
      getDirtyFields(
        {
          test: {
            test1: '',
            test2: 'luo',
          },
          test1: ['1'],
          test2: [
            {
              test1: 'bill',
              test2: '',
            },
          ],
        },
        {
          test: {
            test1: 'bill',
            test2: 'luo',
          },
          test1: ['1', '2', '3'],
          test2: [
            {
              test1: 'bill',
              test2: 'luo',
            },
          ],
        },
      ),
    ).toEqual({
      test: {
        test1: true,
        test2: false,
      },
      test1: [false, true, true],
      test2: [
        {
          test1: false,
          test2: true,
        },
      ],
    });
  });

  it('should set correctly dirty', () => {
    expect(
      getDirtyFields(
        {
          test: [{ data: 'bill' }, { data: 'luo', data1: 'luo1' }],
        },
        {
          test: [{ data: 'bill1' }, { data: 'luo2' }],
        },
      ),
    ).toEqual({
      test: [
        {
          data: true,
        },
        {
          data: true,
          data1: true,
        },
      ],
    });
  });

  it('should not set dirtyFields fields for nested input data which are deep equal', () => {
    expect(
      getDirtyFields(
        { test: [{ data: 'luo', data1: 'luo1' }] },
        { test: [{ data: 'luo', data1: 'luo1' }] },
      ),
    ).toEqual({ test: [{ data: false, data1: false }] });
  });

  it('should unset dirtyFields fields when value matches', () => {
    expect(
      getDirtyFields(
        { test: [{ data: 'bill' }, { data: 'luo2', data1: 'luo1' }] },
        { test: [{ data: 'bill1' }, { data: 'luo2' }] },
      ),
    ).toEqual({ test: [{ data: true }, { data: false, data1: true }] });
  });

  it('should works in reverse dirtyFields fields check', () => {
    expect(
      getDirtyFields(
        { test: [{ data: 'bill1' }, { data: 'luo2' }] },
        { test: [{ data: 'bill' }, { data: 'luo', data1: 'luo1' }] },
      ),
    ).toEqual({ test: [{ data: true }, { data: true, data1: true }] });

    expect(
      getDirtyFields(
        { test: [{ data: 'bill1' }, { data: 'luo2' }] },
        { test: [{ data: 'bill' }, { data: 'luo2', data1: 'luo1' }] },
      ),
    ).toEqual({ test: [{ data: true }, { data: false, data1: true }] });
  });

  it('should work for empty values compare with defaultValues', () => {
    expect(
      getDirtyFields(
        { test: [] },
        { test: [{ data: 'bill' }, { data: 'luo2', data1: 'luo1' }] },
      ),
    ).toEqual({
      test: [
        {
          data: true,
        },
        {
          data: true,
          data1: true,
        },
      ],
    });
  });

  it('should set correctly with nested dirty', () => {
    expect(
      getDirtyFields(
        {
          test: [
            { data: 'bill' },
            {
              data: 'luo',
              data1: 'luo1',
              nested: [{ data: 'luo', data1: 'luo1' }],
              nested1: [{ data: 'luo', data1: 'luo1' }],
            },
          ],
        },
        { test: [{ data: 'bill1' }, { data: 'luo2' }] },
      ),
    ).toEqual({
      test: [
        {
          data: true,
        },
        {
          data: true,
          data1: true,
          nested: [{ data: true, data1: true }],
          nested1: [{ data: true, data1: true }],
        },
      ],
    });
  });

  it('should keep nested dirtyFields fields when value matches', () => {
    expect(
      getDirtyFields(
        {
          test: [
            { data: 'bill' },
            {
              data: 'luo',
              data1: 'luo1',
              nested: [{ data: 'luo', data1: 'luo1' }],
              nested1: [{ data: 'luo', data1: 'luo1' }],
            },
          ],
        },
        {
          test: [
            { data: 'bill1' },
            {
              data: 'luo2',
              data1: 'luo1',
              nested: [{ data: 'luo', data1: 'luo1' }],
            },
          ],
        },
      ),
    ).toEqual({
      test: [
        {
          data: true,
        },
        {
          data: true,
          data1: false,
          nested: [{ data: false, data1: false }],
          nested1: [{ data: true, data1: true }],
        },
      ],
    });
  });

  it('should reset dirtyFields fields', () => {
    expect(
      getDirtyFields(
        { test: [{ data: 'bill' }] },
        { test: [{ data: 'bill' }] },
      ),
    ).toEqual({ test: [{ data: false }] });
  });

  it('should reset dirtyFields fields', () => {
    expect(
      getDirtyFields(
        {
          test: [
            {
              test1: 'test',
              test: [
                {
                  test: 'test1',
                },
              ],
            },
          ],
        },
        {
          test: [
            {
              test1: 'test1',
              test: null,
            },

            {
              test1: 'test',
              test: [
                {
                  test: 'test1',
                },
              ],
            },
          ],
        },
      ),
    ).toEqual({
      test: [
        {
          test: [
            {
              test: true,
            },
          ],
          test1: true,
        },
        {
          test: [
            {
              test: true,
            },
          ],
          test1: true,
        },
      ],
    });
  });

  it('should work out with different data type', () => {
    expect(
      getDirtyFields(
        {
          test: [
            {
              test1: 'test',
              test: [
                {
                  test: 'test1',
                },
              ],
            },
          ],
        },
        {
          test: [
            {
              test1: 'test1',
              test: true,
            },
            {
              test1: 'test',
              test: [
                {
                  test: 'test1',
                },
              ],
            },
          ],
        },
      ),
    ).toEqual({
      test: [
        {
          test: [
            {
              test: true,
            },
          ],
          test1: true,
        },
        {
          test: [
            {
              test: true,
            },
          ],
          test1: true,
        },
      ],
    });
  });
});


================================================
File: /src/__tests__/logic/generateId.test.ts
================================================
import generateId from '../../logic/generateId';

describe('generateId', () => {
  it('should generate a unique id', () => {
    expect(/\w{8}-\w{4}-4\w{3}-\w{4}-\w{12}/i.test(generateId())).toBeTruthy();
  });

  it('should fallback to current date if performance is undefined', () => {
    Object.defineProperty(window, 'performance', {
      value: undefined,
    });

    expect(/\w{8}-\w{4}-4\w{3}-\w{4}-\w{12}/i.test(generateId())).toBeTruthy();
  });
});


================================================
File: /src/__tests__/logic/getCheckboxValue.test.ts
================================================
import getCheckboxValue from '../../logic/getCheckboxValue';

describe('getCheckboxValue', () => {
  it('should return default value if not valid or empty options', () => {
    expect(getCheckboxValue(undefined)).toEqual({
      value: false,
      isValid: false,
    });
  });

  it('should return checked value if single checkbox is checked', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
      ]),
    ).toEqual({ value: '3', isValid: true });
  });

  it('should return true if single checkbox is checked and has no value', () => {
    expect(
      // @ts-expect-error this is a mock for html input
      getCheckboxValue([{ name: 'bill', checked: true, attributes: {} }]),
    ).toEqual({ value: true, isValid: true });
  });

  it('should return true if single checkbox is checked and has empty value', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '',
          // @ts-expect-error this is a mock for html input
          attributes: { value: 'test' },
        },
      ]),
    ).toEqual({ value: true, isValid: true });
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          // @ts-expect-error this is a mock for html input
          attributes: { value: 'test' },
        },
      ]),
    ).toEqual({ value: true, isValid: true });
  });

  it('should return false if single checkbox is un-checked', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: false,
          // @ts-expect-error this is a mock for html input
          attributes: {},
        },
      ]),
    ).toEqual({ value: false, isValid: false });
  });

  it('should return multiple selected values', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '2',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
        {
          name: 'bill',
          checked: true,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
      ]),
    ).toEqual({ value: ['2', '3'], isValid: true });
  });

  it('should return values for checked boxes only', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: false,
          value: '2',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
        {
          name: 'bill',
          checked: true,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
        {
          name: 'bill',
          checked: false,
          value: '4',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '4' },
        },
      ]),
    ).toEqual({ value: ['3'], isValid: true });
  });

  it('should return empty array for multi checkbox with no checked box', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: false,
          value: '2',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
        {
          name: 'bill',
          checked: false,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
      ]),
    ).toEqual({ value: [], isValid: false });
  });

  it('should not return error when check box ref is undefined', () => {
    expect(
      getCheckboxValue([
        // @ts-expect-error this is a mock for html input
        undefined,
        {
          name: 'bill',
          checked: false,
          value: '2',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
      ]),
    ).toEqual({ value: [], isValid: false });
  });

  it('should return disabled input result', () => {
    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '2',
          disabled: true,
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
        {
          name: 'bill',
          checked: true,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
      ]),
    ).toEqual({
      value: ['3'],
      isValid: true,
    });

    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '2',
          disabled: true,
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
        {
          name: 'bill',
          disabled: true,
          checked: true,
          value: '3',
          // @ts-expect-error this is a mock for html input
          attributes: { value: '3' },
        },
      ]),
    ).toEqual({
      value: [],
      isValid: false,
    });

    expect(
      getCheckboxValue([
        {
          name: 'bill',
          checked: true,
          value: '2',
          disabled: true,
          // @ts-expect-error this is a mock for html input
          attributes: { value: '2' },
        },
      ]),
    ).toEqual({
      value: false,
      isValid: false,
    });
  });
});


================================================
File: /src/__tests__/logic/getResolverOptions.test.ts
================================================
import { InternalFieldName } from '../..';
import getResolverOptions from '../../logic/getResolverOptions';

describe('getFielfs', () => {
  it('should return fields from `fieldsNames` and `fieldsRef`', () => {
    const fieldNames: Set<InternalFieldName> = new Set(['test.sub', 'test1']);
    const fieldsRef: any = {
      test: {
        sub: {
          _f: {
            ref: { name: 'test.sub', value: 'test' },
            name: 'test.sub',
            value: 'test',
          },
        },
      },
      test1: {
        _f: {
          ref: { name: 'test1', value: 'test1' },
          name: 'test1',
          value: 'test1',
        },
      },
    };

    expect(getResolverOptions(fieldNames, fieldsRef, undefined, true))
      .toMatchInlineSnapshot(`
      {
        "criteriaMode": undefined,
        "fields": {
          "test": {
            "sub": {
              "name": "test.sub",
              "ref": {
                "name": "test.sub",
                "value": "test",
              },
              "value": "test",
            },
          },
          "test1": {
            "name": "test1",
            "ref": {
              "name": "test1",
              "value": "test1",
            },
            "value": "test1",
          },
        },
        "names": [
          "test.sub",
          "test1",
        ],
        "shouldUseNativeValidation": true,
      }
    `);
  });
});


================================================
File: /src/__tests__/logic/iterateFieldsByAction.test.ts
================================================
import iterateFieldsByAction from '../../logic/iterateFieldsByAction';

describe('iterateFieldsByAction', () => {
  it('should focus on the first error it encounter', () => {
    const focus = jest.fn();
    iterateFieldsByAction(
      {
        test: {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
              focus,
            },
          },
        },
      },
      (ref) => {
        ref.focus && ref.focus();
        return 1;
      },
    );

    expect(focus).toBeCalled();
  });

  it('should focus on first option when options input error encounters', () => {
    const focus = jest.fn();
    iterateFieldsByAction(
      {
        test: {
          _f: {
            name: 'test',
            ref: {
              name: 'test',
            },
            refs: [
              {
                focus,
              } as unknown as HTMLInputElement,
            ],
          },
        },
      },
      (ref) => {
        ref.focus && ref.focus();
        return 1;
      },
    );

    expect(focus).toBeCalled();
  });

  it('should not call focus when field is undefined', () => {
    expect(() => {
      iterateFieldsByAction(
        {
          test: undefined,
        },
        (ref) => {
          ref.focus && ref.focus();
          return 1;
        },
      );
    }).not.toThrow();
  });

  it('should focus on the first error it encounter and not the second', () => {
    const focus = jest.fn();
    iterateFieldsByAction(
      {
        first: {
          _f: {
            name: 'first',
            ref: {
              name: 'first',
              focus,
            },
          },
        },
        second: {
          _f: {
            name: 'second',
            ref: {
              name: 'second',
              focus,
            },
          },
        },
      },
      (ref) => {
        // @ts-expect-error we want to test with what focus was called
        ref.focus && ref.focus(ref.name);
        return 1;
      },
    );
    expect(focus).toBeCalledWith('first');
    expect(focus).not.toBeCalledWith('second');
  });

  it('should recursively drill into objects', () => {
    const focus = jest.fn();
    iterateFieldsByAction(
      {
        test: {
          name: {
            first: {
              _f: {
                name: 'name.first',
                ref: {
                  name: 'first',
                  focus,
                },
              },
            },
            last: {
              _f: {
                name: 'name.last',
                ref: {
                  name: 'last',
                  focus,
                },
              },
            },
          },
        },
      },
      (ref, key) => {
        if (key === 'name.last') {
          // @ts-expect-error we want to test with what focus was called
          ref.focus && ref.focus(ref.name);
          return 1;
        }
        return;
      },
    );
    expect(focus).not.toBeCalledWith('first');
    expect(focus).toBeCalledWith('last');
  });

  it('should should recursively drill into objects and break out of all loops on first focus', () => {
    const focus = jest.fn();
    const notFocus = jest.fn();
    iterateFieldsByAction(
      {
        personal: {
          name: {
            first: {
              _f: {
                name: 'name.first',
                ref: {
                  name: 'first',
                  focus: notFocus,
                },
              },
            },
            last: {
              _f: {
                name: 'name.last',
                ref: {
                  name: 'last',
                  focus,
                },
              },
            },
          },
          phone: {
            _f: {
              name: 'phone',
              ref: {
                name: 'phone',
                focus: notFocus,
              },
            },
          },
          address: {
            line1: {
              _f: {
                name: 'address.line1',
                ref: {
                  name: 'line1',
                  focus: notFocus,
                },
              },
            },
          },
        },
      },
      (ref, key) => {
        // @ts-expect-error we want to test with what focus was called
        ref.focus && ref.focus(ref.name);
        return key === 'name.last' ? 1 : undefined;
      },
    );
    // 'focus' should be called on 'last' and never again
    expect(focus).not.toBeCalledWith('first'); // not valid
    expect(focus).toBeCalledWith('last'); // valid
    expect(focus).not.toBeCalledWith('phone'); // stopped
    expect(focus).not.toBeCalledWith('line1');
    // 'notFocus' should be called on the first, then never again
    expect(notFocus).toBeCalledWith('first'); // not valid
    expect(notFocus).not.toBeCalledWith('last'); // valid
    expect(notFocus).not.toBeCalledWith('phone'); // stopped
    expect(notFocus).not.toBeCalledWith('line1');
  });
});


================================================
File: /src/__tests__/logic/shouldSubscribeByName.test.ts
================================================
import shouldSubscribeByName from '../../logic/shouldSubscribeByName';

describe('shouldSubscribeByName', () => {
  it('should return correct response for subscription name coverage', () => {
    expect(shouldSubscribeByName(undefined, 'test')).toBeTruthy();
    expect(shouldSubscribeByName('test', undefined)).toBeTruthy();
    expect(shouldSubscribeByName(['test'], undefined)).toBeTruthy();
    expect(shouldSubscribeByName(['test'], 'test')).toBeTruthy();
    expect(shouldSubscribeByName(['tes'], 'test')).toBeTruthy();
    expect(shouldSubscribeByName(['test1'], 'test')).toBeTruthy();
    expect(shouldSubscribeByName('test1', 'test')).toBeTruthy();
    expect(shouldSubscribeByName('tes', 'test')).toBeTruthy();

    expect(shouldSubscribeByName('testXXX', 'data')).toBeFalsy();
    expect(shouldSubscribeByName(['testXXX'], 'data')).toBeFalsy();
  });
});


================================================
File: /src/__tests__/logic/getFieldValueAs.test.ts
================================================
import getFieldValueAs from '../../logic/getFieldValueAs';

describe('getFieldValueAs', () => {
  it('should return undefined when value is undefined', () => {
    expect(
      getFieldValueAs(undefined, {
        ref: {
          name: 'test',
        },
        name: 'test',
        valueAsNumber: true,
        valueAsDate: false,
      }),
    ).toBeUndefined();
  });
});


================================================
File: /src/__tests__/logic/hasPromiseValidation.test.ts
================================================
import hasPromiseValidation from '../../logic/hasPromiseValidation';

const commonParam = {
  mount: true,
  name: 'test1',
  ref: {
    name: 'test1',
    value: '',
  },
};

describe('hasPromiseValidation', () => {
  it('validate option does not exist', () => {
    expect(hasPromiseValidation(commonParam)).toEqual(false);
  });
  it('should return true when validate option has a function type value and is an async function', () => {
    const param = {
      ...commonParam,
      validate: async () => {
        return true;
      },
    };

    expect(hasPromiseValidation(param)).toEqual(true);
  });
  it('should return false when validate option has a function type value and is not an async function', () => {
    const param = {
      ...commonParam,
      validate: () => {
        return true;
      },
    };

    expect(hasPromiseValidation(param)).toEqual(false);
  });
  it('should return true when validate option has an object type value, and the values of all properties are async function.', () => {
    const param = {
      ...commonParam,
      validate: {
        positive: async (v: string) => parseInt(v) > 0,
        lessThanTen: async (v: string) => parseInt(v) < 10,
      },
    };

    expect(hasPromiseValidation(param)).toEqual(true);
  });
  it('should return true when validate option has an object type value, and the value of one property is an async function.', () => {
    const param = {
      ...commonParam,
      validate: {
        positive: (v: string) => parseInt(v) > 0,
        lessThanTen: async (v: string) => parseInt(v) < 10,
      },
    };

    expect(hasPromiseValidation(param)).toEqual(true);
  });
  it('should return false when validate option has an object type value, and the values of all properties are not async function.', () => {
    const param = {
      ...commonParam,
      validate: {
        positive: (v: string) => parseInt(v) > 0,
        lessThanTen: (v: string) => parseInt(v) < 10,
      },
    };

    expect(hasPromiseValidation(param)).toEqual(false);
  });
});


================================================
File: /src/__tests__/logic/getValueAndMessage.test.ts
================================================
import getValueAndMessage from '../../logic/getValueAndMessage';

describe('getValueAndMessage', () => {
  it('should return message and value correctly', () => {
    expect(getValueAndMessage(0).value).toEqual(0);
    expect(getValueAndMessage(3).value).toEqual(3);
    expect(getValueAndMessage({ value: 0, message: 'what' }).value).toEqual(0);
    expect(getValueAndMessage({ value: 2, message: 'what' }).value).toEqual(2);
    expect(getValueAndMessage({ value: 1, message: 'test' }).message).toEqual(
      'test',
    );
  });
});


================================================
File: /src/__tests__/logic/isNameInFieldArray.test.ts
================================================
import isNameInFieldArray from '../../logic/isNameInFieldArray';

describe('isNameInFieldArray', () => {
  it('should find match array field', () => {
    expect(isNameInFieldArray(new Set(['test']), 'test.0')).toBeTruthy();
    expect(isNameInFieldArray(new Set(['te']), 'test.0')).toBeFalsy();
    expect(isNameInFieldArray(new Set(['te']), 'test.0')).toBeFalsy();
    expect(isNameInFieldArray(new Set(['test1']), 'test[0]')).toBeFalsy();
    expect(isNameInFieldArray(new Set(['test1']), 'test.0')).toBeFalsy();
    expect(
      isNameInFieldArray(new Set(['test']), 'test.0.data[0]'),
    ).toBeTruthy();
    expect(isNameInFieldArray(new Set(['test']), 'test.0.data.0')).toBeTruthy();
    expect(isNameInFieldArray(new Set(['test']), 'test1.0.data.0')).toBeFalsy();
    expect(isNameInFieldArray(new Set(['test']), 'data.0.data.0')).toBeFalsy();
  });
});


================================================
File: /src/__tests__/logic/isWatched.test.ts
================================================
import isWatched from '../../logic/isWatched';

describe('isWatched', () => {
  it('should return watched fields', () => {
    expect(
      isWatched('', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(),
        focus: '',
        watchAll: true,
      }),
    ).toBeTruthy();

    expect(
      isWatched('test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();
  });

  it('should return true when watched with parent node', () => {
    expect(
      isWatched('test.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();

    expect(
      isWatched('test.test.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['test.test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();

    expect(
      isWatched('test.test.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['testFail.test', 'test.test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();

    expect(
      isWatched('test.0', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();

    expect(
      isWatched('test.0.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['test.0']),
        focus: '',
        watchAll: false,
      }),
    ).toBeTruthy();
  });

  it("should return false when watched with parent node that doesn't match child name", () => {
    expect(
      isWatched('test.test.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['tesk.test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeFalsy();

    expect(
      isWatched('test.test.test', {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(['testFail.test']),
        focus: '',
        watchAll: false,
      }),
    ).toBeFalsy();
  });

  it('should return falsy for blur event', () => {
    expect(
      isWatched(
        '',
        {
          mount: new Set(),
          unMount: new Set(),
          array: new Set(),
          watch: new Set(),
          focus: '',
          watchAll: true,
        },
        true,
      ),
    ).toBeFalsy();
  });
});


================================================
File: /src/__tests__/logic/getEventValue.test.ts
================================================
import getEventValue from '../../logic/getEventValue';

test('getEventValue should return correct value', () => {
  expect(
    getEventValue({
      target: { checked: true, type: 'checkbox' },
    }),
  ).toEqual(true);
  expect(
    getEventValue({
      target: { checked: true, type: 'checkbox', value: 'test' },
    }),
  ).toEqual(true);
  expect(getEventValue({ target: { value: 'test' }, type: 'test' })).toEqual(
    'test',
  );
  expect(getEventValue({ data: 'test' })).toEqual({ data: 'test' });
  expect(getEventValue('test')).toEqual('test');
  expect(getEventValue(undefined)).toEqual(undefined);
  expect(getEventValue(null)).toEqual(null);
});


================================================
File: /src/__tests__/logic/createFormControl.test.ts
================================================
import { createFormControl } from '../../logic/createFormControl';
import isEmptyObject from '../../utils/isEmptyObject';

jest.mock('../../utils/isEmptyObject', () => {
  const original = jest.requireActual('../../utils/isEmptyObject');
  return {
    __esModule: true,
    default: jest.fn(original.default),
  };
});

describe('createFormControl', () => {
  it('should call `executeBuiltInValidation` once for a single field', async () => {
    const { register, control } = createFormControl({
      defaultValues: {
        foo: 'foo',
      },
    });

    register('foo', {});

    await control._updateValid(true);

    expect(isEmptyObject).toHaveBeenCalledTimes(1);
  });

  it('should call `executeBuiltInValidation` twice for a field as an object with a single sub-field', async () => {
    const { register, control } = createFormControl({
      defaultValues: {
        foo: {
          bar: 'bar',
        },
      },
    });

    register('foo.bar', {});

    await control._updateValid(true);

    expect(isEmptyObject).toHaveBeenCalledTimes(2);
  });

  it('should call executeBuiltInValidation the correct number of times in case the field is an array', async () => {
    const { register, control } = createFormControl({
      defaultValues: {
        foo: [
          {
            bar: 'bar',
            baz: 'baz',
          },
          {
            bar: 'bar',
            baz: 'baz',
          },
        ],
      },
    });

    register('foo.1.bar', {});

    await control._updateValid(true);

    expect(isEmptyObject).toHaveBeenCalledTimes(3);
  });
});


================================================
File: /src/__tests__/controller.test.tsx
================================================
import React from 'react';
import {
  act as actComponent,
  fireEvent,
  render,
  screen,
  waitFor,
  waitForElementToBeRemoved,
} from '@testing-library/react';

import { Controller } from '../controller';
import { ControllerRenderProps, FieldValues, ValidateResult } from '../types';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { FormProvider } from '../useFormContext';
import { useWatch } from '../useWatch';
import noop from '../utils/noop';

function Input<TFieldValues extends FieldValues>({
  onChange,
  onBlur,
  placeholder,
}: Pick<ControllerRenderProps<TFieldValues>, 'onChange' | 'onBlur'> & {
  placeholder?: string;
}) {
  return (
    <input
      placeholder={placeholder}
      onChange={() => onChange(1)}
      onBlur={() => onBlur()}
    />
  );
}

describe('Controller', () => {
  it('should render correctly with as with string', () => {
    const Component = () => {
      const { control } = useForm();
      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox') as HTMLInputElement;

    expect(input).toBeVisible();
    expect(input.name).toBe('test');
  });

  it('should render correctly with as with component', () => {
    const Component = () => {
      const { control } = useForm();
      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox') as HTMLInputElement;

    expect(input).toBeVisible();
    expect(input?.name).toBe('test');
  });

  it('should reset value', async () => {
    const Component = () => {
      const { reset, control } = useForm();

      return (
        <>
          <Controller
            defaultValue="default"
            name="test"
            render={({ field }) => <input {...field} />}
            control={control}
          />
          <button
            type="button"
            onClick={() =>
              reset({
                test: 'default',
              })
            }
          >
            reset
          </button>
        </>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), { target: { value: 'test' } });
    expect(screen.getByRole('textbox')).toHaveValue('test');

    fireEvent.click(screen.getByRole('button', { name: /reset/i }));
    expect(screen.getByRole('textbox')).toHaveValue('default');
  });

  it('should set defaultValue to value props when input was reset', () => {
    const Component = () => {
      const { reset, control } = useForm<{
        test: string;
      }>();

      React.useEffect(() => {
        reset({ test: 'default' });
      }, [reset]);

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    expect(screen.getByRole('textbox')).toHaveValue('default');
  });

  it('should render when registered field values are updated', () => {
    const Component = () => {
      const { control } = useForm();
      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), { target: { value: 'test' } });

    expect(screen.getByRole('textbox')).toHaveValue('test');
  });

  it("should trigger component's onChange method and invoke setValue method", () => {
    let fieldValues: unknown;
    const Component = () => {
      const { control, getValues } = useForm();

      return (
        <>
          <Controller
            defaultValue=""
            name="test"
            render={({ field }) => <input {...field} />}
            control={control}
          />
          <button onClick={() => (fieldValues = getValues())}>getValues</button>
        </>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });

    fireEvent.click(screen.getByRole('button', { name: /getValues/ }));

    expect(fieldValues).toEqual({ test: 'test' });
  });

  it("should trigger component's onChange method and invoke trigger method", async () => {
    let errors: any;
    const Component = () => {
      const { control, ...rest } = useForm({ mode: 'onChange' });

      errors = rest.formState.errors;

      return (
        <Controller
          defaultValue="test"
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
          rules={{ required: true }}
        />
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), {
      target: { value: '' },
    });

    await waitFor(() => expect(errors.test).toBeDefined());
  });

  it("should trigger component's onBlur method and invoke trigger method", async () => {
    let errors: any;
    const Component = () => {
      const { control, ...rest } = useForm({ mode: 'onBlur' });

      errors = rest.formState.errors;

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
          rules={{ required: true }}
        />
      );
    };

    render(<Component />);

    fireEvent.blur(screen.getByRole('textbox'), {
      target: { value: '' },
    });

    await waitFor(() => expect(errors.test).toBeDefined());
  });

  it('should set field to formState.touchedFields', async () => {
    let touched: any;
    const Component = () => {
      const { control, formState } = useForm({ mode: 'onBlur' });

      touched = formState.touchedFields;

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    fireEvent.blur(screen.getByRole('textbox'));

    expect(touched).toEqual({ test: true });
  });

  it('should set field to formState validatingFields and render field isValidating state', async () => {
    jest.useFakeTimers();

    const getValidateMock: (timeout: number) => Promise<ValidateResult> = (
      timeout: number,
    ) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    };

    let validatingFields: any;
    const Component = () => {
      const { control, formState } = useForm({ mode: 'onBlur' });

      validatingFields = formState.validatingFields;

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field, fieldState }) => (
            <>
              <div>isValidating: {String(fieldState.isValidating)}</div>
              <input {...field} />
            </>
          )}
          control={control}
          rules={{
            validate: () => getValidateMock(1000),
          }}
        />
      );
    };

    render(<Component />);

    expect(validatingFields).toEqual({});
    expect(screen.getByText('isValidating: false')).toBeVisible();

    fireEvent.blur(screen.getByRole('textbox'));

    expect(validatingFields).toEqual({ test: true });
    expect(screen.getByText('isValidating: true')).toBeVisible();

    await actComponent(async () => {
      jest.advanceTimersByTime(1100);
    });

    expect(validatingFields).toEqual({});
    expect(screen.getByText('isValidating: false')).toBeVisible();
  });

  it('should call trigger method when re-validate mode is onBlur with blur event', async () => {
    const Component = () => {
      const {
        handleSubmit,
        control,
        formState: { errors },
      } = useForm({
        reValidateMode: 'onBlur',
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <Controller
            defaultValue=""
            name="test"
            render={({ field }) => <input {...field} />}
            control={control}
            rules={{ required: true }}
          />
          {errors.test && <span role="alert">required</span>}
          <button>submit</button>
        </form>
      );
    };
    render(<Component />);

    fireEvent.blur(screen.getByRole('textbox'), {
      target: {
        value: '',
      },
    });

    expect(screen.queryByRole('alert')).not.toBeInTheDocument();

    fireEvent.submit(screen.getByRole('button'));

    fireEvent.input(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByRole('alert')).toBeVisible();

    fireEvent.blur(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    await waitForElementToBeRemoved(screen.queryByRole('alert'));
  });

  it('should invoke custom event named method', () => {
    let fieldValues: any;
    const Component = () => {
      const { control, getValues } = useForm();
      return (
        <>
          <Controller
            defaultValue=""
            name="test"
            render={({ field: props }) => {
              return <input {...props} />;
            }}
            control={control}
          />
          <button onClick={() => (fieldValues = getValues())}>getValues</button>
        </>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.click(screen.getByRole('button', { name: /getValues/ }));

    expect(fieldValues).toEqual({ test: 'test' });
  });

  it('should invoke custom onChange method', () => {
    const onChange = jest.fn();
    const Component = () => {
      const { control } = useForm<{
        test: string;
      }>();
      return (
        <>
          <Controller
            defaultValue=""
            name="test"
            render={({ field: { onBlur, value } }) => {
              return (
                <Input placeholder="test" {...{ onChange, onBlur, value }} />
              );
            }}
            control={control}
          />
        </>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    expect(onChange).toBeCalled();
  });

  it('should invoke custom onBlur method', () => {
    const onBlur = jest.fn();
    const Component = () => {
      const { control } = useForm();
      return (
        <>
          <Controller
            defaultValue=""
            name="test"
            render={({ field: { onChange, value } }) => {
              return <Input {...{ onChange, onBlur, value }} />;
            }}
            control={control}
          />
        </>
      );
    };

    render(<Component />);

    fireEvent.blur(screen.getByRole('textbox'));

    expect(onBlur).toBeCalled();
  });

  it('should update rules when rules gets updated', () => {
    let fieldsRef: any;
    const Component = ({ required = true }: { required?: boolean }) => {
      const { control } = useForm();
      fieldsRef = control._fields;
      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          rules={{ required }}
          control={control}
        />
      );
    };
    const { rerender } = render(<Component />);

    rerender(<Component required={false} />);

    expect(fieldsRef.test.required).toBeFalsy();
  });

  it('should set initial state from unmount state', () => {
    const Component = ({ isHide }: { isHide?: boolean }) => {
      const { control } = useForm();
      return isHide ? null : (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    const { rerender } = render(<Component />);

    fireEvent.input(screen.getByRole('textbox'), { target: { value: 'test' } });

    rerender(<Component isHide />);

    expect(screen.queryByRole('textbox')).not.toBeInTheDocument();

    rerender(<Component />);

    expect(screen.getByRole('textbox')).toHaveValue('test');
  });

  it('should skip validation when Controller is unmounted', async () => {
    const onValid = jest.fn();
    const onInvalid = jest.fn();

    const App = () => {
      const [show, setShow] = React.useState(true);
      const { control, handleSubmit } = useForm();

      return (
        <form onSubmit={handleSubmit(onValid, onInvalid)}>
          {show && (
            <Controller
              render={({ field }) => <input {...field} />}
              name={'test'}
              rules={{
                required: true,
              }}
              control={control}
            />
          )}
          <button type={'button'} onClick={() => setShow(false)}>
            toggle
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() => expect(onInvalid).toBeCalledTimes(1));
    expect(onValid).toBeCalledTimes(0);

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() => expect(onValid).toBeCalledTimes(1));
    expect(onInvalid).toBeCalledTimes(1);
  });

  it('should not set initial state from unmount state when input is part of field array', () => {
    const Component = () => {
      const { control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, append, remove } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <form>
          {fields.map((field, i) => (
            <Controller
              key={field.id}
              defaultValue={field.value}
              name={`test.${i}.value` as const}
              render={({ field }) => <input {...field} />}
              control={control}
            />
          ))}
          <button type="button" onClick={() => append({ value: 'test' })}>
            append
          </button>
          <button type="button" onClick={() => remove(0)}>
            remove
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.input(screen.getByRole('textbox'), { target: { value: 'test' } });

    fireEvent.click(screen.getByRole('button', { name: /remove/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(screen.getByRole('textbox')).toHaveValue('test');
  });

  it('should not assign default value when field is removed with useFieldArray', () => {
    const Component = () => {
      const { control } = useForm();
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form>
          {fields.map((field, i) => (
            <div key={field.id}>
              <Controller
                render={({ field }) => <input {...field} />}
                name={`test.${i}.value`}
                defaultValue={''}
                control={control}
              />
              <button type="button" onClick={() => remove(i)}>
                remove{i}
              </button>
            </div>
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.input(inputs[0], {
      target: { value: '1' },
    });

    fireEvent.input(inputs[1], {
      target: { value: '2' },
    });

    fireEvent.input(inputs[2], {
      target: { value: '3' },
    });

    fireEvent.click(screen.getByRole('button', { name: /remove1/i }));

    expect(screen.getAllByRole('textbox')[0]).toHaveValue('1');
    expect(screen.getAllByRole('textbox')[1]).toHaveValue('3');
  });

  it('should validate input when input is touched and with onTouched mode', async () => {
    let currentErrors: any = {};
    const Component = () => {
      const {
        formState: { errors },
        control,
      } = useForm<{ test: string }>({
        mode: 'onTouched',
      });

      currentErrors = errors;

      return (
        <form>
          <Controller
            name={'test'}
            control={control}
            defaultValue=""
            rules={{ required: true }}
            render={({ field }) => <input {...field} />}
          />
        </form>
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox');

    fireEvent.blur(input);

    await waitFor(() => expect(currentErrors.test).not.toBeUndefined());

    fireEvent.input(input, {
      target: { value: '1' },
    });

    await waitFor(() => expect(currentErrors.test).toBeUndefined());
  });

  it('should show invalid input when there is an error', async () => {
    const Component = () => {
      const { control } = useForm({
        mode: 'onChange',
      });

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field: props, fieldState }) => (
            <>
              <input {...props} />
              {fieldState.invalid && <p>Input is invalid.</p>}
            </>
          )}
          control={control}
          rules={{
            required: true,
          }}
        />
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    expect(screen.queryByText('Input is invalid.')).not.toBeInTheDocument();

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '',
      },
    });

    expect(await screen.findByText('Input is invalid.')).toBeVisible();
  });

  it('should show input has been touched.', async () => {
    const Component = () => {
      const { control } = useForm();

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field: props, fieldState }) => (
            <>
              <input {...props} />
              {fieldState.isTouched && <p>Input is touched.</p>}
            </>
          )}
          control={control}
          rules={{
            required: true,
          }}
        />
      );
    };

    render(<Component />);

    expect(screen.queryByText('Input is touched.')).not.toBeInTheDocument();

    fireEvent.blur(screen.getByRole('textbox'));

    expect(await screen.findByText('Input is touched.')).toBeVisible();
  });

  it('should show input is dirty.', async () => {
    const Component = () => {
      const { control } = useForm();

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field: props, fieldState }) => (
            <>
              <input {...props} />
              {fieldState.isDirty && <p>Input is dirty.</p>}
            </>
          )}
          control={control}
          rules={{
            required: true,
          }}
        />
      );
    };

    render(<Component />);

    expect(screen.queryByText('Input is dirty.')).not.toBeInTheDocument();

    const input = screen.getByRole('textbox');

    fireEvent.change(input, { target: { value: 'dirty' } });

    expect(await screen.findByText('Input is dirty.')).toBeVisible();
  });

  it('should display input error.', async () => {
    const Component = () => {
      const { control } = useForm({
        mode: 'onChange',
      });

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field: props, fieldState }) => (
            <>
              <input {...props} />
              {fieldState.error && <p>{fieldState.error.message}</p>}
            </>
          )}
          control={control}
          rules={{
            required: 'This is required',
          }}
        />
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox');

    fireEvent.change(input, { target: { value: 'q' } });
    fireEvent.change(input, { target: { value: '' } });

    expect(await screen.findByText('This is required')).toBeVisible();
  });

  it('should not trigger extra-render while not subscribed to any input state', () => {
    let count = 0;

    const Component = () => {
      const { control } = useForm();
      count++;

      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field: props, fieldState }) => (
            <>
              <input {...props} />
              {fieldState.isTouched && <p>Input is dirty.</p>}
            </>
          )}
          control={control}
          rules={{
            required: true,
          }}
        />
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    expect(count).toEqual(1);
  });

  it('should update Controller value with setValue', () => {
    const Component = () => {
      const { control, setValue } = useForm<{
        test: string;
      }>();

      React.useEffect(() => {
        setValue('test', 'data');
      }, [setValue]);

      return (
        <Controller
          name={'test'}
          control={control}
          render={({ field }) => <input {...field} />}
          defaultValue=""
        />
      );
    };

    render(<Component />);

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'data',
    );
  });

  it('should retain default value or defaultValues at Controller', () => {
    let getValuesMethod = noop;
    const Component = () => {
      const { control, getValues } = useForm<{
        test: number;
        test1: number;
      }>({
        defaultValues: {
          test: 2,
        },
      });

      getValuesMethod = getValues;

      return (
        <>
          <Controller
            render={({ field }) => <input {...field} />}
            name={'test'}
            control={control}
          />
          <Controller
            render={({ field }) => <input {...field} />}
            name={'test1'}
            defaultValue={1}
            control={control}
          />
        </>
      );
    };

    render(<Component />);

    expect(getValuesMethod()).toEqual({
      test: 2,
      test1: 1,
    });
  });

  it('should return correct isValid formState when input ref is not registered', async () => {
    const Component = () => {
      const {
        control,
        formState: { isValid },
      } = useForm<{
        test: string;
        test1: string;
      }>({
        mode: 'onChange',
        defaultValues: {
          test: '2',
          test1: '2',
        },
      });

      return (
        <>
          <Controller
            render={({ field }) => (
              <input value={field.value} onChange={field.onChange} />
            )}
            rules={{ required: true }}
            name={'test'}
            control={control}
          />
          <Controller
            render={({ field }) => (
              <input value={field.value} onChange={field.onChange} />
            )}
            rules={{ required: true }}
            name={'test1'}
            control={control}
          />
          {isValid ? 'true' : 'false'}
        </>
      );
    };

    render(<Component />);

    expect(screen.getByText('false')).toBeVisible();

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: '',
      },
    });

    expect(await screen.findByText('false')).toBeVisible();

    fireEvent.input(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByText('true')).toBeVisible();
  });

  it('should subscribe the correct dirty fields', () => {
    type FormValues = {
      test: string;
    };

    const Component = () => {
      const {
        control,
        formState: { dirtyFields, isDirty },
      } = useForm<FormValues>({
        defaultValues: {
          test: '',
        },
      });

      return (
        <>
          <Controller
            control={control}
            name={'test'}
            render={({ field }) => <input {...field} />}
          />
          <p>{JSON.stringify(dirtyFields)}</p>
          <p>{isDirty ? 'true' : 'false'}</p>
        </>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), { target: { value: '1' } });

    expect(screen.getByText('{"test":true}')).toBeVisible();
    expect(screen.getByText('true')).toBeVisible();

    fireEvent.change(screen.getByRole('textbox'), { target: { value: '' } });

    expect(screen.getByText('{}')).toBeVisible();
    expect(screen.getByText('false')).toBeVisible();
  });

  it('should remove input value and reference with Controller and set shouldUnregister: true', () => {
    type FormValue = {
      test: string;
    };
    const watchedValue: FormValue[] = [];
    const Component = () => {
      const { control, watch } = useForm<FormValue>({
        defaultValues: {
          test: 'bill',
        },
      });
      const [show, setShow] = React.useState(true);
      watchedValue.push(watch());

      return (
        <>
          {show && (
            <Controller
              control={control}
              name={'test'}
              shouldUnregister
              render={({ field }) => <input {...field} />}
            />
          )}
          <button onClick={() => setShow(false)}>hide</button>
        </>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    expect(watchedValue).toEqual([
      {
        test: 'bill',
      },
      {
        test: 'bill',
      },
      {},
    ]);
  });

  it('should set ref to empty object when ref is not defined', async () => {
    const App = () => {
      const [show, setShow] = React.useState(false);
      const { control } = useForm({
        mode: 'onChange',
        defaultValues: {
          test: '',
        },
      });

      return (
        <div>
          {show && (
            <Controller
              name={'test'}
              rules={{ required: true }}
              control={control}
              render={({ field }) => (
                <input value={field.value} onChange={field.onChange} />
              )}
            />
          )}
          <button onClick={() => setShow(!show)}>setShow</button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    const input = screen.getByRole('textbox');

    fireEvent.change(input, {
      target: { value: 'test' },
    });

    // Everything should be fine even if no ref on the controlled input
    await waitFor(() => expect(input).toHaveValue('test'));
  });

  it('should transform input value instead update via ref', () => {
    type FormValues = {
      test: number;
    };

    const transform = {
      input: (x: number) => x / 10,
    };

    function App() {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: 7200,
        },
      });

      return (
        <Controller
          name="test"
          control={control}
          render={({ field }) => (
            <input
              type="number"
              {...field}
              value={transform.input(+field.value)}
              placeholder="test"
            />
          )}
        />
      );
    }

    render(<App />);

    expect(
      (screen.getByPlaceholderText('test') as HTMLInputElement).value,
    ).toEqual('720');
  });

  it('should mark mounted inputs correctly within field array', async () => {
    const App = () => {
      const {
        control,
        handleSubmit,
        formState: { errors },
      } = useForm({
        defaultValues: {
          test: [{ firstName: 'test' }],
        },
      });
      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, index) => {
            return (
              <div key={field.id}>
                <Controller
                  control={control}
                  render={({ field }) => <input {...field} />}
                  name={`test.${index}.firstName`}
                  rules={{ required: true }}
                />
                {errors?.test?.[index]?.firstName && <p>error</p>}
              </div>
            );
          })}
          <button
            type="button"
            onClick={() =>
              prepend({
                firstName: '',
              })
            }
          >
            prepend
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(await screen.findByText('error')).toBeVisible();
  });

  it('should not throw type error with field state', () => {
    type FormValues = {
      firstName: string;
      deepNested: {
        test: string;
      };
      todos: string[];
      nestedValue: { test: string };
    };

    function App() {
      const { control } = useForm<FormValues>({
        defaultValues: {
          firstName: '',
          deepNested: { test: '' },
          todos: [],
          nestedValue: { test: '' },
        },
      });

      return (
        <form>
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="firstName"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="deepNested.test"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="todos"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...{ ...field, value: field.value.test }} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="nestedValue"
          />
        </form>
      );
    }

    render(<App />);

    expect(screen.getAllByRole('textbox').length).toEqual(4);
  });

  it('should not cause type error with any', () => {
    function App() {
      const { control } = useForm({
        defaultValues: {
          firstName: '',
          deepNested: { test: '' },
          todos: [],
          nestedValue: { test: '' },
        },
      });

      return (
        <form>
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="firstName"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="deepNested.test"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="todos"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...{ ...field, value: field.value.test }} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="nestedValue"
          />
        </form>
      );
    }

    render(<App />);

    expect(screen.getAllByRole('textbox').length).toEqual(4);
  });

  it('should not cause type error without generic type', () => {
    function App() {
      const { control } = useForm({
        defaultValues: {
          firstName: '',
          deepNested: { test: '' },
          todos: [],
          nestedValue: { test: '' },
        },
      });

      return (
        <form>
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="firstName"
          />
          <Controller
            render={({ field, fieldState }) => (
              <>
                <input {...field} />
                <p>{fieldState.error?.message}</p>
              </>
            )}
            control={control}
            name="deepNested.test"
          />
          <Controller
            render={({ field }) => (
              <>
                <input {...field} />
              </>
            )}
            control={control}
            name="todos"
          />
          <Controller
            render={({ field }) => (
              <>
                <input {...{ ...field, value: field.value.test }} />
              </>
            )}
            control={control}
            name="nestedValue"
          />
        </form>
      );
    }

    render(<App />);

    expect(screen.getAllByRole('textbox').length).toEqual(4);
  });

  it('should unregister component within field array when field is unmounted', () => {
    const getValueFn = jest.fn();

    const Child = () => {
      const { fields } = useFieldArray({
        name: 'names',
      });
      const show = useWatch({ name: 'show' });

      return (
        <>
          <Controller
            name={'show'}
            render={({ field }) => (
              <input
                {...field}
                checked={field.value}
                type="checkbox"
                data-testid="checkbox"
              />
            )}
          />

          {fields.map((field, i) => (
            <div key={field.id}>
              {show && (
                <Controller
                  shouldUnregister
                  name={`names.${i}.firstName`}
                  render={({ field }) => <input {...field} />}
                />
              )}
            </div>
          ))}
        </>
      );
    };

    function App() {
      const methods = useForm({
        defaultValues: { show: true, names: [{ firstName: '' }] },
      });

      return (
        <FormProvider {...methods}>
          <Child />
          <button
            onClick={() => {
              getValueFn(methods.getValues());
            }}
          >
            getValues
          </button>
        </FormProvider>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(getValueFn).toBeCalledWith({
      names: [{ firstName: '' }],
      show: true,
    });

    fireEvent.click(screen.getByTestId('checkbox'));
    fireEvent.click(screen.getByRole('button'));

    expect(getValueFn).toBeCalledWith({
      show: false,
    });
  });

  it('should set up defaultValues for controlled component with values prop', () => {
    function App() {
      const { control } = useForm({
        values: {
          firstName: 'test',
        },
      });

      return (
        <Controller
          render={({ field }) => <input {...field} />}
          control={control}
          name="firstName"
        />
      );
    }

    render(<App />);

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );
  });

  it('should re-render on change with single value array', async () => {
    function App() {
      const { control, handleSubmit } = useForm<{ numbers: number[] }>();

      return (
        <form onSubmit={handleSubmit(noop)}>
          <Controller
            control={control}
            name="numbers"
            rules={{
              required: 'required',
              validate: () => {
                return 'custom';
              },
            }}
            render={({ field, fieldState }) => (
              <>
                <button type="button" onClick={() => field.onChange([1])}>
                  [1]
                </button>
                <p data-testid="error">{fieldState.error?.message}</p>
              </>
            )}
          />
          <button type="submit">submit</button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(await screen.findByText('required')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: '[1]' }));

    expect(await screen.findByText('custom')).toBeVisible();
  });

  it('should not require type coercion', async () => {
    function App() {
      class NonCoercible {
        x: string;

        constructor(x: string) {
          this.x = x;
        }

        [Symbol.toPrimitive]() {
          throw new TypeError();
        }
      }

      const { control } = useForm({
        mode: 'onChange',
        defaultValues: {
          value: new NonCoercible('a'),
        },
      });

      return (
        <form>
          <Controller
            control={control}
            name="value"
            rules={{
              validate: (field) => {
                return field.x.length > 0;
              },
            }}
            render={({ field }) => (
              <input
                value={field.value.x}
                onChange={(e) =>
                  field.onChange(new NonCoercible(e.target.value))
                }
              />
            )}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'b',
      },
    });

    expect(screen.getByRole('textbox')).toHaveValue('b');
  });

  it('should respect disabled state set on the input element', () => {
    const Component = () => {
      const { control } = useForm();
      return (
        <Controller
          defaultValue=""
          name="test"
          render={({ field }) => <input disabled {...field} />}
          control={control}
        />
      );
    };

    render(<Component />);

    expect(screen.getByRole('textbox')).toBeDisabled();
  });

  it('should respect disabled state set on the Controller component', () => {
    const Component = () => {
      const { control } = useForm();

      const [disabled, setDisabled] = React.useState(true);

      return (
        <>
          <Controller
            defaultValue=""
            name="test"
            disabled={disabled}
            render={({ field }) => <input {...field} />}
            control={control}
          />
          <button onClick={() => setDisabled(false)}>disable</button>
        </>
      );
    };

    render(<Component />);

    expect(screen.getByRole('textbox')).toBeDisabled();

    fireEvent.click(screen.getByRole('button'));

    expect(screen.getByRole('textbox')).toBeEnabled();
  });

  it('should create error object when the value is Invalid Date during onChange event', async () => {
    let currentErrors: any = {};
    const name = 'test';
    const Component = () => {
      const {
        control,
        formState: { errors },
      } = useForm({ mode: 'onChange' });
      const [text, setText] = React.useState('');
      currentErrors = errors;

      return (
        <form>
          <Controller
            defaultValue=""
            name={name}
            control={control}
            render={({ field: { onChange } }) => (
              <input
                type="text"
                value={text}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                  setText(e.target.value);
                  const dateValue = new Date(e.target.value);
                  onChange(dateValue);
                }}
              />
            )}
            rules={{
              validate: (v) => !(v instanceof Date && isNaN(v.getTime())),
            }}
          />
        </form>
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox');

    fireEvent.change(input, { target: { value: 'test' } });

    await waitFor(() => expect(currentErrors).toHaveProperty(name));

    fireEvent.change(input, { target: { value: '2024-10-16' } });

    await waitFor(() => expect(currentErrors).not.toHaveProperty(name));
  });
});


================================================
File: /src/__tests__/useFieldArray.test.tsx
================================================
import React, { useState } from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { Controller } from '../controller';
import {
  Control,
  FieldValues,
  SubmitHandler,
  UseFormRegister,
  UseFormReturn,
} from '../types';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { FormProvider } from '../useFormContext';
import { useFormState } from '../useFormState';
import noop from '../utils/noop';

let i = 0;

jest.mock('../logic/generateId', () => () => String(i++));

describe('useFieldArray', () => {
  beforeEach(() => {
    i = 0;
  });

  describe('initialize', () => {
    it('should return default fields value', () => {
      const { result } = renderHook(() => {
        const { control } = useForm();
        return useFieldArray({
          control,
          name: 'test',
        });
      });

      expect(result.current.fields).toEqual([]);
    });

    it('should populate default values into fields', () => {
      const { result } = renderHook(() => {
        const { control } = useForm({
          defaultValues: { test: [{ test: '1' }, { test: '2' }] },
        });
        return useFieldArray({
          control,
          name: 'test',
        });
      });

      expect(result.current.fields).toEqual([
        { test: '1', id: '0' },
        { test: '2', id: '1' },
      ]);
    });

    it('should render with FormProvider', () => {
      const Provider = ({ children }: { children: React.ReactNode }) => {
        const methods = useForm();
        return <FormProvider {...methods}>{children}</FormProvider>;
      };
      expect(() =>
        renderHook(() => useFieldArray({ name: 'test' }), {
          wrapper: Provider,
        }),
      ).not.toThrow();
    });
  });

  describe('with should unregister false', () => {
    it('should still remain input value with toggle', () => {
      const Component = () => {
        const { register, control } = useForm<{
          test: {
            value: string;
          }[];
        }>();
        const [show, setShow] = React.useState(true);
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <form>
            {show &&
              fields.map((field, i) => (
                <input
                  key={field.id}
                  {...register(`test.${i}.value` as const)}
                />
              ))}
            <button type="button" onClick={() => append({ value: '' })}>
              append
            </button>
            <button type="button" onClick={() => setShow(!show)}>
              toggle
            </button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'append' }));
      expect(screen.getAllByRole('textbox').length).toEqual(1);
      fireEvent.click(screen.getByRole('button', { name: 'toggle' }));
      expect(screen.queryByRole('textbox')).not.toBeInTheDocument();
      fireEvent.click(screen.getByRole('button', { name: 'toggle' }));
      expect(screen.getAllByRole('textbox').length).toEqual(1);
    });

    it('should show errors during mount when mode is set to onChange', async () => {
      const Component = () => {
        const {
          register,
          control,
          formState: { isValid, errors },
        } = useForm<{ test: { value: string }[] }>({
          defaultValues: {
            test: [{ value: 'test' }],
          },
          resolver: async () => ({
            values: {},
            errors: {
              test: [{ value: { message: 'wrong', type: 'test' } }],
            },
          }),
          mode: 'onChange',
        });
        const { fields, append } = useFieldArray({ name: 'test', control });

        return (
          <form>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button
              type="button"
              onClick={() =>
                append({
                  value: 'test',
                })
              }
            >
              append
            </button>

            {!isValid && <p>not valid</p>}
            {errors.test && <p>errors</p>}
          </form>
        );
      };

      render(<Component />);

      expect(await screen.findByRole('textbox')).toBeVisible();
      expect(await screen.findByText('not valid')).toBeVisible();
    });

    it('should retain input values during unmount', async () => {
      type FormValues = {
        test: { name: string }[];
      };

      const FieldArray = ({
        control,
        register,
      }: {
        control: Control<FormValues>;
        register: UseFormRegister<FormValues>;
      }) => {
        const { fields } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <div>
            {fields.map((item, index) => {
              return (
                <div key={item.id}>
                  <input {...register(`test.${index}.name`)} />
                </div>
              );
            })}
          </div>
        );
      };

      const App = () => {
        const [show, setShow] = React.useState(true);
        const { control, register } = useForm({
          shouldUnregister: false,
          defaultValues: {
            test: [{ name: 'test' }],
          },
        });

        return (
          <div>
            {show && <FieldArray control={control} register={register} />}
            <button type={'button'} onClick={() => setShow(!show)}>
              toggle
            </button>
          </div>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: { value: '12345' },
      });

      fireEvent.click(screen.getByRole('button'));

      fireEvent.click(screen.getByRole('button'));

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '12345',
      );
    });
  });

  describe('with resolver', () => {
    it('should provide updated form value each action', async () => {
      let formData = {};
      const Component = () => {
        const {
          register,
          control,
          formState: { isValid },
        } = useForm<{
          data: string;
          test: { value: string }[];
        }>({
          resolver: (data) => {
            formData = data;
            return {
              values: {},
              errors: {},
            };
          },
        });
        const { fields, append } = useFieldArray({ name: 'test', control });

        return (
          <div>
            <input {...register('data')} defaultValue="test" />
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button onClick={() => append({ value: '' })}>append</button>
            <span>{isValid && 'valid'}</span>
          </div>
        );
      };

      render(<Component />);

      expect(await screen.findByText('valid')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(formData).toEqual({
        data: 'test',
        test: [{ value: '' }],
      });
    });

    it('should provide correct form data with nested field array', async () => {
      type FormValues = {
        test: {
          value: string;
          nestedArray: {
            value: string;
          }[];
        }[];
      };

      let formData: any = {};
      const Nested = ({
        index,
        control,
      }: {
        control: Control<FormValues>;
        index: number;
      }) => {
        const { fields, append } = useFieldArray<FormValues>({
          name: `test.${index}.nestedArray` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <input
                key={item.id}
                {...control.register(
                  `test.${index}.nestedArray.${i}.value` as const,
                )}
              />
            ))}

            <button type={'button'} onClick={() => append({ value: 'test' })}>
              Append Nest
            </button>
          </div>
        );
      };

      const Component = () => {
        const {
          register,
          control,
          formState: { isValid },
        } = useForm<FormValues>({
          resolver: (data) => {
            formData = data;
            return {
              values: data,
              errors: {},
            };
          },
          mode: 'onChange',
          defaultValues: {
            test: [{ value: '1', nestedArray: [{ value: '2' }] }],
          },
        });
        const { fields, remove } = useFieldArray({
          name: 'test',
          control,
        });

        return (
          <form>
            {fields.map((item, i) => (
              <fieldset key={item.id}>
                <input {...register(`test.${i}.value` as const)} />

                <Nested control={control} index={i} />
                <button type={'button'} onClick={() => remove(i)}>
                  delete
                </button>
              </fieldset>
            ))}
            <span>{isValid && 'valid'}</span>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'Append Nest' }));

      expect(await screen.findByText('valid')).toBeVisible();

      expect(formData).toEqual({
        test: [
          {
            value: '1',
            nestedArray: [{ value: '2' }, { value: 'test' }],
          },
        ],
      });

      fireEvent.click(screen.getByRole('button', { name: 'delete' }));

      expect(formData).toEqual({
        test: [],
      });
    });

    it('should report field array error during user action', async () => {
      const App = () => {
        const {
          register,
          control,
          formState: { errors },
        } = useForm<{
          test: { value: string }[];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            return {
              values: data,
              errors: {
                test: {
                  type: 'test',
                  message: 'minLength',
                },
              },
            };
          },
          defaultValues: {
            test: [{ value: '1' }],
          },
        });
        const { fields, remove } = useFieldArray({
          name: 'test',
          control,
        });

        return (
          <form>
            {errors.test && <p>minLength</p>}

            {fields.map((item, i) => (
              <fieldset key={item.id}>
                <input {...register(`test.${i}.value` as const)} />
                <button type={'button'} onClick={() => remove(i)}>
                  delete
                </button>
              </fieldset>
            ))}
          </form>
        );
      };

      render(<App />);

      expect(screen.queryByText('minLength')).not.toBeInTheDocument();

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('minLength')).toBeVisible();
    });

    it('should not return schema error without user action', () => {
      const App = () => {
        const {
          register,
          control,
          formState: { errors },
        } = useForm<{
          test: { value: string }[];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            return {
              values: data,
              errors: {
                test: {
                  type: 'test',
                  message: 'minLength',
                },
              },
            };
          },
          defaultValues: {
            test: [],
          },
        });
        const { fields } = useFieldArray({
          name: 'test',
          control,
        });

        return (
          <form>
            {errors.test && <p>minLength</p>}

            {fields.map((item, i) => (
              <fieldset key={item.id}>
                <input {...register(`test.${i}.value` as const)} />
              </fieldset>
            ))}
          </form>
        );
      };

      render(<App />);

      expect(screen.queryByText('minLength')).not.toBeInTheDocument();
    });

    it('should update error when user action corrects it', async () => {
      const App = () => {
        const {
          register,
          control,
          formState: { errors },
        } = useForm<{
          test: { value: string }[];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            if (data.test.length > 1) {
              return {
                values: data,
                errors: {},
              };
            } else {
              return {
                values: data,
                errors: {
                  test: {
                    type: 'test',
                    message: 'minLength',
                  },
                },
              };
            }
          },
          defaultValues: {
            test: [],
          },
        });
        const { fields, append } = useFieldArray({
          name: 'test',
          control,
        });

        return (
          <form>
            {errors.test && <p>minLength</p>}
            {fields.map((item, i) => (
              <input key={item.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button
              type={'button'}
              onClick={() =>
                append({
                  value: '',
                })
              }
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(screen.queryByText('minLength')).toBeInTheDocument(),
      );

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(screen.queryByText('minLength')).not.toBeInTheDocument(),
      );
    });

    it('should update error when array is changed', async () => {
      const App = () => {
        const {
          register,
          control,
          formState: { errors },
        } = useForm<{
          test: { value: string }[];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            const errors: { test?: any } = {};
            if (data.test.length > 4) {
              errors.test = { type: 'toobig', message: 'WAY too many items' };
            } else if (data.test.length > 3) {
              errors.test = { type: 'toobig', message: 'Too many items' };
            }
            for (const [index, item] of data.test.entries()) {
              if (item.value === '') {
                errors.test = errors.test || [];
                errors.test[index] = {
                  value: { type: 'required', message: 'Required' },
                };
              }
            }

            return {
              values: data,
              errors,
            };
          },
          defaultValues: {
            test: [{ value: '0' }, { value: '1' }, { value: '2' }],
          },
        });
        const { fields, append, remove } = useFieldArray({
          name: 'test',
          control,
        });

        return (
          <form>
            {errors.test?.type && <p>Array error: {errors.test.message}</p>}
            {fields.map((item, i) => (
              <div key={item.id}>
                <input {...register(`test.${i}.value` as const)} />
                <button type="button" onClick={() => remove(i)}>
                  remove
                </button>
                {errors.test?.[i]?.value && (
                  <span>
                    Item {i} error: {errors.test?.[i]?.value?.message}
                  </span>
                )}
              </div>
            ))}
            <button
              type="button"
              onClick={() =>
                append({
                  value: fields.length.toString(),
                })
              }
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      await waitFor(() =>
        expect(screen.queryByText('Array error:')).not.toBeInTheDocument(),
      );

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      await waitFor(() =>
        expect(
          screen.queryByText('Array error: Too many items'),
        ).toBeInTheDocument(),
      );

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      await waitFor(() =>
        expect(
          screen.queryByText('Array error: WAY too many items'),
        ).toBeInTheDocument(),
      );

      fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[0]);

      await waitFor(() =>
        expect(
          screen.queryByText('Array error: Too many items'),
        ).toBeInTheDocument(),
      );

      fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[0]);

      await waitFor(() =>
        expect(screen.queryByText('Array error:')).not.toBeInTheDocument(),
      );

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: { value: '' },
      });

      await waitFor(() =>
        expect(
          screen.queryByText('Item 0 error: Required'),
        ).toBeInTheDocument(),
      );

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      await waitFor(() => {
        expect(
          screen.queryByText('Array error: Too many items'),
        ).toBeInTheDocument();
        expect(
          screen.queryByText('Item 0 error: Required'),
        ).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      await waitFor(() => {
        expect(
          screen.queryByText('Array error: WAY too many items'),
        ).toBeInTheDocument();
        expect(
          screen.queryByText('Item 0 error: Required'),
        ).toBeInTheDocument();
      });

      fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[4]);

      await waitFor(() => {
        expect(
          screen.queryByText('Array error: Too many items'),
        ).toBeInTheDocument();
        expect(
          screen.queryByText('Item 0 error: Required'),
        ).toBeInTheDocument();
      });

      fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[3]);

      await waitFor(() => {
        expect(
          screen.queryByText('Array error: Too many items'),
        ).not.toBeInTheDocument();
        expect(
          screen.queryByText('Item 0 error: Required'),
        ).toBeInTheDocument();
      });
    });
  });

  describe('when component unMount', () => {
    it('should keep field array values', async () => {
      let getValues: any;
      const Component = () => {
        const [show, setShow] = React.useState(true);
        const { register, control, getValues: tempGetValues } = useForm();
        const { fields, append } = useFieldArray({ name: 'test', control });
        getValues = tempGetValues;

        return (
          <>
            {show && (
              <div>
                {fields.map((_, i) => (
                  <input key={i.toString()} {...register(`test.${i}.value`)} />
                ))}
                <button onClick={() => append({ value: '' })}>append</button>
              </div>
            )}
            <button type={'button'} onClick={() => setShow(!show)}>
              setShow
            </button>
          </>
        );
      };

      render(<Component />);

      const button = screen.getByRole('button', { name: /append/i });

      fireEvent.click(button);

      fireEvent.click(button);

      fireEvent.click(button);

      fireEvent.click(screen.getByRole('button', { name: 'setShow' }));

      expect(getValues()).toEqual({
        test: [{ value: '' }, { value: '' }, { value: '' }],
      });

      fireEvent.click(screen.getByRole('button', { name: 'setShow' }));
      expect(screen.getAllByRole('textbox').length).toEqual(3);
    });

    it('should remove reset method when field array is removed', () => {
      let controlTemp: any;
      let fieldsTemp: unknown[] = [];

      const App = () => {
        const { register, control } = useForm({
          defaultValues: {
            test: [{ value: 'default' }],
          },
        });
        const { fields, append } = useFieldArray({
          name: 'test',
          control,
        });
        controlTemp = control;
        fieldsTemp = fields;

        return (
          <form>
            {fields.map((field) => {
              return <input key={field.id} {...register('test.0.value')} />;
            })}
            <button
              type={'button'}
              onClick={() => {
                append({
                  value: 'test',
                });
              }}
            >
              append
            </button>
          </form>
        );
      };

      const { unmount } = render(<App />);

      expect(fieldsTemp).toEqual([{ id: '0', value: 'default' }]);

      fireEvent.click(screen.getByRole('button'));

      expect(fieldsTemp).toEqual([
        { id: '0', value: 'default' },
        {
          id: '1',
          value: 'test',
        },
      ]);

      unmount();

      expect(controlTemp._names.array).toEqual(new Set(['test']));
      expect(fieldsTemp).toEqual([
        { id: '0', value: 'default' },
        {
          id: '1',
          value: 'test',
        },
      ]);
    });

    it('should unset field array values correctly on DOM removing', async () => {
      interface NestedComponentProps
        extends Pick<UseFormReturn<FormValues>, 'control' | 'register'> {
        childIndex: number;
      }

      type FormValues = {
        test: {
          title: string;
          nested: {
            name: string;
          }[];
        }[];
        title: string;
      };

      const NestedComponent = ({
        childIndex,
        control,
        register,
      }: NestedComponentProps) => {
        const { fields } = useFieldArray({
          control,
          name: `test.${childIndex}.nested` as `test.0.nested`,
        });

        return (
          <div>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input
                    {...register(
                      `test.${childIndex}.nested.${index}.name` as const,
                    )}
                  />
                </div>
              );
            })}
          </div>
        );
      };

      const Component = () => {
        const { control, register } = useForm<FormValues>();
        const { fields, append, remove } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <form>
            <input {...register('title')} />
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input {...register(`test.${index}.title` as const)} />
                  <button type="button" onClick={() => remove(index)}>
                    Remove child
                  </button>
                  <NestedComponent
                    childIndex={index}
                    control={control}
                    register={register}
                  />
                </div>
              );
            })}
            <button
              type="button"
              onClick={() => append({ title: 'test', nested: [] })}
            >
              Add child
            </button>
          </form>
        );
      };

      render(<Component />);

      const addChild = () => fireEvent.click(screen.getByText('Add child'));

      addChild();

      expect(screen.getByText('Remove child')).toBeInTheDocument();

      fireEvent.click(screen.getByText('Remove child'));

      expect(screen.queryByText('Remove child')).not.toBeInTheDocument();

      addChild();

      expect(screen.getByText('Remove child')).toBeInTheDocument();
    });
  });

  describe('with should unregister true', () => {
    it('should not unregister field if unregister method is triggered', () => {
      let getValues: any;
      const Component = () => {
        const {
          register,
          unregister,
          control,
          getValues: tempGetValues,
        } = useForm();
        const { fields, append } = useFieldArray({ name: 'test', control });
        getValues = tempGetValues;

        React.useEffect(() => {
          if (fields.length >= 3) {
            unregister('test');
          }
        }, [fields, unregister]);

        return (
          <div>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value`)} />
            ))}
            <button type={'button'} onClick={() => append({ value: '' })}>
              append
            </button>
          </div>
        );
      };

      render(<Component />);

      const button = screen.getByRole('button', { name: /append/i });

      fireEvent.click(button);
      fireEvent.click(button);
      fireEvent.click(button);

      expect(getValues()).toEqual({
        test: [{ value: '' }, { value: '' }, { value: '' }],
      });
    });

    it('should remove field array after useFieldArray is unmounted', () => {
      type FormValues = {
        test: { name: string }[];
      };

      const FieldArray = ({ control }: { control: Control<FormValues> }) => {
        const { fields } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <div>
            {fields.map((item, index) => {
              return (
                <input key={item.id} name={`test.${index}.name` as const} />
              );
            })}
          </div>
        );
      };

      const App = () => {
        const [show, setShow] = React.useState(true);
        const { control } = useForm<FormValues>({
          shouldUnregister: true,
          defaultValues: {
            test: [{ name: 'test' }],
          },
        });

        return (
          <div>
            {show && <FieldArray control={control} />}
            <button type={'button'} onClick={() => setShow(!show)}>
              toggle
            </button>
          </div>
        );
      };

      render(<App />);

      expect(screen.getByRole('textbox')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(screen.queryByRole('textbox')).not.toBeInTheDocument();
    });
  });

  describe('setError', () => {
    it('should be able to set an field array error', async () => {
      const Component = () => {
        const {
          register,
          setError,
          control,
          formState: { errors },
        } = useForm();
        const { fields, append, remove } = useFieldArray({
          name: 'test',
          control,
        });

        React.useEffect(() => {
          if (fields.length === 0) {
            setError('test', {
              type: 'min length',
            });
          }
        }, [fields, setError]);

        return (
          <div>
            {fields.map((_, i) => (
              <div key={i.toString()}>
                <input {...register(`test.${i}.value`)} />
                <button type={'button'} onClick={() => remove(i)}>
                  delete
                </button>
              </div>
            ))}
            <button type="button" onClick={() => append({ value: '' })}>
              append
            </button>
            <button>submit</button>
            <p>{errors.test && 'Error'}</p>
          </div>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      fireEvent.click(screen.getByRole('button', { name: 'delete' }));

      expect(await screen.findByText('Error')).toBeVisible();
    });
  });

  describe('with reset', () => {
    it('should reset with field array', async () => {
      let fieldsTemp: unknown[] = [];

      const App = () => {
        const { register, reset, control } = useForm({
          defaultValues: {
            test: [{ value: 'default' }],
          },
        });
        const { fields, append } = useFieldArray({
          name: 'test',
          control,
        });
        fieldsTemp = fields;

        return (
          <form>
            {fields.map((field, index) => {
              return (
                <input key={field.id} {...register(`test.${index}.value`)} />
              );
            })}

            <button
              type={'button'}
              onClick={() => {
                append({ value: 'test' });
              }}
            >
              append
            </button>

            <button
              type={'button'}
              onClick={() => {
                reset();
              }}
            >
              reset
            </button>
          </form>
        );
      };

      render(<App />);

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      fireEvent.click(screen.getByRole('button', { name: 'reset' }));

      expect(fieldsTemp).toEqual([{ id: '4', value: 'default' }]);
    });

    it('should reset with field array with shouldUnregister set to false', () => {
      const { result } = renderHook(() => {
        const { register, reset, control } = useForm({
          defaultValues: {
            test: [{ value: 'default' }],
          },
        });
        const { fields, append } = useFieldArray({
          name: 'test',
          control,
        });
        return { register, reset, fields, append };
      });

      act(() => {
        result.current.append({ value: 'test' });
      });

      result.current.register('test.0.value');

      act(() => {
        result.current.reset();
      });

      expect(result.current.fields).toEqual([{ id: '4', value: 'default' }]);

      act(() => {
        result.current.reset({
          test: [{ value: 'data' }],
        });
      });

      expect(result.current.fields).toEqual([{ id: '6', value: 'data' }]);
    });

    it('should reset with async', async () => {
      type FormValues = {
        test: {
          value: string;
          nestedArray: {
            value: string;
          }[];
        }[];
      };

      const Nested = ({
        index,
        control,
      }: {
        control: Control<FormValues>;
        index: number;
      }) => {
        const { fields } = useFieldArray<FormValues>({
          name: `test.${index}.nestedArray` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <input
                key={item.id}
                {...control.register(
                  `test.${index}.nestedArray.${i}.value` as const,
                )}
              />
            ))}
          </div>
        );
      };

      const Component = () => {
        const { register, reset, control } = useForm<FormValues>();
        const { fields } = useFieldArray({
          name: 'test',
          control,
        });

        React.useEffect(() => {
          setTimeout(() => {
            reset({
              test: [
                { value: '1', nestedArray: [{ value: '2' }] },
                { value: '3', nestedArray: [{ value: '4' }] },
              ],
            });
          });
        }, [reset]);

        return (
          <form>
            {fields.map((item, i) => (
              <fieldset key={item.id}>
                <input {...register(`test.${i}.value` as const)} />

                <Nested control={control} index={i} />
              </fieldset>
            ))}
          </form>
        );
      };

      render(<Component />);

      await waitFor(() =>
        expect(screen.getAllByRole('textbox')).toHaveLength(4),
      );
    });
  });

  describe('with setValue', () => {
    it.each(['isDirty', 'dirtyFields'])(
      'should set name to dirtyFieldRef if array field values are different with default value when formState.%s is defined',
      async (property) => {
        let setValue: any;
        let formState: any;
        const Component = () => {
          const {
            register,
            control,
            formState: tempFormState,
            setValue: tempSetValue,
            watch,
          } = useForm({
            defaultValues: {
              test: [
                { name: 'default' },
                { name: 'default1' },
                { name: 'default2' },
              ],
            },
          });
          const { fields } = useFieldArray({ name: 'test', control });
          watch();

          setValue = tempSetValue;
          formState = tempFormState;
          formState[property];

          return (
            <form>
              {fields.map((field, i) => (
                <input
                  key={field.id}
                  {...register(`test.${i}.name` as const)}
                />
              ))}
            </form>
          );
        };

        render(<Component />);

        await act(async () => {
          setValue(
            'test',
            [
              { name: 'default_update' },
              { name: 'default1' },
              { name: 'default2' },
            ],
            { shouldDirty: true },
          );
        });

        if (property === 'dirtyFields') {
          expect(formState.dirtyFields).toEqual({
            test: [{ name: true }, { name: false }, { name: false }],
          });
        } else {
          expect(formState.isDirty).toBeTruthy();
        }
      },
    );

    it.each(['dirtyFields'])(
      'should unset name from dirtyFieldRef if array field values are not different with default value when formState.%s is defined',
      (property) => {
        let setValue: any;
        let formState: any;
        const Component = () => {
          const {
            register,
            control,
            formState: tempFormState,
            setValue: tempSetValue,
          } = useForm({
            defaultValues: {
              test: [
                { name: 'default' },
                { name: 'default1' },
                { name: 'default2' },
              ],
            },
          });
          const { fields } = useFieldArray({ name: 'test', control });

          setValue = tempSetValue;
          formState = tempFormState;
          formState[property];

          return (
            <form>
              {fields.map((field, i) => (
                <input
                  key={field.id}
                  {...register(`test.${i}.name` as const)}
                />
              ))}
            </form>
          );
        };

        render(<Component />);

        act(() => {
          setValue(
            'test',
            [
              { name: 'default_update' },
              { name: 'default1' },
              { name: 'default2' },
            ],
            { shouldDirty: true },
          );
        });

        if (property === 'dirtyFields') {
          expect(formState.dirtyFields).toEqual({
            test: [{ name: true }, { name: false }, { name: false }],
          });
        } else {
          expect(formState.isDirty).toBeTruthy();
        }

        act(() => {
          setValue(
            'test',
            [{ name: 'default' }, { name: 'default1' }, { name: 'default2' }],
            { shouldDirty: true },
          );
        });

        expect(formState.dirtyFields).toEqual({
          test: [
            {
              name: false,
            },
            {
              name: false,
            },
            {
              name: false,
            },
          ],
        });
        expect(formState.isDirty).toBeFalsy();
      },
    );

    it('should set nested field array correctly', async () => {
      type FormValues = {
        test: {
          firstName: string;
          lastName: string;
          keyValue: { name: string }[];
        }[];
      };

      function NestedArray({
        control,
        index,
      }: {
        control: Control<FormValues>;
        index: number;
      }) {
        const { fields } = useFieldArray({
          name: `test.${index}.keyValue` as 'test.0.keyValue',
          control,
        });

        return (
          <ul>
            {fields.map((item, i) => (
              <Controller
                key={item.id}
                render={({ field }) => (
                  <input
                    {...field}
                    aria-label={`test.${index}.keyValue.${i}.name`}
                  />
                )}
                name={`test.${index}.keyValue.${i}.name` as const}
                control={control}
              />
            ))}
          </ul>
        );
      }

      function Component() {
        const { register, control, setValue } = useForm<FormValues>({
          defaultValues: {
            test: [
              {
                firstName: 'Bill',
                lastName: 'Luo',
                keyValue: [{ name: '1a' }, { name: '1c' }],
              },
            ],
          },
        });
        const { fields } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <form>
            {fields.map((item, index) => {
              return (
                <div key={item.id}>
                  <input
                    aria-label={`test.${index}.firstName`}
                    {...register(`test.${index}.firstName` as const)}
                  />
                  <NestedArray control={control} index={index} />
                </div>
              );
            })}
            <button
              type="button"
              onClick={() => setValue('test.0.keyValue', [{ name: '2a' }])}
            >
              setValue
            </button>
          </form>
        );
      }

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'setValue' }));

      const input = screen.getByLabelText(
        'test.0.keyValue.0.name',
      ) as HTMLInputElement;

      expect(input.value).toEqual('2a');

      expect(
        (screen.getByLabelText('test.0.firstName') as HTMLInputElement).value,
      ).toEqual('Bill');
    });
  });

  describe('array of array fields', () => {
    it('should remove correctly with nested field array and set shouldUnregister to false', () => {
      type FormValues = {
        fieldArray: {
          value: string;
          nestedFieldArray: {
            value: string;
          }[];
        }[];
      };

      const ArrayField = ({
        arrayIndex,
        register,
        control,
      }: {
        arrayIndex: number;
        register: UseFormReturn<FormValues>['register'];
        arrayField: Partial<FieldValues>;
        control: Control<FormValues>;
      }) => {
        const { fields, append, remove } = useFieldArray<FormValues>({
          name: `fieldArray.${arrayIndex}.nestedFieldArray` as const,
          control,
        });

        return (
          <div>
            <input {...register(`fieldArray.${arrayIndex}.value` as const)} />
            {fields.map((nestedField, index) => (
              <div key={nestedField.id}>
                <input
                  {...register(
                    `fieldArray.${arrayIndex}.nestedFieldArray.${index}.value` as const,
                  )}
                />
                <button type="button" onClick={() => remove(index)}>
                  remove
                </button>
              </div>
            ))}
            <button
              type="button"
              onClick={() => {
                append({
                  value:
                    `fieldArray.${arrayIndex}.nestedFieldArray.${fields.length}.value` as const,
                });
              }}
            >
              Add nested array
            </button>
          </div>
        );
      };

      const Component = () => {
        const { register, control } = useForm<FormValues>();
        const { fields, append } = useFieldArray({
          name: 'fieldArray',
          control,
        });

        return (
          <form>
            {fields.map((field, index) => (
              <ArrayField
                key={field.id}
                arrayIndex={index}
                arrayField={field}
                register={register}
                control={control}
              />
            ))}

            <button
              type="button"
              onClick={() => {
                append({
                  value: `fieldArray[${fields.length}].value`,
                  nestedFieldArray: [],
                });
              }}
            >
              Add array
            </button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(
        screen.getByRole('button', {
          name: 'Add array',
        }),
      );

      fireEvent.click(
        screen.getByRole('button', {
          name: 'Add nested array',
        }),
      );

      fireEvent.click(
        screen.getByRole('button', {
          name: 'Add nested array',
        }),
      );

      fireEvent.click(
        screen.getAllByRole('button', {
          name: 'remove',
        })[0],
      );

      fireEvent.click(
        screen.getAllByRole('button', {
          name: 'remove',
        })[0],
      );

      expect(screen.getAllByRole('textbox').length).toEqual(1);
    });

    it('should prepend correctly with default values on nested array fields', () => {
      type FormInputs = {
        nest: {
          test: {
            value: string;
            nestedArray: { value: string }[];
          }[];
        };
      };

      const ChildComponent = ({
        index,
        control,
      }: {
        control: Control<FormInputs>;
        index: number;
      }) => {
        const { fields } = useFieldArray<FormInputs>({
          name: `nest.test.${index}.nestedArray` as const,
          control,
        });

        return (
          <>
            {fields.map((item, i) => (
              <input
                key={item.id}
                {...control.register(
                  `nest.test.${index}.nestedArray.${i}.value` as const,
                )}
              />
            ))}
          </>
        );
      };

      const Component = () => {
        const { register, control } = useForm<FormInputs>({
          defaultValues: {
            nest: {
              test: [
                { value: '1', nestedArray: [{ value: '2' }, { value: '3' }] },
                { value: '4', nestedArray: [{ value: '5' }] },
              ],
            },
          },
        });
        const { fields, prepend } = useFieldArray({
          name: 'nest.test',
          control,
        });

        return (
          <>
            {fields.map((item, i) => (
              <div key={item.id}>
                <input {...register(`nest.test.${i}.value` as const)} />
                <ChildComponent control={control} index={i} />
              </div>
            ))}

            <button
              type={'button'}
              onClick={() => prepend({ value: 'test', nestedArray: [] })}
            >
              prepend
            </button>
          </>
        );
      };

      render(<Component />);

      expect(screen.getAllByRole('textbox')).toHaveLength(5);

      fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

      expect(screen.getAllByRole('textbox')).toHaveLength(6);

      expect(
        (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
      ).toEqual('test');
    });

    it('should render correct amount of child array fields', async () => {
      type FormValues = {
        nest: {
          test: {
            value: string;
            nestedArray: {
              value: string;
            }[];
          }[];
        };
      };
      const ChildComponent = ({
        index,
        control,
      }: {
        control: Control<FormValues>;
        index: number;
      }) => {
        const { fields } = useFieldArray<FormValues>({
          name: `nest.test.${index}.nestedArray` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <input
                key={item.id}
                {...control.register(
                  `nest.test.${index}.nestedArray.${i}.value` as const,
                )}
              />
            ))}
          </div>
        );
      };

      const Component = () => {
        const { register, control } = useForm({
          defaultValues: {
            nest: {
              test: [
                { value: '1', nestedArray: [{ value: '2' }] },
                { value: '3', nestedArray: [{ value: '4' }] },
              ],
            },
          },
        });
        const { fields, remove, append } = useFieldArray({
          name: 'nest.test',
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <div key={item.id}>
                <input {...register(`nest.test.${i}.value` as const)} />

                <ChildComponent control={control} index={i} />

                <button
                  type={'button'}
                  onClick={() => remove(i)}
                  data-testid={item.value}
                >
                  remove
                </button>
              </div>
            ))}

            <button
              type={'button'}
              onClick={() => append({ value: 'test', nestedArray: [] })}
            >
              append
            </button>
          </div>
        );
      };

      render(<Component />);

      expect(screen.getAllByRole('textbox')).toHaveLength(4);

      fireEvent.click(screen.getByTestId('1'));

      expect(screen.getAllByRole('textbox')).toHaveLength(2);

      fireEvent.click(screen.getByRole('button', { name: /append/i }));

      expect(screen.getAllByRole('textbox')).toHaveLength(3);
    });

    it('should populate all array fields with setValue when name match Field Array', () => {
      type FormInputs = {
        nest: {
          value: number;
          nestedArray: {
            value: number;
          }[];
        }[];
      };

      const ChildComponent = ({
        index,
        control,
      }: {
        control: Control<FormInputs>;
        index: number;
      }) => {
        const { fields } = useFieldArray<FormInputs>({
          name: `nest.${index}.nestedArray` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <label key={item.id}>
                {`nest.${index}.nestedArray.${i}.value`}
                <input
                  {...control.register(
                    `nest.${index}.nestedArray.${i}.value` as const,
                  )}
                />
              </label>
            ))}
          </div>
        );
      };

      const Component = () => {
        const { register, control, setValue } = useForm<FormInputs>();
        const { fields } = useFieldArray({
          name: 'nest',
          control,
        });

        React.useEffect(() => {
          setValue('nest', [
            {
              value: 1,
              nestedArray: [
                {
                  value: 11,
                },
              ],
            },
            {
              value: 2,
              nestedArray: [
                {
                  value: 21,
                },
              ],
            },
          ]);
        }, [setValue]);

        return (
          <div>
            {fields.map((item, i) => (
              <div key={item.id}>
                <label>
                  {`nest.${i}.value`}
                  <input {...register(`nest.${i}.value` as const)} />
                </label>

                <ChildComponent control={control} index={i} />
              </div>
            ))}
          </div>
        );
      };

      render(<Component />);

      const nestInput0 = screen.getByRole('textbox', {
        name: 'nest.0.value',
      });
      const nestInput1 = screen.getByRole('textbox', { name: 'nest.1.value' });
      const nestedArrayInput0 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.0.value',
      });
      const nestedArrayInput1 = screen.getByRole('textbox', {
        name: 'nest.1.nestedArray.0.value',
      });

      expect(nestInput0).toHaveValue('1');
      expect(nestedArrayInput0).toHaveValue('11');
      expect(nestInput1).toHaveValue('2');
      expect(nestedArrayInput1).toHaveValue('21');
    });

    it('should populate all array fields correctly with setValue', () => {
      type FormValues = {
        nest: {
          value: number;
          nestedArray: { value: number }[];
        }[];
      };

      const ChildComponent = ({
        index,
        control,
      }: {
        control: Control<FormValues>;
        index: number;
      }) => {
        const { fields } = useFieldArray<FormValues>({
          name: `nest.${index}.nestedArray` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <label key={item.id}>
                {`nest.${index}.nestedArray.${i}.value`}
                <input
                  {...control.register(
                    `nest.${index}.nestedArray.${i}.value` as const,
                  )}
                />
              </label>
            ))}
          </div>
        );
      };

      const Component = () => {
        const { register, control, setValue } = useForm<FormValues>();
        const { fields } = useFieldArray({
          name: 'nest',
          control,
        });

        React.useEffect(() => {
          setValue(
            'nest',
            [
              {
                value: 1,
                nestedArray: [
                  {
                    value: 11,
                  },
                ],
              },
              {
                value: 2,
                nestedArray: [
                  {
                    value: 21,
                  },
                ],
              },
            ],
            { shouldDirty: true },
          );
        }, [setValue]);

        return (
          <div>
            {fields.map((item, i) => (
              <div key={item.id}>
                <label>
                  {`nest.${i}.value`}
                  <input {...register(`nest.${i}.value` as const)} />
                </label>

                <ChildComponent control={control} index={i} />
              </div>
            ))}
          </div>
        );
      };

      render(<Component />);

      const nestInput0 = screen.getByRole('textbox', { name: 'nest.0.value' });
      const nestInput1 = screen.getByRole('textbox', { name: 'nest.1.value' });
      const nestedArrayInput0 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.0.value',
      });
      const nestedArrayInput1 = screen.getByRole('textbox', {
        name: 'nest.1.nestedArray.0.value',
      });

      expect(nestInput0).toHaveValue('1');
      expect(nestedArrayInput0).toHaveValue('11');
      expect(nestInput1).toHaveValue('2');
      expect(nestedArrayInput1).toHaveValue('21');
    });

    it('should worked with deep nested field array without chaining useFieldArray', () => {
      type FormValues = {
        nest: {
          value: string;
          nestedArray: { deepNest: { value: string }[] };
        }[];
      };

      const ChildComponent = ({
        index,
        control,
      }: {
        control: Control<FormValues>;
        index: number;
      }) => {
        const { fields, append } = useFieldArray<FormValues>({
          name: `nest.${index}.nestedArray.deepNest` as const,
          control,
        });

        return (
          <div>
            {fields.map((item, i) => (
              <label key={item.id}>
                {`nest.${index}.nestedArray.deepNest.${i}.value`}
                <input
                  {...control.register(
                    `nest.${index}.nestedArray.deepNest.${i}.value` as const,
                  )}
                />
              </label>
            ))}
            <button type={'button'} onClick={() => append({ value: 'test' })}>
              append
            </button>
          </div>
        );
      };

      const Component = () => {
        const { register, control, setValue, reset } = useForm<FormValues>();
        const { fields } = useFieldArray({
          name: 'nest',
          control,
        });

        React.useEffect(() => {
          reset({
            nest: [
              {
                value: '1',
                nestedArray: {
                  deepNest: [
                    {
                      value: '1',
                    },
                  ],
                },
              },
            ],
          });
        }, [reset]);

        return (
          <div>
            {fields.map((item, i) => (
              <div key={item.id}>
                <label>
                  {`nest.${i}.value`}
                  <input {...register(`nest.${i}.value` as const)} />
                </label>
                <ChildComponent control={control} index={i} />
                <button
                  type={'button'}
                  onClick={() => {
                    setValue(
                      'nest',
                      [
                        {
                          value: 'newV1',
                          nestedArray: {
                            deepNest: [
                              {
                                value: 'new1',
                              },
                              {
                                value: 'new2',
                              },
                              {
                                value: 'new3',
                              },
                            ],
                          },
                        },
                      ],
                      { shouldDirty: true },
                    );
                  }}
                >
                  setValue
                </button>
              </div>
            ))}
          </div>
        );
      };

      render(<Component />);

      expect(screen.getAllByRole('textbox')).toHaveLength(2);
      const nestInput = screen.getByRole('textbox', { name: 'nest.0.value' });
      const deepNestInput0 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.deepNest.0.value',
      });

      expect(nestInput).toHaveValue('1');
      expect(deepNestInput0).toHaveValue('1');

      fireEvent.click(screen.getByRole('button', { name: 'setValue' }));

      const deepNestInput1 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.deepNest.1.value',
      });
      const deepNestInput2 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.deepNest.2.value',
      });

      expect(screen.getByRole('textbox', { name: 'nest.0.value' })).toHaveValue(
        'newV1',
      );
      expect(
        screen.getByRole('textbox', {
          name: 'nest.0.nestedArray.deepNest.0.value',
        }),
      ).toHaveValue('new1');
      expect(deepNestInput1).toHaveValue('new2');
      expect(deepNestInput2).toHaveValue('new3');

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      const deepNestInput3 = screen.getByRole('textbox', {
        name: 'nest.0.nestedArray.deepNest.3.value',
      });
      expect(deepNestInput3).toHaveValue('test');
    });

    it('should allow append with deeply nested field array even with flat structure', async () => {
      const watchValue: unknown[] = [];

      const App = () => {
        const [data, setData] = React.useState({});
        const { control, handleSubmit, watch } = useForm<{
          test: {
            yourDetails: {
              firstName: string[];
              lastName: string[];
            };
          }[];
        }>();
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        watchValue.push(watch());

        return (
          <form
            onSubmit={handleSubmit((data) => {
              setData(data);
            })}
          >
            {fields.map((field) => {
              return <div key={field.id} />;
            })}
            <button
              type={'button'}
              onClick={() => {
                append({
                  yourDetails: {
                    firstName: ['test', 'test1'],
                    lastName: ['test', 'test1'],
                  },
                });
              }}
            >
              append
            </button>
            <button>submit</button>
            <p>{JSON.stringify(data)}</p>
          </form>
        );
      };

      render(<App />);

      expect(watchValue.at(-1)).toEqual({ test: [] });

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      expect(watchValue.at(-1)).toEqual({
        test: [
          {
            yourDetails: {
              firstName: ['test', 'test1'],
              lastName: ['test', 'test1'],
            },
          },
        ],
      });

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(
        await screen.findByText(
          '{"test":[{"yourDetails":{"firstName":["test","test1"],"lastName":["test","test1"]}}]}',
        ),
      ).toBeVisible();

      // Let's check all values of renders with implicitly the number of render (for each value)
      expect(watchValue).toMatchSnapshot();
    });
  });

  describe('submit form', () => {
    it('should not leave defaultValues as empty array', async () => {
      let submitData: any;
      type FormValues = {
        test: {
          value: string;
        }[];
      };
      const Component = () => {
        const { register, control, handleSubmit } = useForm<FormValues>({
          defaultValues: {
            test: [],
          },
        });
        const { fields } = useFieldArray({
          control,
          name: 'test',
        });
        const onSubmit: SubmitHandler<FormValues> = (data) => {
          submitData = data;
        };

        return (
          <form onSubmit={handleSubmit(onSubmit)}>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(submitData).toEqual({
          test: [],
        }),
      );
    });
  });

  it('should custom register append, prepend and insert inputs with values', () => {
    type FormValues = {
      test: {
        test: string;
        test1: string;
        test2: {
          test: string;
        }[];
      }[];
    };
    const watchValues: unknown[] = [];

    const Component = () => {
      const { control, watch } = useForm<FormValues>({
        defaultValues: {
          test: [],
        },
      });
      const { append, prepend, insert } = useFieldArray({
        control,
        name: 'test',
      });

      watchValues.push(watch('test'));

      React.useEffect(() => {
        append({
          test: 'append',
          test1: 'append',
          test2: [],
        });
      }, [append]);

      return (
        <form>
          <button
            type={'button'}
            onClick={() =>
              prepend({
                test: 'prepend',
                test1: 'prepend',
                test2: [],
              })
            }
          >
            prepend
          </button>
          <button
            type={'button'}
            onClick={() =>
              insert(1, {
                test: 'insert',
                test1: 'insert',
                test2: [],
              })
            }
          >
            insert
          </button>

          <button
            type={'button'}
            onClick={() =>
              append({
                test: 'append',
                test2: [
                  {
                    test: 'test',
                  },
                ],
                test1: '',
              })
            }
          >
            deep append
          </button>
          <button
            type={'button'}
            onClick={() =>
              prepend({
                test: 'prepend',
                test2: [
                  {
                    test: 'test',
                  },
                ],
                test1: '',
              })
            }
          >
            deep prepend
          </button>
          <button
            type={'button'}
            onClick={() =>
              insert(1, {
                test: 'insert',
                test2: [
                  {
                    test: 'test',
                  },
                ],
                test1: '',
              })
            }
          >
            deep insert
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(watchValues.at(-1)).toEqual([
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    expect(watchValues.at(-1)).toEqual([
      { test: 'prepend', test1: 'prepend', test2: [] },
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'insert' }));

    expect(watchValues.at(-1)).toEqual([
      { test: 'prepend', test1: 'prepend', test2: [] },
      {
        test: 'insert',
        test1: 'insert',
        test2: [],
      },
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'deep append' }));

    expect(watchValues.at(-1)).toEqual([
      { test: 'prepend', test1: 'prepend', test2: [] },
      {
        test: 'insert',
        test1: 'insert',
        test2: [],
      },
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
      {
        test: 'append',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'deep prepend' }));

    expect(watchValues.at(-1)).toEqual([
      {
        test: 'prepend',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
      { test: 'prepend', test1: 'prepend', test2: [] },
      {
        test: 'insert',
        test1: 'insert',
        test2: [],
      },
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
      {
        test: 'append',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'deep insert' }));

    expect(watchValues.at(-1)).toEqual([
      {
        test: 'prepend',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
      {
        test: 'insert',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
      { test: 'prepend', test1: 'prepend', test2: [] },
      {
        test: 'insert',
        test1: 'insert',
        test2: [],
      },
      {
        test: 'append',
        test1: 'append',
        test2: [],
      },
      {
        test: 'append',
        test1: '',
        test2: [
          {
            test: 'test',
          },
        ],
      },
    ]);

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(watchValues).toMatchSnapshot();
  });

  it('should append multiple inputs correctly', () => {
    type FormValues = {
      test: {
        value: string;
      }[];
    };

    const watchedValue: unknown[] = [];

    const Component = () => {
      const { register, control, watch } = useForm<FormValues>({
        defaultValues: {
          test: [
            {
              value: 'data',
            },
          ],
        },
      });
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      watchedValue.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => {
              append([{ value: 'test' }, { value: 'test1' }]);
            }}
          >
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(watchedValue.at(-1)).toEqual({
      test: [
        {
          value: 'data',
        },
      ],
    });

    fireEvent.click(screen.getByRole('button'));

    expect(watchedValue.at(-1)).toEqual({
      test: [
        {
          value: 'data',
        },
        { value: 'test' },
        { value: 'test1' },
      ],
    });

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(watchedValue).toMatchSnapshot();
  });

  it('should update field array defaultValues when invoke setValue', async () => {
    type FormValues = {
      names: {
        name: string;
      }[];
    };

    const result: unknown[] = [];

    const Child = () => {
      const { fields } = useFieldArray<FormValues>({
        name: 'names',
      });

      return (
        <>
          {fields.map((item, index) => (
            <Controller
              key={item.id}
              name={`names.${index}.name` as const}
              render={({ field }) => <input {...field} />}
            />
          ))}
        </>
      );
    };

    function Component() {
      const [hide, setHide] = React.useState(true);
      const methods = useForm<FormValues>({
        defaultValues: {
          names: [{ name: 'will' }, { name: 'Mike' }],
        },
      });
      const { setValue } = methods;

      result.push(methods.watch());

      return (
        <form>
          <FormProvider {...methods}>{hide && <Child />}</FormProvider>
          <button type={'button'} onClick={() => setValue('names', [])}>
            Change value
          </button>
          <button type={'button'} onClick={() => setHide(!hide)}>
            Toggle hide
          </button>
        </form>
      );
    }

    render(<Component />);

    expect(result.at(-1)).toEqual({
      names: [
        {
          name: 'will',
        },
        {
          name: 'Mike',
        },
      ],
    });

    fireEvent.click(screen.getByRole('button', { name: 'Toggle hide' }));

    expect(screen.queryAllByRole('textbox')).toEqual([]);

    fireEvent.click(screen.getByRole('button', { name: 'Change value' }));

    expect(screen.queryByRole('textbox')).not.toBeInTheDocument();

    expect(screen.queryByRole('textbox')).not.toBeInTheDocument();

    fireEvent.click(screen.getByRole('button', { name: 'Toggle hide' }));

    expect(screen.queryByRole('textbox')).not.toBeInTheDocument();

    expect(result.at(-1)).toEqual({ names: [] });

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(result).toEqual([
      {
        names: [
          {
            name: 'will',
          },
          {
            name: 'Mike',
          },
        ],
      },
      {
        names: [
          {
            name: 'will',
          },
          {
            name: 'Mike',
          },
        ],
      },
      {
        names: [],
      },
      {
        names: [],
      },
      {
        names: [],
      },
    ]);
  });

  it('should unregister field array when shouldUnregister set to true', () => {
    type FormValues = {
      test: {
        value: string;
      }[];
    };

    const watchedValues: FormValues[] = [];

    const Child = ({
      control,
      register,
    }: {
      show: boolean;
      control: Control<FormValues>;
      register: UseFormRegister<FormValues>;
    }) => {
      const { fields } = useFieldArray({
        control,
        name: 'test',
        shouldUnregister: true,
      });

      return (
        <>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
        </>
      );
    };

    const Component = () => {
      const { register, control, watch } = useForm<FormValues>({
        defaultValues: {
          test: [{ value: 'test' }, { value: 'test1' }],
        },
      });
      const [show, setShow] = React.useState(true);

      watchedValues.push(watch());

      return (
        <form>
          {show && <Child register={register} control={control} show={show} />}
          <button type="button" onClick={() => setShow(!show)}>
            toggle
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(watchedValues.at(-1)).toEqual({
      test: [{ value: 'test' }, { value: 'test1' }],
    });

    fireEvent.click(screen.getByRole('button'));

    expect(watchedValues.at(-1)).toEqual({});

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(watchedValues).toEqual([
      {
        test: [
          {
            value: 'test',
          },
          {
            value: 'test1',
          },
        ],
      },
      {
        test: [
          {
            value: 'test',
          },
          {
            value: 'test1',
          },
        ],
      },
      {},
    ]);
  });

  it('should keep field values when field array gets unmounted and mounted', async () => {
    type FormValues = {
      test: { firstName: string }[];
    };

    const Test = ({
      register,
      control,
    }: {
      register: UseFormRegister<FormValues>;
      control: Control<FormValues>;
    }) => {
      const { fields, append } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <div>
          {fields.map((field, i) => {
            return (
              <input
                key={field.id}
                {...register(`test.${i}.firstName` as const)}
              />
            );
          })}
          <button
            onClick={() =>
              append({
                firstName: 'test',
              })
            }
          >
            append
          </button>
        </div>
      );
    };

    const App = () => {
      const { control, register } = useForm<FormValues>();
      const [show, setShow] = React.useState(true);

      return (
        <>
          {show && <Test control={control} register={register} />}
          <button onClick={() => setShow(!show)}>show</button>
        </>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'show' }));

    expect(screen.queryByRole('textbox')).not.toBeInTheDocument();

    fireEvent.click(screen.getByRole('button', { name: 'show' }));

    expect(screen.getAllByRole('textbox').length).toEqual(2);
  });

  it('should append deep nested field array correctly with strict mode', async () => {
    function App() {
      const { control, register, handleSubmit } = useForm<{
        test: {
          yourDetail: {
            firstName: string;
            lastName: string;
          };
        }[];
      }>();
      const { fields, append } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <React.StrictMode>
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input {...register(`test.${index}.yourDetail.firstName`)} />
                  <input {...register(`test.${index}.yourDetail.lastName`)} />
                </div>
              );
            })}
            <button
              type="button"
              onClick={() =>
                append({
                  yourDetail: {
                    firstName: 'bill',
                    lastName: 'luo',
                  },
                })
              }
            >
              Append
            </button>
            <input type="submit" />
          </form>
        </React.StrictMode>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'Append' }));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('bill');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('luo');
  });

  it('should not populate defaultValue when field array is already mounted', async () => {
    type FormValues = {
      root: {
        test: string;
        children: { name: string }[];
      }[];
    };

    const Child = ({
      control,
      index,
      register,
    }: {
      control: Control<FormValues>;
      index: number;
      register: UseFormRegister<FormValues>;
    }) => {
      const { fields, append } = useFieldArray({
        name: `root.${index}.children`,
        control,
      });

      return (
        <div>
          {fields.map((field, k) => {
            return (
              <div key={field.id}>
                <input {...register(`root.${index}.children.${k}.name`)} />
              </div>
            );
          })}

          <button
            onClick={() => {
              append({
                name: 'test',
              });
            }}
          >
            append
          </button>
        </div>
      );
    };

    const App = () => {
      const { register, control } = useForm<FormValues>({
        defaultValues: {
          root: [
            {
              test: 'default',
              children: [
                {
                  name: 'child of index 0',
                },
              ],
            },
            {
              test: 'default1',
              children: [],
            },
          ],
        },
      });
      const { fields, swap } = useFieldArray({
        control,
        name: 'root',
      });

      return (
        <div>
          {fields.map((field, index) => {
            return (
              <div key={field.id}>
                <input {...register(`root.${index}.test` as const)} />
                <Child control={control} register={register} index={index} />
              </div>
            );
          })}
          <button
            type={'button'}
            onClick={() => {
              swap(0, 1);
            }}
          >
            swap
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'swap' }));

    fireEvent.click(screen.getAllByRole('button', { name: 'append' })[0]);

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('default1');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('test');
    expect(
      (screen.getAllByRole('textbox')[2] as HTMLInputElement).value,
    ).toEqual('default');
    expect(
      (screen.getAllByRole('textbox')[3] as HTMLInputElement).value,
    ).toEqual('child of index 0');
  });

  it('should update field array correctly when unmounted field', () => {
    type FormValues = {
      nest: {
        value: string;
        nested: {
          value: string;
        }[];
      }[];
    };

    function Nested({
      control,
      register,
      index,
    }: {
      control: Control<FormValues>;
      register: UseFormRegister<FormValues>;
      index: number;
    }) {
      const { fields } = useFieldArray({
        control,
        name: `nest.${index}.nested`,
      });

      return (
        <>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`nest.${index}.nested.${i}.value`)}
            />
          ))}
        </>
      );
    }

    function App() {
      const { control, register, setValue, getValues } = useForm<FormValues>({
        defaultValues: {
          nest: [
            { value: '0', nested: [{ value: '0sub1' }, { value: '0sub2' }] },
            { value: '1', nested: [{ value: '1sub1' }, { value: '1sub2' }] },
            { value: '2', nested: [{ value: '2sub1' }, { value: '2sub2' }] },
          ],
        },
      });
      const { fields, remove } = useFieldArray({
        control,
        name: 'nest',
      });

      function handleAddInner() {
        setValue(`nest.1.nested`, [
          ...getValues(`nest.1.nested`),
          { value: `1sub-new` },
        ]);
      }

      return (
        <>
          {fields.map((field, index) => (
            <div key={field.id}>
              <input {...register(`nest.${index}.value`)} />
              <button type={'button'} onClick={() => remove(index)}>
                remove{index}
              </button>
              <Nested index={index} {...{ control, register }} />
            </div>
          ))}

          <button onClick={handleAddInner}>set</button>
        </>
      );
    }

    render(<App />);

    expect(screen.getAllByRole('textbox').length).toEqual(9);

    fireEvent.click(screen.getByRole('button', { name: 'remove1' }));

    expect(screen.getAllByRole('textbox').length).toEqual(6);

    fireEvent.click(screen.getByRole('button', { name: 'set' }));

    expect(screen.getAllByRole('textbox').length).toEqual(7);
    expect(
      (screen.getAllByRole('textbox')[6] as HTMLInputElement).value,
    ).toEqual('1sub-new');
  });

  it('should update field array correctly with async invocation', async () => {
    type FormValues = {
      items: { id: string; name: string }[];
    };

    let controlObj: any = {};

    const App = () => {
      const { register, control } = useForm<FormValues>({
        mode: 'onChange',
        defaultValues: {
          items: [{ name: 'one' }, { name: 'two' }],
        },
      });

      controlObj = control;

      const { fields, remove, insert } = useFieldArray({
        control,
        name: 'items',
      });

      return (
        <form>
          {fields.map((field, index) => {
            return (
              <div key={field.id}>
                <button
                  type="button"
                  onClick={() => {
                    setTimeout(() => {
                      remove(index);
                    });
                  }}
                >
                  remove
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setTimeout(() => {
                      insert(index + 1, {
                        name: 'test',
                        id: '',
                      });
                    });
                  }}
                >
                  copy
                </button>
                <input
                  {...register(`items.${index}.name` as const, {
                    required: true,
                  })}
                />
              </div>
            );
          })}
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getAllByRole('button', { name: 'copy' })[0]);

    fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[0]);

    expect(controlObj._fields.items.length).toEqual(2);
  });

  it('should avoid omit keyName when defaultValues contains keyName attribute', () => {
    let getValuesMethod: Function = noop;

    const App = () => {
      const { control, getValues } = useForm({
        defaultValues: {
          test: [{ id: '1234', test: 'data' }],
        },
      });

      getValuesMethod = getValues;

      useFieldArray({
        control,
        name: 'test',
      });

      return null;
    };

    render(<App />);

    expect(getValuesMethod()).toEqual({
      test: [{ id: '1234', test: 'data' }],
    });
  });

  describe('with rules', () => {
    it('should validate the minLength of the entire field array after submit and correct accordingly', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
        } = useForm({
          defaultValues: {
            test: [{ test: '' }],
          },
        });

        const { append } = useFieldArray({
          control,
          name: 'test',
          rules: {
            minLength: {
              value: 2,
              message: 'Min length should be 2',
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
            <button
              type={'button'}
              onClick={() => {
                append({
                  test: '',
                });
              }}
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'submit' }));
      });

      screen.getByText('Min length should be 2');

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      expect(screen.queryByAltText('Min length should be 2')).toBeNull();
    });

    it('should validate with custom validation after submit and correct accordingly', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
        } = useForm({
          defaultValues: {
            test: [{ test: '' }],
          },
        });

        const { append } = useFieldArray({
          control,
          name: 'test',
          rules: {
            validate: (values) => {
              if (Array.isArray(values) && values.length < 2) {
                return 'Min length should be 2';
              }

              return true;
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
            <button
              type={'button'}
              onClick={() => {
                append({
                  test: '',
                });
              }}
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'submit' }));
      });

      screen.getByText('Min length should be 2');

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      expect(screen.queryByAltText('Min length should be 2')).toBeNull();
    });

    it('should validate the maxLength of the entire field array after submit and correct accordingly', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
        } = useForm({
          defaultValues: {
            test: [{ test: '' }, { test: '' }, { test: '' }, { test: '' }],
          },
        });

        const { remove } = useFieldArray({
          control,
          name: 'test',
          rules: {
            maxLength: {
              value: 2,
              message: 'Max length should be 2',
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
            <button
              type={'button'}
              onClick={() => {
                remove();
              }}
            >
              remove
            </button>
          </form>
        );
      };

      render(<App />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'submit' }));
      });

      screen.getByText('Max length should be 2');

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'remove' }));
      });

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();
    });

    it('should respect the validation mode and trigger validation after each field array action', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
        } = useForm({
          defaultValues: {
            test: [{ test: '' }, { test: '' }, { test: '' }, { test: '' }],
          },
          mode: 'onChange',
        });

        const { remove, append } = useFieldArray({
          control,
          name: 'test',
          rules: {
            maxLength: {
              value: 2,
              message: 'Max length should be 2',
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
            <button
              type={'button'}
              onClick={() => {
                remove();
              }}
            >
              remove
            </button>

            <button
              type={'button'}
              onClick={() => {
                append({
                  test: '',
                });
              }}
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      screen.getByText('Max length should be 2');

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'remove' }));
      });

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();
    });

    it('should not conflict with field level error', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
          register,
        } = useForm({
          defaultValues: {
            test: [{ test: '' }, { test: '' }, { test: '' }, { test: '' }],
          },
          mode: 'onChange',
        });

        const { remove, append, fields } = useFieldArray({
          control,
          name: 'test',
          rules: {
            maxLength: {
              value: 2,
              message: 'Max length should be 2',
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input
                    {...register(`test.${index}.test`, {
                      required: 'This is required',
                    })}
                  />
                  <p>{errors.test?.[index]?.test?.message}</p>
                </div>
              );
            })}
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
            <button
              type={'button'}
              onClick={() => {
                remove();
              }}
            >
              remove
            </button>

            <button
              type={'button'}
              onClick={() => {
                append({
                  test: '',
                });
              }}
            >
              append
            </button>
          </form>
        );
      };

      render(<App />);

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();
      expect(screen.queryByAltText('This is required')).toBeNull();

      await act(async () => {
        fireEvent.change(screen.getAllByRole('textbox')[0], {
          target: {
            value: '1',
          },
        });
      });

      await act(async () => {
        fireEvent.change(screen.getAllByRole('textbox')[0], {
          target: {
            value: '',
          },
        });
      });

      screen.getByText('This is required');

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'remove' }));
      });

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();
    });

    it('should not throw error when required is not defined but minLength', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
          register,
        } = useForm<{ test: { test: string }[] }>({
          defaultValues: {
            test: [],
          },
        });

        const { fields } = useFieldArray({
          control,
          name: 'test',
          rules: {
            maxLength: {
              value: 2,
              message: 'Max length should be 2',
            },
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input
                    {...register(`test.${index}.test`, {
                      required: 'This is required',
                    })}
                  />
                  <p>{errors.test?.[index]?.test?.message}</p>
                </div>
              );
            })}
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
          </form>
        );
      };

      render(<App />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button'));
      });

      expect(screen.queryByAltText('Max length should be 2')).toBeNull();
    });

    it('should throw error when required is defined', async () => {
      const App = () => {
        const {
          control,
          handleSubmit,
          formState: { errors },
          register,
        } = useForm<{ test: { test: string }[] }>({
          defaultValues: {
            test: [],
          },
        });

        const { fields } = useFieldArray({
          control,
          name: 'test',
          rules: {
            required: 'Please enter some data',
          },
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input
                    {...register(`test.${index}.test`, {
                      required: 'This is required',
                    })}
                  />
                  <p>{errors.test?.[index]?.test?.message}</p>
                </div>
              );
            })}
            <p>{errors.test?.root?.message}</p>
            <button>submit</button>
          </form>
        );
      };

      render(<App />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button'));
      });

      expect(screen.queryByAltText('Please enter some data')).toBeNull();
    });
  });

  describe('with nested field array ', () => {
    type FormValues = {
      fieldArray: {
        value: string;
        nestedFieldArray: {
          value: string;
        }[];
      }[];
    };

    const ArrayField = ({
      arrayIndex,
      register,
      control,
    }: {
      arrayIndex: number;
      register: UseFormReturn<FormValues>['register'];
      arrayField: Partial<FieldValues>;
      control: Control<FormValues>;
    }) => {
      const { fields, append } = useFieldArray({
        name: `fieldArray.${arrayIndex}.nestedFieldArray` as const,
        control,
        rules: {
          required: 'This is required',
          minLength: {
            value: 3,
            message: 'Min length of 3',
          },
        },
      });

      return (
        <div>
          {fields.map((nestedField, index) => (
            <div key={nestedField.id}>
              <input
                {...register(
                  `fieldArray.${arrayIndex}.nestedFieldArray.${index}.value` as const,
                )}
              />
            </div>
          ))}
          <button
            type="button"
            onClick={() => {
              append({
                value:
                  `fieldArray.${arrayIndex}.nestedFieldArray.${fields.length}.value` as const,
              });
            }}
          >
            Add nested array
          </button>
        </div>
      );
    };

    it('should report field array error at the nested useFieldArray level when form submitted', async () => {
      const Component = () => {
        const {
          register,
          control,
          handleSubmit,
          formState: { errors },
        } = useForm<FormValues>();
        const { fields, append } = useFieldArray({
          name: 'fieldArray',
          control,
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <ArrayField
                    arrayIndex={index}
                    arrayField={field}
                    register={register}
                    control={control}
                  />
                  <p>
                    {errors?.fieldArray?.[0]?.nestedFieldArray?.root?.message}
                  </p>
                </div>
              );
            })}
            <button
              onClick={() =>
                append({
                  value: '',
                  nestedFieldArray: [],
                })
              }
              type={'button'}
            >
              append
            </button>
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'submit' }));
      });

      screen.getByText('This is required');
    });

    it('should report field array error at the nested useFieldArray level during field level action', async () => {
      const Component = () => {
        const {
          register,
          control,
          handleSubmit,
          formState: { errors },
        } = useForm<FormValues>({
          mode: 'onChange',
        });
        const { fields, append } = useFieldArray({
          name: 'fieldArray',
          control,
        });

        return (
          <form onSubmit={handleSubmit(noop)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <ArrayField
                    arrayIndex={index}
                    arrayField={field}
                    register={register}
                    control={control}
                  />
                  <p>
                    {errors?.fieldArray?.[0]?.nestedFieldArray?.root?.message}
                  </p>
                </div>
              );
            })}
            <button
              onClick={() =>
                append({
                  value: '',
                  nestedFieldArray: [],
                })
              }
              type={'button'}
            >
              append
            </button>
            <button>submit</button>
          </form>
        );
      };

      render(<Component />);

      await act(async () => {
        fireEvent.click(screen.getByRole('button', { name: 'append' }));
      });

      await act(async () => {
        fireEvent.click(
          screen.getByRole('button', { name: 'Add nested array' }),
        );
      });

      screen.getByText('Min length of 3');
    });
  });

  it('should update isValid correctly with rules props and inline validation', async () => {
    const App = () => {
      const {
        control,
        register,
        formState: { isValid },
      } = useForm({
        defaultValues: {
          test: [{ value: '1' }],
        },
      });
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
        rules: {
          required: true,
        },
      });

      return (
        <div>
          {fields.map((field, index) => (
            <input
              key={field.id}
              {...register(`test.${index}.value`, { required: true })}
            />
          ))}

          <button
            onClick={() =>
              append({
                value: '',
              })
            }
          >
            Append
          </button>

          <p>{isValid ? 'valid' : 'invalid'}</p>
        </div>
      );
    };

    render(<App />);

    await waitFor(() => {
      screen.getByText('valid');
    });

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('invalid');
    });
  });

  describe('with formState observers', () => {
    it('should trigger reRender when user subscribes to root formState', async () => {
      type FormValues = { test: { value: string }[] };

      const FieldArray = ({
        register,
        control,
      }: {
        register: UseFormRegister<FormValues>;
        control: Control<FormValues>;
      }) => {
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button type="button" onClick={() => append({ value: '' })}>
              append
            </button>
          </>
        );
      };

      let renderCount = 0;
      const Component = () => {
        const { register, control, formState } = useForm<FormValues>();

        formState.isDirty;
        formState.dirtyFields;
        formState.errors;

        renderCount++;

        return (
          <form>
            <FieldArray register={register} control={control} />
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: /append/i }));
      await waitFor(() => expect(renderCount).toEqual(2));
    });

    it('should trigger reRender on components that subscribe to useFieldArray fieldState', async () => {
      type FormValues = { test: { value: string }[] };
      let rootRenderCount = 0;
      let observerRenderCount = 0;

      const FieldArray = ({
        register,
        control,
      }: {
        register: UseFormRegister<FormValues>;
        control: Control<FormValues>;
      }) => {
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button type="button" onClick={() => append({ value: '' })}>
              append
            </button>
          </>
        );
      };

      const Observer = ({ control }: { control: Control<FormValues> }) => {
        const { isDirty, dirtyFields, errors } = useFormState({
          name: 'test',
          control,
        });

        observerRenderCount++;

        return <p>{JSON.stringify({ isDirty, dirtyFields, errors })}</p>;
      };

      const Component = () => {
        const { register, control } = useForm<FormValues>();

        rootRenderCount++;

        return (
          <form>
            <FieldArray register={register} control={control} />
            <Observer control={control} />
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: /append/i }));

      await waitFor(() => {
        expect(rootRenderCount).toEqual(1);
        expect(observerRenderCount).toEqual(2);
      });
    });

    it('should unmount field array and remove its reference with shouldUnregister: true', () => {
      type FormValues = {
        type: string;
        array: {
          data: string;
        }[];
      };

      let array: { data: string }[] = [];

      function FieldArray({ control }: { control: Control<FormValues> }) {
        useFieldArray({
          name: 'array' as const,
          control,
          shouldUnregister: true,
        });
        return null;
      }

      function App() {
        const methods = useForm({
          defaultValues: {
            type: 'NO_CART',
            array: [],
          },
          shouldUnregister: true,
        });
        const [toggle, setToggle] = useState(false);
        const { control, watch } = methods;
        array = watch('array');

        return (
          <>
            <button onClick={() => setToggle(!toggle)} />
            <form>{toggle && <FieldArray control={control} />}</form>
          </>
        );
      }

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(array).toEqual([]);

      fireEvent.click(screen.getByRole('button'));

      expect(array).toBeUndefined();
    });

    it('should not trigger reRender on components that do not subscribe to useFieldArray fieldState', async () => {
      type FormValues = { test: { value: string }[]; other: string };
      let rootRenderCount = 0;
      let notObserverRenderCount = 0;

      const FieldArray = ({
        register,
        control,
      }: {
        register: UseFormRegister<FormValues>;
        control: Control<FormValues>;
      }) => {
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <>
            {fields.map((field, i) => (
              <input key={field.id} {...register(`test.${i}.value` as const)} />
            ))}
            <button type="button" onClick={() => append({ value: '' })}>
              append
            </button>
          </>
        );
      };

      const NotObserver = ({ control }: { control: Control<FormValues> }) => {
        const { isDirty, dirtyFields, errors } = useFormState({
          name: 'other',
          control,
        });

        notObserverRenderCount++;

        return <p>{JSON.stringify({ isDirty, dirtyFields, errors })}</p>;
      };

      const Component = () => {
        const { register, control } = useForm<FormValues>();

        rootRenderCount++;

        return (
          <form>
            <FieldArray register={register} control={control} />
            <NotObserver control={control} />
            <input {...register('other')} />
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: /append/i }));

      expect(rootRenderCount).toEqual(1);
      expect(notObserverRenderCount).toEqual(1);
    });
  });
});


================================================
File: /src/__tests__/useWatch.test.tsx
================================================
import React from 'react';
import {
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
  within,
} from '@testing-library/react';

import {
  Control,
  UseFieldArrayReturn,
  UseFormRegister,
  UseFormReturn,
} from '../types';
import { useController } from '../useController';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { FormProvider, useFormContext } from '../useFormContext';
import { useWatch } from '../useWatch';
import noop from '../utils/noop';

let i = 0;

jest.mock('../logic/generateId', () => () => String(i++));

describe('useWatch', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should return default value in useForm', () => {
    let method;
    let watched;
    const Component = () => {
      method = useForm<{ test: string }>({ defaultValues: { test: 'test' } });
      watched = useWatch({ control: method.control });
      return <div />;
    };
    render(<Component />);

    expect(watched).toEqual({ test: 'test' });
  });

  it('should return default value in useWatch', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string }>({
        defaultValues: {
          test: 'test',
        },
      });
      return useWatch({
        control,
        name: 'test',
      });
    });

    expect(result.current).toEqual('test');
  });

  it('should return default value for single input', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string; test1: string }>({
        defaultValues: {
          test: 'test',
          test1: 'test1',
        },
      });
      return useWatch({
        control,
        name: 'test',
      });
    });

    expect(result.current).toEqual('test');
  });

  it('should return default values for array of inputs', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string; test1: string }>({
        defaultValues: {
          test: 'test',
          test1: 'test1',
        },
      });
      return useWatch({
        control,
        name: ['test', 'test1'],
      });
    });

    expect(result.current).toEqual(['test', 'test1']);
  });

  it('should return own default value for single input', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string; test1: string }>({});
      return useWatch({
        control,
        name: 'test',
        defaultValue: 'test',
      });
    });

    expect(result.current).toEqual('test');
  });

  it('should return own default value for array of inputs', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string; test1: string }>({});
      return useWatch({
        control,
        name: ['test', 'test1'],
        defaultValue: {
          test: 'test',
          test1: 'test1',
        },
      });
    });

    expect(result.current).toEqual(['test', 'test1']);
  });

  it('should return default value when name is undefined', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string; test1: string }>({
        defaultValues: {
          test: 'test',
          test1: 'test1',
        },
      });
      return useWatch({
        control,
      });
    });

    expect(result.current).toEqual({ test: 'test', test1: 'test1' });
  });

  it('should return empty array when watch array fields', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string }>();
      return useWatch({
        control,
        name: ['test'],
      });
    });

    expect(result.current).toEqual([undefined]);
  });

  it('should return undefined', () => {
    const { result } = renderHook(() => {
      const { control } = useForm<{ test: string }>();
      return useWatch({
        control,
        name: 'test',
      });
    });

    expect(result.current).toBeUndefined();
  });

  it('should render with FormProvider', () => {
    const Provider = ({ children }: { children: React.ReactNode }) => {
      const methods = useForm<{ test: string }>();
      return <FormProvider {...methods}>{children}</FormProvider>;
    };
    expect(() =>
      renderHook(() => useWatch({ name: 'test' }), {
        wrapper: Provider,
      }),
    ).not.toThrow();
  });

  it('should remove input with shouldUnregister: true and deeply nested', async () => {
    type FormValue = {
      test: string;
    };

    let submitData = {};

    const Child = ({
      control,
      register,
    }: {
      register: UseFormRegister<FormValue>;
      control: Control<FormValue>;
    }) => {
      const show = useWatch({
        control,
        name: 'test',
      });

      return <>{show && show !== 'test' && <input {...register('test')} />}</>;
    };

    const Component = () => {
      const { register, control, handleSubmit } = useForm<FormValue>({
        defaultValues: {
          test: 'bill',
        },
        shouldUnregister: true,
      });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            submitData = data;
          })}
        >
          <Child control={control} register={register} />
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(submitData).toEqual({});
  });

  it('should return defaultValue with shouldUnregister set to true and keepDefaultValues', () => {
    const output: unknown[] = [];

    function App() {
      const { register, reset, control } = useForm({
        defaultValues: { test: 'test' },
        shouldUnregister: true,
      });
      const inputs = useWatch({ control });

      output.push(inputs);

      return (
        <form>
          <input {...register('test')} />
          <button
            type="button"
            onClick={() => reset(undefined, { keepDefaultValues: true })}
          >
            Reset
          </button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'test' },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(output).toEqual([
      { test: 'test' },
      { test: 'test' },
      { test: 'test' },
      { test: 'test' },
      { test: 'test' },
    ]);
  });

  it('should subscribe to exact input change', () => {
    const App = () => {
      const { control, register } = useForm();
      const value = useWatch({
        name: 'test',
        control,
        exact: true,
        defaultValue: 'test',
      });

      return (
        <div>
          <input {...register('test.0.data')} />
          <p>{value}</p>
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1234',
      },
    });

    expect(screen.getByText('test')).toBeVisible();
  });

  it('should return root object subscription', () => {
    function App() {
      const { register, control } = useForm({
        defaultValues: { field: { firstName: 'value' } },
      });
      const field = useWatch({ control, name: 'field' });

      return (
        <div>
          <form>
            <input {...register('field.firstName')} placeholder="First Name" />
            <p>{field.firstName}</p>
          </form>
        </div>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '123',
      },
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '234',
      },
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '345',
      },
    });

    expect(screen.getByText('345')).toBeVisible();
  });

  describe('when disabled prop is used', () => {
    it('should be able to disabled subscription and started with true', async () => {
      type FormValues = {
        test: string;
      };

      const ChildComponent = ({
        control,
      }: {
        control: Control<FormValues>;
      }) => {
        const [disabled, setDisabled] = React.useState(true);
        const test = useWatch({
          control,
          name: 'test',
          disabled,
        });

        return (
          <div>
            <p>{test}</p>
            <button
              onClick={() => {
                setDisabled(!disabled);
              }}
              type={'button'}
            >
              toggle
            </button>
          </div>
        );
      };

      const App = () => {
        const { register, control } = useForm<FormValues>({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <div>
            <input {...register('test')} />
            <ChildComponent control={control} />
          </div>
        );
      };

      render(<App />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'what',
        },
      });

      expect(screen.getByText('test')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'what12345',
        },
      });

      expect(screen.getByText('what12345')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: '12345',
        },
      });

      expect(screen.getByText('what12345')).toBeVisible();
    });

    it('should be able to toggle the subscription and started with false', async () => {
      type FormValues = {
        test: string;
      };

      const ChildComponent = ({
        control,
      }: {
        control: Control<FormValues>;
      }) => {
        const [disabled, setDisabled] = React.useState(false);
        const test = useWatch({
          control,
          name: 'test',
          disabled,
        });

        return (
          <div>
            <p>{test}</p>
            <button
              onClick={() => {
                setDisabled(!disabled);
              }}
              type={'button'}
            >
              toggle
            </button>
          </div>
        );
      };

      const WatchApp = () => {
        const { register, control } = useForm<FormValues>({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <div>
            <input {...register('test')} />
            <ChildComponent control={control} />
          </div>
        );
      };

      render(<WatchApp />);

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'what',
        },
      });

      expect(screen.getByText('what')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      fireEvent.change(screen.getByRole('textbox'), {
        target: {
          value: 'what12345',
        },
      });

      expect(screen.getByText('what')).toBeVisible();
    });
  });

  describe('update', () => {
    it('should partial re-render', async () => {
      type FormInputs = {
        child: string;
        parent: string;
      };

      let childCount = 0;
      const Child = ({
        register,
        control,
      }: Pick<UseFormReturn<FormInputs>, 'register' | 'control'>) => {
        useWatch({ name: 'child', control });
        childCount++;
        return <input {...register('child')} />;
      };

      let parentCount = 0;
      const Parent = () => {
        const {
          register,
          handleSubmit,
          control,
          formState: { errors },
        } = useForm<FormInputs>();
        parentCount++;
        return (
          <form onSubmit={handleSubmit(noop)}>
            <>
              <input {...register('parent')} />
              <Child register={register} control={control} />
              {errors.parent}
              <button>submit</button>
            </>
          </form>
        );
      };

      render(<Parent />);

      const childInput = screen.getAllByRole('textbox')[1];

      fireEvent.input(childInput, {
        target: { value: 'test' },
      });

      expect(parentCount).toBe(1);
      expect(childCount).toBe(2);

      parentCount = 0;
      childCount = 0;

      fireEvent.submit(screen.getByRole('button', { name: /submit/i }));

      await waitFor(() => expect(parentCount).toBe(1));
      expect(childCount).toBe(1);

      parentCount = 0;
      childCount = 0;

      fireEvent.input(childInput, { target: { value: 'test1' } });

      expect(parentCount).toBe(0);
      expect(childCount).toBe(1);
    });

    it('should partial re-render with array name and exact option', async () => {
      type FormInputs = {
        child: string;
        childSecond: string;
        parent: string;
      };

      let childCount = 0;
      let childSecondCount = 0;
      const Child = ({
        register,
        control,
      }: Pick<UseFormReturn<FormInputs>, 'register' | 'control'>) => {
        useWatch({ name: ['childSecond'], control });
        childCount++;
        return <input {...register('child')} />;
      };

      const ChildSecond = ({
        register,
        control,
      }: Pick<UseFormReturn<FormInputs>, 'register' | 'control'>) => {
        useWatch({ name: ['childSecond'], control, exact: true });
        childSecondCount++;
        return <input {...register('childSecond')} />;
      };

      let parentCount = 0;
      const Parent = () => {
        const {
          register,
          handleSubmit,
          control,
          formState: { errors },
        } = useForm<FormInputs>();
        parentCount++;
        return (
          <form onSubmit={handleSubmit(noop)}>
            <>
              <input {...register('parent')} />
              <Child register={register} control={control} />
              <ChildSecond register={register} control={control} />
              {errors.parent}
              <button>submit</button>
            </>
          </form>
        );
      };

      render(<Parent />);

      const childInput = screen.getAllByRole('textbox')[1];
      const childSecondInput = screen.getAllByRole('textbox')[2];

      fireEvent.input(childInput, {
        target: { value: 'test' },
      });

      expect(parentCount).toBe(1);
      expect(childCount).toBe(2);
      expect(childSecondCount).toBe(1);

      parentCount = 0;
      childCount = 0;
      childSecondCount = 0;

      fireEvent.submit(screen.getByRole('button', { name: /submit/i }));

      await waitFor(() => expect(parentCount).toBe(1));
      expect(childCount).toBe(1);
      expect(childSecondCount).toBe(1);

      parentCount = 0;
      childCount = 0;
      childSecondCount = 0;

      fireEvent.input(childInput, { target: { value: 'test1' } });

      expect(parentCount).toBe(0);
      expect(childCount).toBe(1);
      expect(childSecondCount).toBe(0);

      parentCount = 0;
      childCount = 0;
      childSecondCount = 0;

      fireEvent.input(childSecondInput, { target: { value: 'test2' } });

      expect(parentCount).toBe(0);
      expect(childCount).toBe(1);
      expect(childSecondCount).toBe(1);
    });

    it('should only subscribe change at useWatch level instead of useForm', () => {
      type FormValues = {
        test: string;
        test1: string;
        test2: string;
      };

      let parentRenderCount = 0;
      let childRenderCount = 0;

      const Test = ({ control }: { control: Control<FormValues> }) => {
        useWatch({
          control,
        });

        childRenderCount++;

        return <div>test</div>;
      };

      const Component = () => {
        const { control, register } = useForm<FormValues>();

        parentRenderCount++;

        return (
          <div>
            <Test control={control} />
            <input {...register('test')} />
            <input {...register('test1')} />
            <input {...register('test2')} />
          </div>
        );
      };

      render(<Component />);

      fireEvent.change(screen.getAllByRole('textbox')[0], {
        target: {
          value: '1234',
        },
      });

      fireEvent.change(screen.getAllByRole('textbox')[1], {
        target: {
          value: '1234',
        },
      });

      fireEvent.change(screen.getAllByRole('textbox')[2], {
        target: {
          value: '1234',
        },
      });

      expect(parentRenderCount).toEqual(1);
      expect(childRenderCount).toEqual(4);
    });

    it("should not re-render external component when field name don't match", async () => {
      type FormInputs = { test1: string; test2: string };

      const Child = ({ control }: { control: Control<FormInputs> }) => {
        useWatch({ name: 'test2', control });

        return <div />;
      };

      const Parent = () => {
        const { register, control } = useForm<FormInputs>();
        useWatch({ name: 'test1', control });

        return (
          <form>
            <input {...register('test1')} />
            <input {...register('test2')} />
            <Child control={control} />
          </form>
        );
      };

      render(<Parent />);

      fireEvent.input(screen.getAllByRole('textbox')[1], {
        target: {
          name: 'test2',
          value: 'value',
        },
      });
    });

    it('should not throw error when null or undefined is set', () => {
      const watchedValue: Record<string, any> = {};
      const Component = () => {
        const { register, control } = useForm<{
          test: string;
          test1: string;
        }>();

        register('test');
        register('test1');

        watchedValue['test'] = useWatch({ name: 'test', control });
        watchedValue['test1'] = useWatch({ name: 'test1', control });

        return <div />;
      };

      render(<Component />);

      expect(watchedValue).toEqual({ test: undefined, test1: undefined });
    });

    it('should return undefined when input gets unregistered', async () => {
      const Component = () => {
        const { register, control, unregister } = useForm<{ test: number }>();
        const [show, setShow] = React.useState(true);
        const data: any = useWatch({ name: 'test', control });

        return (
          <>
            {show && <input {...register('test')} />}
            <span>{data}</span>
            <button
              type="button"
              onClick={() => {
                unregister('test');
                setShow(false);
              }}
            >
              hide
            </button>
          </>
        );
      };

      render(<Component />);

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      expect(screen.getByText('test')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(screen.queryByText('test')).not.toBeInTheDocument();
    });

    it('should return undefined when input get unregistered', () => {
      type FormValues = {
        test: string;
      };

      const Test = ({ control }: { control: Control<FormValues> }) => {
        const value = useWatch({
          control,
          name: 'test',
        });

        return <div>{value === undefined ? 'yes' : 'no'}</div>;
      };

      const Component = () => {
        const { register, control, unregister } = useForm<FormValues>({
          defaultValues: {
            test: 'test',
          },
        });

        React.useEffect(() => {
          register('test');
        }, [register]);

        return (
          <>
            <Test control={control} />
            <button onClick={() => unregister('test')}>unregister</button>
          </>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      expect(screen.getByText('yes')).toBeVisible();
    });
  });

  describe('fieldArray', () => {
    it('should watch correct input update with single field array input', () => {
      const inputValues: string[] = [];

      type FormValues = {
        labels: {
          displayName: string;
          internalName: string;
        }[];
      };

      function Item({
        control,
        register,
        itemIndex,
        remove,
      }: {
        control: Control<FormValues>;
        register: UseFormReturn<FormValues>['register'];
        remove: UseFieldArrayReturn['remove'];
        itemIndex: number;
      }) {
        const actualValue = useWatch({
          control,
          name: `labels.${itemIndex}.displayName` as const,
        });
        inputValues.push(actualValue);

        return (
          <div>
            <input
              {...register(`labels.${itemIndex}.displayName` as const)}
              defaultValue={actualValue}
            />
            <button type="button" onClick={() => remove(itemIndex)}>
              Remove
            </button>
          </div>
        );
      }

      const Component = () => {
        const { control, register } = useForm<FormValues>({
          defaultValues: {
            labels: [
              {
                displayName: 'Type',
                internalName: 'type',
              },
              {
                displayName: 'Number',
                internalName: 'number',
              },
              {
                displayName: 'Totals',
                internalName: 'totals',
              },
            ],
          },
        });

        const { fields, remove } = useFieldArray({
          control,
          name: 'labels',
        });

        return (
          <form>
            {fields.map((item, itemIndex) => (
              <Item
                key={item.id}
                control={control}
                register={register}
                itemIndex={itemIndex}
                remove={remove}
              />
            ))}
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getAllByRole('button')[1]);

      expect(inputValues).toEqual([
        'Type',
        'Number',
        'Totals',
        'Type',
        'Totals',
        'Type',
        'Totals',
      ]);
    });

    it('should return shallow merged watch values', () => {
      const watchedValue: unknown[] = [];

      function App() {
        const methods = useForm({
          defaultValues: {
            name: 'foo',
            arr: [],
          },
          mode: 'onSubmit',
          reValidateMode: 'onChange',
          criteriaMode: 'all',
          shouldUnregister: false,
        });

        return (
          <FormProvider {...methods}>
            <input {...methods.register('name')} placeholder="First Name" />
            <Preview />
            <FieldArray />
            <input type="submit" />
          </FormProvider>
        );
      }

      function Preview() {
        const form = useWatch({});
        watchedValue.push(form);

        return null;
      }

      function FieldArray() {
        useFieldArray({
          name: 'arr',
          shouldUnregister: false,
        });

        return null;
      }

      render(<App />);

      expect(watchedValue).toEqual([
        {
          arr: [],
          name: 'foo',
        },
        {
          arr: [],
          name: 'foo',
        },
      ]);
    });
  });

  describe('fieldArray with shouldUnregister true', () => {
    it('should watch correct input update with single field array input', async () => {
      const watchData: unknown[] = [];

      type Unpacked<T> = T extends (infer U)[] ? U : T;

      type FormValues = {
        items: { prop: string }[];
      };

      function App() {
        const rhfProps = useForm<FormValues>({
          defaultValues: {
            items: [{ prop: 'test' }, { prop: 'test1' }],
          },
          shouldUnregister: true,
        });
        const { control } = rhfProps;

        const { fields, insert, remove } = useFieldArray({
          control,
          name: 'items',
        });

        return (
          <form>
            {fields.map((item, index) => {
              return (
                <div key={item.id}>
                  <Child control={control} index={index} itemDefault={item} />
                  <button
                    type="button"
                    onClick={() => {
                      insert(index + 1, { prop: 'ShouldBeTHere' });
                    }}
                  >
                    insert
                  </button>
                  <button
                    type="button"
                    onClick={() => {
                      remove(index);
                    }}
                  >
                    remove
                  </button>
                </div>
              );
            })}
            <Watcher itemsDefault={fields} control={control} />
            <input type="submit" />
          </form>
        );
      }

      function Watcher({
        itemsDefault,
        control,
      }: {
        itemsDefault: FormValues['items'];
        control: Control<FormValues>;
      }) {
        const useWatchedItems = useWatch({
          name: 'items',
          control,
          defaultValue: itemsDefault,
        });

        watchData.push(useWatchedItems);

        return (
          <div>
            {useWatchedItems.map((item, index) => {
              return (
                <p key={index}>
                  Value {index}: {item.prop}
                </p>
              );
            })}
          </div>
        );
      }

      function Child({
        index,
        itemDefault,
        control,
      }: {
        index: number;
        itemDefault: Unpacked<FormValues['items']>;
        control: Control<FormValues>;
      }) {
        const { field } = useController({
          name: `items.${index}.prop` as const,
          control,
          defaultValue: itemDefault.prop,
        });

        return <input {...field} />;
      }

      render(<App />);

      expect(screen.getByText('Value 0: test')).toBeVisible();
      expect(screen.getByText('Value 1: test1')).toBeVisible();
      expect(
        screen.queryByText('Value 1: ShouldBeTHere'),
      ).not.toBeInTheDocument();

      fireEvent.click(screen.getAllByRole('button', { name: 'insert' })[0]);

      expect(await screen.findByText('Value 1: ShouldBeTHere')).toBeVisible();
      expect(screen.getByText('Value 2: test1')).toBeVisible();

      fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[0]);

      expect(
        screen.queryByText('Value 2: ShouldBeTHere'),
      ).not.toBeInTheDocument();

      expect(watchData).toMatchSnapshot();
    });
  });

  describe('reset', () => {
    it('should return updated default value with watched field after reset', async () => {
      type FormValues = {
        test: string;
        name: string;
      };

      function Watcher({ control }: { control: Control<FormValues> }) {
        const testField = useWatch<FormValues>({
          name: 'test',
          control: control,
        });

        return <div>{testField}</div>;
      }

      function Component() {
        const { reset, control } = useForm<FormValues>({
          defaultValues: {
            test: '',
            name: '',
          },
        });

        React.useEffect(() => {
          reset({
            test: 'test',
          });
        }, [reset]);

        return <Watcher control={control} />;
      }

      render(<Component />);

      expect(await screen.findByText('test')).toBeVisible();
    });

    it('should return default value of reset method', async () => {
      const Component = () => {
        const { register, reset, control } = useForm<{
          test: string;
        }>();
        const test = useWatch<{
          test: string;
        }>({ name: 'test', control });

        React.useEffect(() => {
          reset({ test: 'default' });
        }, [reset]);

        return (
          <form>
            <input {...register('test')} />
            <span>{test}</span>
          </form>
        );
      };

      render(<Component />);

      expect(await screen.findByText('default')).toBeDefined();
    });

    it('should re-register watched input after reset', async () => {
      type FormValues = {
        firstName: string;
      };

      function LivePreview({ control }: { control: Control<FormValues> }) {
        const value = useWatch({
          name: `firstName`,
          defaultValue: 'yes',
          control,
        });

        return <p>{value}</p>;
      }

      const Component = () => {
        const formMethods = useForm<FormValues>();
        const { control, reset, register } = formMethods;

        React.useEffect(() => {
          reset({
            firstName: 'firstName',
          });
        }, [reset]);

        return (
          <>
            <input {...register('firstName')} />

            <LivePreview control={control} />
          </>
        );
      };

      render(<Component />);

      expect(screen.getByText('firstName')).toBeVisible();

      fireEvent.change(screen.getByRole('textbox'), {
        target: { value: '123' },
      });

      expect(screen.getByText('123')).toBeVisible();
    });

    it('should fallback to inline defaultValue with reset API', () => {
      const App = () => {
        const { control, reset } = useForm();
        const value = useWatch({
          name: 'test',
          defaultValue: 'yes',
          control,
        });

        React.useEffect(() => {
          reset({});
        }, [reset]);

        return <p>{value ? 'yes' : 'no'}</p>;
      };

      render(<App />);

      expect(screen.getByText('yes')).toBeVisible();
    });

    describe('with useFieldArray', () => {
      // issue: https://github.com/react-hook-form/react-hook-form/issues/2229
      it('should return current value with radio type', () => {
        type FormValues = {
          options: { option: string }[];
        };
        const watchedValue: object[] = [];

        const Test = ({ control }: { control: Control<FormValues> }) => {
          const values = useWatch({ control });
          const options = values.options;
          watchedValue.push(values);

          return (
            <div>
              <p>First: {options?.[0].option}</p>
              <p>Second: {options?.[1].option}</p>
            </div>
          );
        };

        const Component = () => {
          const { register, reset, control } = useForm<FormValues>();
          const { fields } = useFieldArray({ name: 'options', control });

          React.useEffect(() => {
            reset({
              options: [
                {
                  option: 'yes',
                },
                {
                  option: 'yes',
                },
              ],
            });
          }, [reset]);

          return (
            <form>
              {fields.map((_, i) => (
                <div key={i.toString()} data-testid={`field-${i}`}>
                  <label>
                    Yes
                    <input
                      type="radio"
                      value="yes"
                      {...register(`options.${i}.option` as const)}
                    />
                  </label>
                  <label>
                    No
                    <input
                      type="radio"
                      value="no"
                      {...register(`options.${i}.option` as const)}
                    />
                  </label>
                </div>
              ))}
              <Test control={control} />
            </form>
          );
        };

        render(<Component />);

        const firstField = screen.getByTestId('field-0');
        expect(within(firstField).getByLabelText('Yes')).toBeChecked();
        expect(screen.getByText('First: yes')).toBeVisible();

        const secondField = screen.getByTestId('field-1');
        expect(within(secondField).getByLabelText('Yes')).toBeChecked();
        expect(screen.getByText('Second: yes')).toBeVisible();

        fireEvent.click(within(firstField).getByLabelText('No'));

        expect(screen.getByText('First: no')).toBeVisible();
        expect(screen.getByText('Second: yes')).toBeVisible();

        // Let's check all values of renders with implicitly the number of render (for each value)
        expect(watchedValue).toMatchSnapshot();
      });

      it("should watch item correctly with useFieldArray's remove method", async () => {
        let watchedValue: { [x: string]: any } | undefined;
        const Component = () => {
          const { register, control } = useForm<{
            test: {
              firstName: string;
              lsatName: string;
            }[];
          }>({
            defaultValues: {
              test: [{ firstName: 'test' }, { firstName: 'test1' }],
            },
          });
          const { fields, remove } = useFieldArray({
            name: 'test',
            control,
          });
          watchedValue = useWatch({
            name: 'test',
            control,
          });

          return (
            <form>
              {fields.map((item, i) => (
                <div key={item.firstName}>
                  <input
                    type="input"
                    defaultValue={item.firstName}
                    {...register(`test.${i}.firstName` as const)}
                  />

                  <button type="button" onClick={() => remove(i)}>
                    remove
                  </button>
                </div>
              ))}
            </form>
          );
        };

        render(<Component />);

        expect(watchedValue).toEqual([
          { firstName: 'test' },
          { firstName: 'test1' },
        ]);

        fireEvent.click(screen.getAllByRole('button')[0]);

        expect(watchedValue).toEqual([{ firstName: 'test1' }]);
      });
    });

    describe('with custom register', () => {
      it('should return default value of reset method when value is not empty', async () => {
        const Component = () => {
          const { register, reset, control } = useForm<{
            test: string;
          }>();
          const test = useWatch<{
            test: string;
          }>({
            name: 'test',
            control,
          });

          React.useEffect(() => {
            register('test');
          }, [register]);

          React.useEffect(() => {
            reset({ test: 'default1' });
          }, [reset]);

          return (
            <form>
              <input {...register('test')} />
              <span data-testid="result">{test}</span>
            </form>
          );
        };

        render(<Component />);

        expect((await screen.findByTestId('result')).textContent).toBe(
          'default1',
        );
      });

      it('should return default value of reset method', async () => {
        const Component = () => {
          const { register, reset, control } = useForm<{
            test: string;
          }>();
          const test = useWatch<{
            test: string;
          }>({ name: 'test', control });

          React.useEffect(() => {
            register('test');
          }, [register]);

          React.useEffect(() => {
            reset({ test: 'default' });
          }, [reset]);

          return (
            <form>
              <span>{test}</span>
            </form>
          );
        };

        render(<Component />);

        expect(await screen.findByText('default')).toBeDefined();
      });

      it('should return default value', async () => {
        const Component = () => {
          const { register, reset, control } = useForm<{ test: string }>({
            defaultValues: {
              test: 'test',
            },
          });
          const test = useWatch<{ test: string }>({
            name: 'test',
            control,
          });

          React.useEffect(() => {
            register('test');
          }, [register]);

          React.useEffect(() => {
            reset();
          }, [reset]);

          return (
            <form>
              <span>{test}</span>
            </form>
          );
        };

        render(<Component />);

        expect(await screen.findByText('test')).toBeDefined();
      });
    });
  });

  describe('unregister', () => {
    it('should return correct value after input get unregistered', async () => {
      type FormValues = { test: string };

      const Component = ({ control }: { control: Control<FormValues> }) => {
        const test = useWatch<{ test: string }>({ name: 'test', control });
        return <div>{test === undefined ? 'no' : test}</div>;
      };

      const Form = () => {
        const { control, unregister, register } = useForm<FormValues>({
          defaultValues: { test: 'test' },
        });

        return (
          <>
            <Component control={control} />
            <input {...register('test')} />
            <button onClick={() => unregister('test')}>unregister</button>
          </>
        );
      };

      render(<Form />);

      expect(screen.getByText('test')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(screen.getByText('no')).toBeVisible();
    });
  });

  describe('setValue', () => {
    it('should return correct value after input get unregistered', async () => {
      type FormValues = { test: string };

      const Child = ({ register }: UseFormReturn<FormValues>) => {
        return <input {...register('test')} />;
      };

      const Component = ({ control }: { control: Control<FormValues> }) => {
        const test = useWatch<{ test: string }>({ name: 'test', control });
        return <div>{test === 'bill' ? 'no' : test}</div>;
      };

      const Form = () => {
        const methods = useForm<FormValues>({
          defaultValues: { test: 'test' },
        });

        const { setValue } = methods;

        React.useEffect(() => {
          setValue('test', 'bill');
        }, [setValue]);

        return (
          <>
            <Component control={methods.control} />
            <Child {...methods} />
          </>
        );
      };

      render(<Form />);

      expect(await screen.findByText('no')).toBeVisible();
    });

    it('should keep set type after set value', async () => {
      const Form = () => {
        const { control, setValue } = useForm({
          defaultValues: { test: new Set(['test']) },
        });
        const { field } = useController({
          control,
          name: 'test',
        });

        React.useEffect(() => {
          setValue('test', new Set(['test']));
        }, [setValue]);

        return <>{field.value instanceof Set ? 'yes' : 'no'}</>;
      };

      render(<Form />);

      await waitFor(() => {
        screen.getByText('yes');
      });
    });

    it('should watch nested object field update', () => {
      interface FormData {
        one: {
          two: {
            dep: number;
          };
        };
      }

      const Component1 = () => {
        const watchedDep = useWatch({ name: 'one.two.dep' });
        return <p>{watchedDep}</p>;
      };

      const Component2 = () => {
        const { register, setValue } = useFormContext<FormData>();
        const field = register('one.two.dep');

        return (
          <>
            <input {...field} />
            <button
              onClick={() => {
                setValue('one.two', { dep: 333 });
              }}
            >
              set deep
            </button>
          </>
        );
      };

      const Component: React.FC = () => {
        const form = useForm<FormData>({
          defaultValues: {
            one: {
              two: {
                dep: 111,
              },
            },
          },
        });

        return (
          <>
            <FormProvider {...form}>
              <Component1 />
              <Component2 />
            </FormProvider>
          </>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      expect(screen.getByText('333')).toBeVisible();

      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        '333',
      );
    });
  });

  describe('formContext', () => {
    it('should work with form context', async () => {
      const Component = () => {
        const test = useWatch<{ test: string }>({ name: 'test' });
        return <div>{test}</div>;
      };

      const Form = () => {
        const methods = useForm<{ test: string }>({
          defaultValues: { test: 'test' },
        });

        return (
          <FormProvider {...methods}>
            <Component />
          </FormProvider>
        );
      };

      render(<Form />);

      expect(await screen.findByText('test')).toBeDefined();
    });
  });
});


================================================
File: /src/__tests__/controller.server.test.tsx
================================================
import React from 'react';
import { renderToString } from 'react-dom/server';

import { Controller } from '../controller';
import { useForm } from '../useForm';

describe('Controller with SSR', () => {
  // issue: https://github.com/react-hook-form/react-hook-form/issues/1398
  it('should render correctly with as with component', () => {
    const Component = () => {
      const { control } = useForm<{
        test: string;
      }>();

      return (
        <Controller
          defaultValue="default"
          name="test"
          render={({ field }) => <input {...field} />}
          control={control}
        />
      );
    };

    renderToString(<Component />);
  });
});


================================================
File: /src/__tests__/__snapshots__/useWatch.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`useWatch fieldArray with shouldUnregister true should watch correct input update with single field array input 1`] = `
[
  [
    {
      "id": "0",
      "prop": "test",
    },
    {
      "id": "1",
      "prop": "test1",
    },
  ],
  [
    {
      "prop": "test",
    },
    {
      "prop": "test1",
    },
  ],
  [
    {
      "prop": "test",
    },
    {
      "prop": "test1",
    },
  ],
  [
    {
      "prop": "test",
    },
    {
      "prop": "ShouldBeTHere",
    },
    {
      "prop": "test1",
    },
  ],
  [
    {
      "prop": "test",
    },
    {
      "prop": "ShouldBeTHere",
    },
    {
      "prop": "test1",
    },
  ],
  [
    {
      "prop": "ShouldBeTHere",
    },
    {
      "prop": "test1",
    },
  ],
]
`;

exports[`useWatch reset with useFieldArray should return current value with radio type 1`] = `
[
  {},
  {
    "options": [
      {
        "option": "yes",
      },
      {
        "option": "yes",
      },
    ],
  },
  {
    "options": [
      {
        "option": "yes",
      },
      {
        "option": "yes",
      },
    ],
  },
  {
    "options": [
      {
        "option": "no",
      },
      {
        "option": "yes",
      },
    ],
  },
]
`;


================================================
File: /src/__tests__/__snapshots__/useFieldArray.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`useFieldArray array of array fields should allow append with deeply nested field array even with flat structure 1`] = `
[
  {},
  {
    "test": [],
  },
  {
    "test": [
      {
        "yourDetails": {
          "firstName": [
            "test",
            "test1",
          ],
          "lastName": [
            "test",
            "test1",
          ],
        },
      },
    ],
  },
  {
    "test": [
      {
        "yourDetails": {
          "firstName": [
            "test",
            "test1",
          ],
          "lastName": [
            "test",
            "test1",
          ],
        },
      },
    ],
  },
  {
    "test": [
      {
        "yourDetails": {
          "firstName": [
            "test",
            "test1",
          ],
          "lastName": [
            "test",
            "test1",
          ],
        },
      },
    ],
  },
]
`;

exports[`useFieldArray should append multiple inputs correctly 1`] = `
[
  {
    "test": [
      {
        "value": "data",
      },
    ],
  },
  {
    "test": [
      {
        "value": "data",
      },
    ],
  },
  {
    "test": [
      {
        "value": "data",
      },
      {
        "value": "test",
      },
      {
        "value": "test1",
      },
    ],
  },
  {
    "test": [
      {
        "value": "data",
      },
      {
        "value": "test",
      },
      {
        "value": "test1",
      },
    ],
  },
]
`;

exports[`useFieldArray should custom register append, prepend and insert inputs with values 1`] = `
[
  [],
  [
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "insert",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
  [
    {
      "test": "prepend",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "insert",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
    {
      "test": "prepend",
      "test1": "prepend",
      "test2": [],
    },
    {
      "test": "insert",
      "test1": "insert",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "append",
      "test2": [],
    },
    {
      "test": "append",
      "test1": "",
      "test2": [
        {
          "test": "test",
        },
      ],
    },
  ],
]
`;


================================================
File: /src/__tests__/useController.test.tsx
================================================
import React, { useState } from 'react';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';

import { Controller } from '../controller';
import { Control, FieldPath, FieldValues } from '../types';
import { useController } from '../useController';
import { useForm } from '../useForm';
import { FormProvider, useFormContext } from '../useFormContext';
import isBoolean from '../utils/isBoolean';
import noop from '../utils/noop';

describe('useController', () => {
  it('should render input correctly', () => {
    const Component = () => {
      const { control } = useForm<{
        test: string;
        test1: { test: string }[];
      }>();

      useController({
        name: 'test',
        control,
        defaultValue: '',
      });

      return null;
    };

    render(<Component />);
  });

  it('should only subscribe to formState at each useController level', async () => {
    const renderCounter = [0, 0];
    type FormValues = {
      test: string;
      test1: string;
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { field } = useController({
        name: 'test',
        control,
      });

      renderCounter[0]++;

      return <input {...field} />;
    };

    const Test1 = ({ control }: { control: Control<FormValues> }) => {
      const {
        field,
        fieldState: { isDirty, isTouched },
      } = useController({
        name: 'test1',
        control,
      });

      renderCounter[1]++;

      return (
        <div>
          <input {...field} />
          {isDirty && <p>isDirty</p>}
          {isTouched && <p>isTouched</p>}
        </div>
      );
    };

    const Component = () => {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: '',
          test1: '',
        },
      });

      return (
        <div>
          <Test control={control} />
          <Test1 control={control} />
        </div>
      );
    };

    render(<Component />);

    expect(renderCounter).toEqual([1, 1]);

    fireEvent.change(screen.getAllByRole('textbox')[1], {
      target: {
        value: '1232',
      },
    });

    expect(screen.getByText('isDirty')).toBeVisible();

    fireEvent.blur(screen.getAllByRole('textbox')[1]);

    expect(screen.getByText('isTouched')).toBeVisible();

    expect(renderCounter).toEqual([1, 3]);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: '1232',
      },
    });

    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    expect(renderCounter).toEqual([2, 3]);
  });

  describe('checkbox', () => {
    it('should work for checkbox by spread the field object', async () => {
      const watchResult: unknown[] = [];
      const Component = () => {
        const { control, watch } = useForm<{
          test: string;
        }>();

        watchResult.push(watch());

        const { field } = useController({
          name: 'test',
          control,
          defaultValue: '',
        });

        return <input type="checkbox" {...field} />;
      };

      render(<Component />);

      expect(watchResult).toEqual([{}]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: true }]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: true }, { test: false }]);
    });

    it('should work for checkbox by assign checked', async () => {
      const watchResult: unknown[] = [];
      const Component = () => {
        const { control, watch } = useForm<{
          test: string;
        }>();

        watchResult.push(watch());

        const { field } = useController({
          name: 'test',
          control,
          defaultValue: '',
        });

        return (
          <input
            type="checkbox"
            checked={!!field.value}
            onChange={(e) => field.onChange(e.target.checked)}
          />
        );
      };

      render(<Component />);

      expect(watchResult).toEqual([{}]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: true }]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: true }, { test: false }]);
    });

    it('should work for checkbox by assign value manually', async () => {
      const watchResult: unknown[] = [];
      const Component = () => {
        const { control, watch } = useForm<{
          test: string;
        }>();

        watchResult.push(watch());

        const { field } = useController({
          name: 'test',
          control,
          defaultValue: '',
        });

        return (
          <input
            value="on"
            type="checkbox"
            checked={!!field.value}
            onChange={(e) =>
              field.onChange(e.target.checked ? e.target.value : false)
            }
          />
        );
      };

      render(<Component />);

      expect(watchResult).toEqual([{}]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: 'on' }]);

      fireEvent.click(screen.getByRole('checkbox'));

      expect(watchResult).toEqual([{}, { test: 'on' }, { test: false }]);
    });
  });

  it('should subscribe to formState update with trigger re-render at root', () => {
    type FormValues = {
      test: string;
    };
    let counter = 0;

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { field, formState } = useController({
        control,
        name: 'test',
      });

      return (
        <>
          <input {...field} />
          <p>{formState.dirtyFields.test && 'dirty'}</p>
          <p>{formState.touchedFields.test && 'touched'}</p>
        </>
      );
    };

    const Component = () => {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: '',
        },
      });
      counter++;

      return <Test control={control} />;
    };

    render(<Component />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.blur(screen.getByRole('textbox'));

    expect(counter).toEqual(1);

    expect(screen.getByText('dirty')).toBeVisible();
    expect(screen.getByText('touched')).toBeVisible();
  });

  it('should not overwrite defaultValues with defaultValue', () => {
    const App = () => {
      const { control } = useForm({
        defaultValues: {
          test: 'bill',
        },
      });

      return (
        <Controller
          render={({ field }) => {
            return <input {...field} />;
          }}
          control={control}
          name={'test'}
          defaultValue={'luo'}
        />
      );
    };

    render(<App />);

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe(
      'bill',
    );
  });

  it('should be able to update input value without ref', () => {
    const App = () => {
      const { control, setValue } = useForm();
      const { field } = useController({
        control,
        name: 'test',
        defaultValue: '',
      });

      return (
        <div>
          <input value={field.value} onChange={field.onChange} />
          <button
            onClick={() => {
              setValue('test', 'data');
            }}
          >
            setValue
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'data',
    );
  });

  it('should be able to setValue after reset', async () => {
    let renderCount = 0;

    type FormValues = {
      name: string;
    };

    const Input = ({ control }: { control: Control<FormValues> }) => {
      renderCount++;
      const { field } = useController({
        name: 'name',
        control,
        defaultValue: '',
      });

      return <input {...field} />;
    };

    function App() {
      const { reset, control, setValue } = useForm<FormValues>();

      React.useEffect(() => {
        reset({ name: 'initial' });
      }, [reset]);

      return (
        <div>
          <Input control={control} />
          <button type="button" onClick={() => setValue('name', 'test', {})}>
            setValue
          </button>
        </div>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );
    expect(renderCount).toEqual(3);
  });

  it('should invoke native validation with Controller', async () => {
    const setCustomValidity = jest.fn();
    const reportValidity = jest.fn();
    const focus = jest.fn();
    const message = 'This is required';

    type FormValues = {
      test: string;
    };

    function Input({ control }: { control: Control<FormValues> }) {
      const { field } = useController({
        control,
        rules: { required: message },
        name: 'test',
      });

      return (
        <div>
          <input
            {...field}
            ref={() => {
              field.ref({
                focus,
                setCustomValidity,
                reportValidity,
              });
            }}
          />
        </div>
      );
    }

    function App() {
      const { handleSubmit, control } = useForm<FormValues>({
        defaultValues: {
          test: '',
        },
        mode: 'onChange',
        shouldUseNativeValidation: true,
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <Input control={control} />
          <input type="submit" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => expect(focus).toBeCalled());
    expect(setCustomValidity).toBeCalledWith(message);
    expect(reportValidity).toBeCalled();

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'bill',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => expect(setCustomValidity).toBeCalledTimes(3));
    expect(reportValidity).toBeCalledTimes(3);
    expect(focus).toBeCalledTimes(2);
  });

  it('should update with inline defaultValue', async () => {
    const onSubmit = jest.fn();
    const App = () => {
      const { control, handleSubmit } = useForm();
      useController({ control, defaultValue: 'test', name: 'test' });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            onSubmit(data);
          })}
        >
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() =>
      expect(onSubmit).toBeCalledWith({
        test: 'test',
      }),
    );
  });

  it('should return defaultValues when component is not yet mounted', async () => {
    const defaultValues = {
      test: {
        deep: [
          {
            test: '0',
            test1: '1',
          },
        ],
      },
    };

    const App = () => {
      const { control, getValues } = useForm<{
        test: {
          deep: { test: string; test1: string }[];
        };
      }>({
        defaultValues,
      });

      const { field } = useController({
        control,
        name: 'test.deep.0.test',
      });

      return (
        <div>
          <input {...field} />
          <p>{JSON.stringify(getValues())}</p>
        </div>
      );
    };

    render(<App />);

    expect(true).toEqual(true);

    expect(
      await screen.findByText('{"test":{"deep":[{"test":"0","test1":"1"}]}}'),
    ).toBeVisible();
  });

  it('should trigger extra re-render and update latest value when setValue called during mount', async () => {
    const Child = () => {
      const { setValue } = useFormContext();
      const {
        field: { value },
      } = useController({
        name: 'content',
      });

      React.useEffect(() => {
        setValue('content', 'expected value');
      }, [setValue]);

      return <p>{value}</p>;
    };

    function App() {
      const methods = useForm({
        defaultValues: {
          content: 'default',
        },
      });

      return (
        <FormProvider {...methods}>
          <form>
            <Child />
            <input type="submit" />
          </form>
        </FormProvider>
      );
    }

    render(<App />);

    expect(await screen.findByText('expected value')).toBeVisible();
  });

  it('should remount with input with current formValue', () => {
    let data: unknown;

    function Input<T extends FieldValues>({
      control,
      name,
    }: {
      control: Control<T>;
      name: FieldPath<T>;
    }) {
      const {
        field: { value },
      } = useController({
        control,
        name,
        shouldUnregister: true,
      });

      data = value;

      return null;
    }

    const App = () => {
      const { control } = useForm<{
        test: string;
      }>({
        defaultValues: {
          test: 'test',
        },
      });
      const [toggle, setToggle] = React.useState(true);

      return (
        <div>
          {toggle && <Input control={control} name={'test'} />}
          <button onClick={() => setToggle(!toggle)}>toggle</button>
        </div>
      );
    };

    render(<App />);

    expect(data).toEqual('test');

    fireEvent.click(screen.getByRole('button'));

    fireEvent.click(screen.getByRole('button'));

    expect(data).toBeUndefined();
  });

  it('should always get the latest value for onBlur event', async () => {
    const watchResults: unknown[] = [];

    const App = () => {
      const { control, watch } = useForm();
      const { field } = useController({
        control,
        name: 'test',
        defaultValue: '',
      });

      watchResults.push(watch());

      return (
        <button
          onClick={() => {
            field.onChange('updated value');
            field.onBlur();
          }}
        >
          test
        </button>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'), {
      target: {
        value: 'test',
      },
    });

    expect(watchResults).toEqual([
      {},
      {
        test: 'updated value',
      },
    ]);
  });

  it('should focus and select the input text', () => {
    const select = jest.fn();
    const focus = jest.fn();

    const App = () => {
      const { control, setFocus } = useForm({
        defaultValues: {
          test: 'data',
        },
      });
      const { field } = useController({
        control,
        name: 'test',
      });

      field.ref({
        select,
        focus,
      });

      React.useEffect(() => {
        setFocus('test', { shouldSelect: true });
      }, [setFocus]);

      return null;
    };

    render(<App />);

    expect(select).toBeCalled();
    expect(focus).toBeCalled();
  });

  it('should update isValid correctly with strict mode', async () => {
    const App = () => {
      const form = useForm({
        mode: 'onChange',
        defaultValues: {
          name: '',
        },
      });
      const { isValid } = form.formState;

      return (
        <React.StrictMode>
          <FormProvider {...form}>
            <Controller
              render={({ field }) => (
                <input value={field.value} onChange={field.onChange} />
              )}
              name="name"
              rules={{
                required: true,
              }}
            />
            <p>{isValid ? 'valid' : 'not'}</p>
          </FormProvider>
        </React.StrictMode>
      );
    };

    render(<App />);

    await waitFor(() => {
      screen.getByText('not');
    });
  });

  it('should restore defaultValues with react strict mode double useEffect', () => {
    function Form() {
      return (
        <Controller
          name="lastName"
          shouldUnregister={true}
          render={({ field }) => <input {...field} />}
        />
      );
    }

    function App() {
      const methods = useForm({
        defaultValues: {
          lastName: 'luo',
        },
      });
      const {
        formState: { dirtyFields },
      } = methods;

      return (
        <React.StrictMode>
          <FormProvider {...methods}>
            <form>
              <Form />
              {dirtyFields.lastName ? 'dirty' : 'pristine'}
            </form>
          </FormProvider>
        </React.StrictMode>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'luo1',
      },
    });

    screen.getByText('dirty');

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'luo',
      },
    });

    screen.getByText('pristine');
  });

  it('should disable the controller input', async () => {
    function Form() {
      const { field } = useController({
        name: 'lastName',
      });
      return <p>{field.disabled ? 'disabled' : ''}</p>;
    }

    function App() {
      const methods = useForm({
        disabled: true,
      });

      return (
        <FormProvider {...methods}>
          <form>
            <Form />
          </form>
        </FormProvider>
      );
    }

    render(<App />);

    await waitFor(() => {
      screen.getByText('disabled');
    });
  });

  it('should disable form input with disabled prop', async () => {
    const App = () => {
      const [disabled, setDisabled] = React.useState(false);
      const { control, watch } = useForm({
        defaultValues: {
          test: 'test',
        },
      });
      const {
        field: { disabled: disabledProps },
      } = useController({
        control,
        name: 'test',
        disabled,
      });

      const input = watch('test');

      return (
        <form>
          <p>{input}</p>
          <button
            onClick={() => {
              setDisabled(!disabled);
            }}
            type={'button'}
          >
            toggle
          </button>
          <p>{disabledProps ? 'disable' : 'notDisabled'}</p>
        </form>
      );
    };

    render(<App />);

    screen.getByText('test');
    screen.getByText('notDisabled');

    fireEvent.click(screen.getByRole('button'));

    waitFor(() => {
      screen.getByText('');
      screen.getByText('disable');
    });
  });

  it('should disable form input field with disabled prop', async () => {
    const App = () => {
      const { control } = useForm();
      const {
        field,
        fieldState: { invalid, isTouched, isDirty },
      } = useController({
        name: 'test',
        control,
        disabled: true,
        rules: { required: true },
      });

      return (
        <form>
          <input {...field} />
          <button>submit</button>
          {invalid && <p>invalid</p>}
          {isTouched && <p>isTouched</p>}
          {isDirty && <p>isDirty</p>}
        </form>
      );
    };

    render(<App />);

    await waitFor(() => {
      expect(screen.getByRole('textbox')).toBeDisabled();
    });
  });

  it('should not disable form input field with disabled=false', async () => {
    const App = () => {
      const { control } = useForm();
      const {
        field,
        fieldState: { invalid, isTouched, isDirty },
      } = useController({
        name: 'test',
        control,
        disabled: false,
        rules: { required: true },
      });

      return (
        <form>
          <input {...field} />
          <button>submit</button>
          {invalid && <p>invalid</p>}
          {isTouched && <p>isTouched</p>}
          {isDirty && <p>isDirty</p>}
        </form>
      );
    };

    render(<App />);

    await waitFor(() => {
      expect(screen.getByRole('textbox')).not.toBeDisabled();
    });
  });

  it('should pass validation with disabled to set to true', () => {
    const callback = jest.fn();

    const App = () => {
      const { handleSubmit, control } = useForm({
        defaultValues: {
          test: 'test',
        },
      });
      const { field } = useController({
        control,
        rules: {
          required: true,
        },
        name: 'test',
        disabled: true,
      });

      return (
        <form onSubmit={handleSubmit(callback)}>
          <input {...field} />
          <button>submit</button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    waitFor(() => {
      expect(callback).toBeCalled();
    });
  });

  it('should not omit form value when disabled is not been presented', async () => {
    const onSubmit = jest.fn();

    const App = () => {
      const { handleSubmit, control } = useForm({
        defaultValues: {
          test: 'test',
        },
      });
      const [toggle, setToggle] = useState<boolean | undefined>(undefined);
      const { field } = useController({
        control,
        name: 'test',
        disabled: toggle,
      });

      return (
        <form
          onSubmit={handleSubmit((data) => {
            onSubmit(data);
          })}
        >
          <input {...field} />
          <button>submit</button>
          <button
            type={'button'}
            onClick={() => {
              setToggle((value) => {
                if (isBoolean(value)) {
                  return false;
                }

                return !value;
              });
            }}
          >
            toggle
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(onSubmit).toBeCalledWith({
        test: 'test',
      }),
    );

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(onSubmit).toBeCalledWith({
        test: 'test',
      }),
    );

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(onSubmit).toBeCalledWith({
        test: undefined,
      }),
    );
  });

  it('should subscribe to exact form state update', () => {
    type FormValues = {
      test: string;
      test_with_suffix: string;
    };

    const renderCounter: Record<keyof FormValues, number> = {
      test: 0,
      test_with_suffix: 0,
    };

    const ControlledInput = ({
      name,
      control,
    }: {
      name: keyof FormValues;
      control: Control<FormValues>;
    }) => {
      const {
        field,
        fieldState: { error, isDirty },
      } = useController({
        name,
        control,
        rules: { required: 'is required' },
      });

      renderCounter[name]++;

      return (
        <div>
          <input aria-label={name} {...field} />
          {error && (
            <p>
              {name} {error.message}
            </p>
          )}
          {isDirty && <p>{name} isDirty</p>}
        </div>
      );
    };

    const App = () => {
      const { control } = useForm<FormValues>({
        mode: 'onBlur',
        defaultValues: {
          test: '1234',
          test_with_suffix: '1234',
        },
      });
      return (
        <form>
          <ControlledInput name="test" control={control} />
          <ControlledInput name="test_with_suffix" control={control} />
        </form>
      );
    };

    render(<App />);

    expect(renderCounter).toEqual({ test: 1, test_with_suffix: 1 });
    expect(screen.queryByText('test is required')).toBeNull();
    expect(screen.queryByText('test_with_suffix is required')).toBeNull();

    fireEvent.change(screen.getByRole('textbox', { name: 'test' }), {
      target: {
        value: '',
      },
    });

    fireEvent.blur(screen.getByRole('textbox', { name: 'test' }));

    expect(screen.getByText('test isDirty')).toBeVisible();

    expect(renderCounter).toEqual({ test: 2, test_with_suffix: 1 });

    fireEvent.change(
      screen.getByRole('textbox', { name: 'test_with_suffix' }),
      {
        target: {
          value: '',
        },
      },
    );

    fireEvent.blur(screen.getByRole('textbox', { name: 'test_with_suffix' }));

    expect(screen.getByText('test_with_suffix isDirty')).toBeVisible();

    expect(renderCounter).toEqual({ test: 2, test_with_suffix: 2 });
  });
});


================================================
File: /src/__tests__/type.test.tsx
================================================
import React from 'react';

import { Controller } from '../controller';
import {
  FieldErrors,
  FieldPath,
  FieldValues,
  Path,
  PathValue,
  UseFormRegister,
} from '../types';
import { useController } from '../useController';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { useFormState } from '../useFormState';
import { useWatch } from '../useWatch';

test('should not throw type error with path name', () => {
  type MissingCompanyNamePath = Path<{
    test: {
      test: {
        name: string;
      }[];
      testName: string;
    };
  }>;

  const test: MissingCompanyNamePath[] = [
    'test',
    'test.test',
    'test.testName',
    'test.test.0',
    'test.test.0.name',
  ];

  test;
});

test('should not throw type error with optional array fields', () => {
  type Thing = { id: string; name: string };

  interface FormData {
    name: string;
    things?: Array<{ name: string }>;
    items?: Array<Thing>;
  }

  function App() {
    const { control, register } = useForm<FormData>({
      defaultValues: { name: 'test' },
    });
    const { fields, append } = useFieldArray({ control, name: 'things' });
    const fieldArray = useFieldArray({ control, name: 'items' });

    return (
      <div className="App">
        <input {...register('name')} />

        <button onClick={() => append({ name: '' })}>Add</button>

        {fields.map((field, index) => (
          <div key={field.id}>
            <input {...register(`things.${index}.name` as const)} />
          </div>
        ))}
        {fieldArray.fields.map((item) => {
          return <div key={item.id}>{item.name}</div>;
        })}
      </div>
    );
  }

  App;
});

test('should work with optional field with Controller', () => {
  type FormValues = {
    firstName: string;
    lastName?: string;
  };

  function App() {
    const { control } = useForm<FormValues>();

    return (
      <div>
        <Controller
          name="firstName"
          defaultValue=""
          control={control}
          render={({ field: { value, onChange } }) => {
            return <input value={value} onChange={onChange} />;
          }}
        />
        <Controller
          name="lastName"
          defaultValue=""
          control={control}
          render={({ field: { value, onChange } }) => {
            return <input value={value} onChange={onChange} />;
          }}
        />
      </div>
    );
  }

  App;
});

test('should work with useWatch return correct array types', () => {
  type FormValues = {
    testString: string;
    testNumber: number;
    testObject: {
      testString: string;
      test1String: string;
    };
  };

  const App = () => {
    const { control } = useForm<FormValues>();
    const output: [
      FormValues['testString'],
      FormValues['testNumber'],
      FormValues['testObject'],
    ] = useWatch({
      control,
      name: ['testString', 'testNumber', 'testObject'],
    });

    return output;
  };

  App;
});

test('should type errors correctly with Path generic', () => {
  interface InputProps<T extends FieldValues = FieldValues> {
    name: FieldPath<T>;
    register: UseFormRegister<T>;
    errors: FieldErrors<T>;
  }

  function Input<T extends FieldValues = FieldValues>({
    name,
    register,
    errors,
  }: InputProps<T>) {
    return (
      <>
        <input {...register(name)} />
        {errors[name] ? errors?.[name]?.message : 'no error'}
      </>
    );
  }

  Input;
});

test('should allow unpackedValue and deep partial unpackValue for reset', () => {
  type Type1 = { name: string };
  type Type2 = { name: string };

  type Forms = {
    test: Type1;
    test1: Type2;
  };

  type FormMapKey = keyof Forms;

  const Test = <T extends FormMapKey>() => {
    const { reset, getValues } = useForm<Forms[T]>();
    reset(getValues());
  };

  Test;
});

test('should infer context type into control', () => {
  function App() {
    const [isValid] = React.useState(true);
    const { control } = useForm<{ test: {}[] }, { isValid: boolean }>({
      resolver: (data, context) => {
        return {
          values: context?.isValid ? data : {},
          errors: {},
        };
      },
      context: {
        isValid,
      },
    });

    useFieldArray({
      name: 'test',
      control,
    });

    return null;
  }

  App;
});

test('should support optional field errors', () => {
  type Errors = FieldErrors<{
    steps?: { action: string }[];
    foo?: {
      bar: string;
    };
    baz: { action: string };
  }>;

  const error = {
    type: 'test',
    message: 'test',
  };

  let errors: Errors = {
    steps: error,
    foo: error,
    baz: error,
  };

  errors = {
    steps: [{ action: error }],
    foo: {
      bar: error,
    },
    baz: {
      action: error,
    },
  };

  errors;
});

test('should support nullable field errors', () => {
  type Errors = FieldErrors<{
    steps?: { action: string }[] | null;
    foo: {
      bar: string;
    } | null;
    baz: { action: string };
  }>;

  const error = {
    type: 'test',
    message: 'test',
  };

  let errors: Errors = {
    steps: error,
    foo: error,
    baz: error,
  };

  errors = {
    steps: [{ action: error }],
    foo: {
      bar: error,
    },
    baz: {
      action: error,
    },
  };

  errors;
});

test('should work with generic component path assertion', () => {
  function App<T extends FieldValues>() {
    const { register } = useForm<T>();
    const FIELD_DATA_EXTENSION = '__data';
    const item = {
      value: 'data',
    };

    register(`FieldName${FIELD_DATA_EXTENSION}` as FieldPath<T>, {
      value: item as PathValue<T, Path<T>>,
    });

    return null;
  }

  App;
});

test('should infer async default values', () => {
  const formValues = {
    test: 'test',
    test1: {
      nested: 'test',
    },
    fieldArray: [{ test: '' }],
  };

  function App() {
    const {
      register,
      control,
      formState,
      setValue,
      reset,
      watch,
      getValues,
      getFieldState,
      clearErrors,
      unregister,
      setFocus,
      trigger,
      setError,
    } = useForm<typeof formValues>({
      defaultValues: async () => {
        return formValues;
      },
    });
    useFieldArray({
      name: 'fieldArray' as const,
      control,
    });
    useController({
      name: 'test1.nested',
      control,
    });
    useWatch({
      name: 'test1',
      control,
    });
    useFormState({
      name: 'fieldArray',
      control,
    });

    setValue('test', 'data');
    setValue('test1.nested', 'data');
    reset({
      test: 'test',
      test1: {
        nested: 'test1',
      },
    });

    watch('test');
    watch('test1.nested');

    getValues('test');
    getValues('test1.nested');

    getFieldState('test');
    getFieldState('test1.nested');

    clearErrors('test');
    clearErrors('test1.nested');

    unregister('test');
    unregister('test1.nested');

    setFocus('test');
    setFocus('test1.nested');

    trigger('test');
    trigger('test1.nested');

    setError('test', { type: 'test ' });
    setError('test1.nested', { type: 'test ' });

    return (
      <form>
        <input {...register('test')} />
        <Controller render={() => <input />} name={'test1'} control={control} />
        <p>{formState.errors?.test?.message}</p>
        <p>{formState.errors?.test1?.message}</p>
        <p>{formState.touchedFields.test}</p>
        <p>{formState.touchedFields.test1?.nested}</p>
        <p>{formState.dirtyFields.test}</p>
        <p>{formState.dirtyFields.test1?.nested}</p>
      </form>
    );
  }

  App;
});

test('should work for root error type', () => {
  const App = () => {
    const {
      setError,
      formState: { errors },
    } = useForm();

    setError('root', {
      type: 'data',
      message: 'test',
    });
    setError('root.nested', {
      type: 'data',
      message: 'test',
    });

    React.useEffect(() => {
      setError('root.test', {
        type: 'root.test',
      });
      setError('root', {
        type: 'root',
      });
    }, [setError]);

    return (
      <form>
        <p>{errors.root?.test?.message}</p>
        <p>{errors.root?.message}</p>
      </form>
    );
  };

  App;
});

it('should worked for error with type or message keyword', () => {
  type FormInputs = {
    object: { id: string; type: string; message: string };
  };

  const App = () => {
    const {
      register,
      handleSubmit,
      formState: { errors },
    } = useForm<FormInputs>({
      defaultValues: {
        object: {
          type: 'test',
          id: 'test',
        },
      },
    });

    const onSubmit = (data: FormInputs) => {
      alert(JSON.stringify(data));
    };

    return (
      <form onSubmit={handleSubmit(onSubmit)}>
        <label>Id</label>
        <input type="number" {...register('object.type', { min: 1 })} />
        <input type="number" {...register('object.id', { min: 1 })} />
        <p>{errors?.object?.id?.message}</p>
        <input type="submit" />
      </form>
    );
  };

  App;
});

test('should provide correct type for validate function with useFieldArray', () => {
  const App = () => {
    const { control } = useForm<{
      test: {
        first: string;
        last: string;
      }[];
      test1: {
        first: string;
        last: string;
      }[];
    }>({
      defaultValues: {
        test: [
          {
            first: 'value',
            last: 'test',
          },
        ],
      },
    });
    useFieldArray({
      control,
      name: 'test',
      rules: {
        validate: (data) => {
          return !!data.find((test) => test.first && test.last);
        },
      },
    });
    useFieldArray({
      control,
      name: 'test1',
      rules: {
        validate: {
          test: (data) => {
            return !!data.find((test) => test.first && test.last);
          },
        },
      },
    });

    return null;
  };

  App;
});


================================================
File: /src/__tests__/useFieldArray/append.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Control, FieldPath } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('append', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should append dirtyFields fields correctly', async () => {
    let dirtyInputs = {};
    const Component = () => {
      const {
        register,
        control,
        formState: { dirtyFields },
      } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [
            { value: 'plz change' },
            { value: 'dont change' },
            { value: 'dont change' },
          ],
        },
      });
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      dirtyInputs = dirtyFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          {dirtyFields.test?.length && 'dirty'}
        </form>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getAllByRole('textbox')[0], {
      target: { value: 'test' },
    });
    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    expect(await screen.findByText('dirty')).toBeVisible();

    expect(dirtyInputs).toEqual({
      test: [{ value: true }],
    });

    fireEvent.click(screen.getByRole('button'));

    expect(dirtyInputs).toEqual({
      test: [
        { value: true },
        { value: false },
        { value: false },
        { value: true },
      ],
    });
  });

  it('should append data into the fields', () => {
    let currentFields: unknown[] = [];
    const Component = () => {
      const { register, control } = useForm<{
        test: { test: string }[];
      }>();
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      currentFields = fields;

      return (
        <form>
          {fields.map((field, index) => {
            return (
              <input
                key={field.id}
                {...register(`test.${index}.test` as const)}
              />
            );
          })}
          <button type={'button'} onClick={() => append({ test: 'test' })}>
            append
          </button>
          <button
            type={'button'}
            onClick={() =>
              append([{ test: 'test-batch' }, { test: 'test-batch1' }])
            }
          >
            appendBatch
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    expect(currentFields).toEqual([{ id: '0', test: 'test' }]);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    expect(currentFields).toEqual([
      { id: '0', test: 'test' },
      { id: '2', test: 'test' },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'appendBatch' }));

    expect(currentFields).toEqual([
      { id: '0', test: 'test' },
      { id: '2', test: 'test' },
      { id: '5', test: 'test-batch' },
      { id: '6', test: 'test-batch1' },
    ]);
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should be dirtyFields when value is appended with %s',
    () => {
      let isDirtyValue;
      let dirtyValue;

      const Component = () => {
        const {
          register,
          control,
          formState: { isDirty, dirtyFields },
        } = useForm<{
          test: { test: string }[];
        }>();
        const { fields, append } = useFieldArray({
          control,
          name: 'test',
        });

        isDirtyValue = isDirty;
        dirtyValue = dirtyFields;

        return (
          <form>
            {fields.map((field, index) => {
              return (
                <input
                  key={field.id}
                  {...register(`test.${index}.test` as const)}
                />
              );
            })}
            <button type={'button'} onClick={() => append({ test: 'test' })}>
              append
            </button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      fireEvent.click(screen.getByRole('button', { name: 'append' }));

      expect(isDirtyValue).toBeTruthy();
      expect(dirtyValue).toEqual({
        test: [{ test: true }, { test: true }, { test: true }],
      });
    },
  );

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: unknown[] = [];
    const Component = () => {
      const { register, watch, control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(watched).toEqual([
      {},
      { test: [] },
      { test: [{ value: '' }] },
      { test: [{ value: '' }] },
    ]);
  });

  it('should focus if shouldFocus is true', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: { test: [{ value: '1' }, { value: '2' }] },
      });
      const { fields, append } = useFieldArray({ control, name: 'test' });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '3' })}>
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);

    expect(document.activeElement).toEqual(inputs[2]);
  });

  it('should not focus if shouldFocus is false', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: { test: [{ value: '1' }, { value: '2' }] },
      });
      const { fields, append } = useFieldArray({ control, name: 'test' });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => append({ value: '3' }, { shouldFocus: false })}
          >
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);
    expect(document.activeElement).toEqual(document.body);
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, append } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      renderedItems.push(watched);
      return (
        <div>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: 'test' })}>append</button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        undefined,
        [],
        [{ value: 'test' }],
        [{ value: 'test' }],
      ]),
    );
  });

  it('should append nested field value without its reference', () => {
    type FormValues = {
      test: { name: { deep: string } }[];
    };

    function Input({
      name,
      control,
    }: {
      name: FieldPath<FormValues>;
      control: Control<FormValues>;
    }) {
      const { field } = useController({
        name: name as 'test.0.name.deep',
        control,
      });

      return <input type="text" {...field} />;
    }

    function FieldArray({
      control,
      name,
      itemDefaultValue,
    }: {
      control: Control<FormValues>;
      name: FieldPath<FormValues>;
      itemDefaultValue: { name: { deep: string } };
    }) {
      const { fields, append } = useFieldArray({
        control,
        name: name as 'test',
      });

      return (
        <>
          {fields.map((item, index) => (
            <Input
              key={item.id}
              name={`test.${index}.name.deep`}
              control={control}
            />
          ))}
          <button type="button" onClick={() => append(itemDefaultValue)}>
            Append
          </button>
        </>
      );
    }

    function App() {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: [],
        },
      });

      return (
        <form>
          <FieldArray
            name="test"
            control={control}
            itemDefaultValue={{ name: { deep: '' } }}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: '1234' },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('');
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { append } = useFieldArray({ control, name: 'test' });
        return { formState, append };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.append({ value: '1' });
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { append } = useFieldArray({ control, name: 'test' });
        return { formState, append };
      });

      act(() => {
        result.current.append({ value: '1' });
      });

      expect(resolver).toBeCalled();
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [{ id: '1234', test: 'data' }],
        },
      });

      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"1234","test":"data"},{"id":"whatever","test":"1234"}]}',
      ),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, append } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"1234"}]}'),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/focus.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';

import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

describe('useFieldArray focus', () => {
  it('should not focus any element when shouldFocus is set to false', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, prepend, append, insert } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => prepend({ value: '' }, { shouldFocus: false })}
          >
            prepend
          </button>
          <button
            type="button"
            onClick={() => append({ value: '' }, { shouldFocus: false })}
          >
            append
          </button>
          <button
            type="button"
            onClick={() => insert(1, { value: '' }, { shouldFocus: false })}
          >
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    expect(document.activeElement).toEqual(document.body);
  });

  it('should focus on the precise input index', () => {
    function App() {
      const { register, handleSubmit, control } = useForm({
        defaultValues: {
          test: [
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
            { value: '0' },
          ],
        },
      });
      const { fields, insert } = useFieldArray({ control, name: 'test' });

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, index) => (
            <div key={field.id}>
              <input
                {...register(`test.${index}.value`)}
                defaultValue={field.value}
              />
              <button onClick={() => insert(1, { value: '' })}>insert</button>
            </div>
          ))}
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getAllByRole('button', { name: /insert/i })[0]);

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[1]);
  });

  it('should focus correct field array by focus index', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, prepend, append, insert } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => prepend({ value: '' }, { focusIndex: 1 })}
          >
            prepend
          </button>
          <button
            type="button"
            onClick={() => append({ value: '' }, { focusIndex: 0 })}
          >
            append
          </button>
          <button
            type="button"
            onClick={() => insert(1, { value: '' }, { focusIndex: 0 })}
          >
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[0]);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[1]);

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[0]);
  });

  it('should focus correct field array by focus name', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, prepend, append, insert } = useFieldArray({
        name: 'test',
        control,
      });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() =>
              prepend({ value: '' }, { focusName: 'test.1.value' })
            }
          >
            prepend
          </button>
          <button
            type="button"
            onClick={() => append({ value: '' }, { focusName: 'test.0.value' })}
          >
            append
          </button>
          <button
            type="button"
            onClick={() =>
              insert(1, { value: '' }, { focusName: 'test.0.value' })
            }
          >
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[0]);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[1]);

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    expect(document.activeElement).toEqual(screen.getAllByRole('textbox')[0]);
  });
});


================================================
File: /src/__tests__/useFieldArray/move.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('move', () => {
  beforeEach(() => {
    i = 0;
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should move dirtyFields into pointed position when formState.%s is defined',
    () => {
      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          defaultValues: { test: [{ value: '1' }] },
        });
        const methods = useFieldArray({
          control,
          name: 'test',
        });
        return {
          formState,
          ...methods,
        };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.append({ value: '2' });
      });

      act(() => {
        result.current.append({ value: '3' });
      });

      act(() => {
        result.current.move(0, 1);
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [{ value: true }, { value: true }, { value: true }],
      });
    },
  );

  it('should move errors', async () => {
    let errors: any;
    const Component = () => {
      const { register, handleSubmit, control, ...rest } = useForm({
        defaultValues: { test: [{ value: 'test' }] },
      });
      const { fields, append, move } = useFieldArray({
        control,
        name: 'test',
      });
      errors = rest.formState.errors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => move(0, 1)}>
            move
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() => expect(errors.test[0]).toBeUndefined());
    expect(errors.test[1]).toBeDefined();

    fireEvent.click(screen.getByRole('button', { name: /move/i }));

    expect(errors.test[0]).toBeDefined();
    expect(errors.test[1]).toBeUndefined();
  });

  it('should move touched fields', async () => {
    let touched: any;
    const Component = () => {
      const { register, formState, control } = useForm({
        defaultValues: { test: [{ value: 'test' }] },
      });
      const { fields, append, move } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => move(0, 1)}>
            move
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    fireEvent.click(screen.getByRole('button', { name: /move/i }));

    expect(touched).toEqual({
      test: [undefined, { value: true }],
    });
  });

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, move } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => move(0, 1)}>
            move
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'move' }));

    expect(watched).toEqual([
      { test: [{ value: '1' }, { value: '2' }] }, // first render
      { test: [{ value: '1' }, { value: '2' }] }, // render inside useEffect in useFieldArray
      { test: [{ value: '2' }, { value: '1' }] }, // render inside move method
      { test: [{ value: '2' }, { value: '1' }] }, // render inside useEffect in useFieldArray
    ]);
  });

  it('should populate all fields with default values', () => {
    let getValues: any;
    const Component = () => {
      const {
        register,
        control,
        getValues: tempGetValues,
      } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields } = useFieldArray({
        control,
        name: 'test',
      });
      getValues = tempGetValues;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
        </form>
      );
    };

    render(<Component />);

    expect(getValues()).toEqual({ test: [{ value: '1' }, { value: '2' }] });
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, move } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      const isMoved = React.useRef(false);
      if (isMoved.current) {
        renderedItems.push(watched);
      }

      return (
        <div>
          {fields.map((field, i) => (
            <div key={`${field.id}`}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: '' })}>append</button>
          <button
            onClick={() => {
              move(0, 1);
              isMoved.current = true;
            }}
          >
            move
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.change(inputs[0], {
      target: { name: 'test[0].value', value: '111' },
    });
    fireEvent.change(inputs[1], {
      target: { name: 'test[1].value', value: '222' },
    });

    fireEvent.click(screen.getByRole('button', { name: /move/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        [{ value: '222' }, { value: '111' }],
        [{ value: '222' }, { value: '111' }],
      ]),
    );
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: '1' }, { value: '2' }],
          },
        });
        const { move } = useFieldArray({ control, name: 'test' });
        return { formState, move };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.move(0, 1);
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '2' }, { value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: '1' }, { value: '2' }],
          },
        });
        const { move } = useFieldArray({ control, name: 'test' });
        return { formState, move };
      });

      act(() => {
        result.current.move(0, 1);
      });

      expect(resolver).toBeCalled();
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [
            { id: '1234', test: 'data' },
            { id: '4567', test: 'data1' },
          ],
        },
      });

      const { fields, move } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              move(0, 1);
            }}
          >
            move
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'move' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"4567","test":"data1"},{"id":"1234","test":"data"}]}',
      ),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };
    let k = 0;

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, append, move } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              move(0, 1);
            }}
          >
            move
          </button>

          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever' + k,
                test: '1234' + k,
              });
              k = 1;
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'move' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"whatever1","test":"12341"},{"id":"whatever0","test":"12340"}]}',
      ),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/remove.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Controller } from '../../controller';
import { Control, DeepMap, FieldError } from '../../types';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

jest.useFakeTimers();

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('remove', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should update isDirty formState when item removed', () => {
    let formState: any;
    const Component = () => {
      const {
        register,
        control,
        formState: tempFormState,
      } = useForm({
        defaultValues: {
          test: [{ name: 'default' }],
        },
      });
      const { fields, remove, append } = useFieldArray({
        name: 'test',
        control,
      });

      formState = tempFormState;
      formState.isDirty;

      return (
        <form>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input {...register(`test.${i}.name` as const)} />
              <button type={'button'} onClick={() => remove(i)}>
                remove
              </button>
            </div>
          ))}

          <button
            type={'button'}
            onClick={() =>
              append({
                name: '',
              })
            }
          >
            append
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(formState.isDirty).toBeFalsy();

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(formState.isDirty).toBeTruthy();

    fireEvent.click(screen.getAllByRole('button', { name: /remove/i })[1]);

    expect(formState.isDirty).toBeFalsy();
  });

  it('should update isValid formState when item removed', async () => {
    let formState: any;
    const Component = () => {
      const {
        register,
        control,
        formState: tempFormState,
      } = useForm({
        mode: 'onChange',
        defaultValues: {
          test: [{ name: 'default' }],
        },
      });
      const { fields, remove, append } = useFieldArray({
        name: 'test',
        control,
      });

      formState = tempFormState;

      formState.isValid;

      return (
        <form>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input
                {...register(`test.${i}.name` as const, { required: true })}
              />
              <button type={'button'} onClick={() => remove(i)}>
                remove
              </button>
            </div>
          ))}

          <button
            type={'button'}
            onClick={() =>
              append({
                name: '',
              })
            }
          >
            append
          </button>

          <p>{formState.isValid ? 'isValid' : 'notValid'}</p>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(await screen.findByText('notValid')).toBeVisible();

    fireEvent.click(screen.getAllByRole('button', { name: /remove/i })[1]);

    expect(await screen.findByText('isValid')).toBeVisible();
  });

  it('should remove field according index', () => {
    const { result } = renderHook(() => {
      const { control } = useForm({
        defaultValues: {
          test: [{ value: 'default' }],
        },
      });
      return useFieldArray({
        control,
        name: 'test',
      });
    });

    act(() => {
      result.current.append({ value: 'test' });
    });

    act(() => {
      result.current.remove(1);
    });

    expect(result.current.fields).toEqual([{ id: '0', value: 'default' }]);

    act(() => {
      result.current.remove(0);
    });

    expect(result.current.fields).toEqual([]);
  });

  it('should remove all field', () => {
    const { result } = renderHook(() => {
      const { control } = useForm({
        defaultValues: {
          test: [{ value: 'default' }],
        },
      });
      return useFieldArray({
        control,
        name: 'test',
      });
    });

    act(() => {
      result.current.append({ value: 'test' });
    });

    act(() => {
      result.current.remove();
    });

    expect(result.current.fields).toEqual([]);
  });

  it('should remove specific fields when index is array', () => {
    const { result } = renderHook(() => {
      const { control } = useForm({
        defaultValues: {
          test: [{ value: 'default' }],
        },
      });
      return useFieldArray({
        control,
        name: 'test',
      });
    });

    act(() => {
      result.current.append({ value: 'test' });
    });

    act(() => {
      result.current.remove([0, 1]);
    });

    expect(result.current.fields).toEqual([]);
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should be dirtyFields when value is remove with %s',
    () => {
      const { result } = renderHook(() => {
        const { register, formState, control } = useForm({
          defaultValues: {
            test: [{ value: 'default' }],
          },
        });
        const { fields, append, remove } = useFieldArray({
          control,
          name: 'test',
        });

        return { register, formState, fields, append, remove };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.append({ value: 'test' });
      });

      act(() => {
        result.current.append({ value: 'test' });
      });

      act(() => {
        result.current.remove(0);
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [{ value: true }, { value: true }],
      });

      act(() => {
        result.current.remove();
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [{ value: true }],
      });
    },
  );

  it('should remove values from formState.touchedFields', () => {
    let touched: any;

    const Component = () => {
      const { register, formState, control } = useForm();
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value`)} />
          ))}
          <button type="button" onClick={() => append({ value: 'append' })}>
            append
          </button>
          <button type="button" onClick={() => remove(0)}>
            remove
          </button>
          <button type="button" onClick={() => remove()}>
            remove all
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.blur(inputs[0]);
    fireEvent.blur(inputs[1]);
    fireEvent.blur(inputs[2]);

    expect(touched).toEqual({
      test: [{ value: true }, { value: true }, { value: true }],
    });

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    expect(touched).toEqual({
      test: [{ value: true }, { value: true }],
    });

    fireEvent.click(screen.getByRole('button', { name: 'remove all' }));

    expect(touched).toEqual({ test: [] });
  });

  it('should remove specific field if isValid is true', async () => {
    const Component = () => {
      const { register, formState, control } = useForm({
        mode: VALIDATION_MODE.onChange,
      });
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      formState.isValid;

      return (
        <form>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => remove(1)}>
            remove
          </button>
          <p>{formState.isValid ? 'valid' : 'notValid'}</p>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    expect(await screen.findByText('notValid')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.input(inputs[0], {
      target: { value: 'test' },
    });

    fireEvent.input(inputs[2], {
      target: { value: 'test' },
    });

    fireEvent.input(inputs[3], {
      target: { value: 'test' },
    });

    expect(await screen.findByText('notValid')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    expect(await screen.findByText('valid')).toBeVisible();
  });

  it('should remove all field if isValid is true', async () => {
    let isValid = false;
    const Component = () => {
      const { register, formState, control } = useForm({
        mode: VALIDATION_MODE.onChange,
      });
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });
      isValid = formState.isValid;

      return (
        <form>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => remove()}>
            remove
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    await waitFor(() => expect(isValid).toBeFalsy());
    expect(screen.getAllByRole('textbox')).toHaveLength(1);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    expect(screen.getAllByRole('textbox')).toHaveLength(2);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    await waitFor(() => expect(isValid).toBeFalsy());
    expect(screen.getAllByRole('textbox')).toHaveLength(3);

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));
    await waitFor(() => expect(isValid).toBe(true));
  });

  it('should remove error', async () => {
    let errors: any;
    const Component = () => {
      const {
        register,
        formState: { errors: tempErrors },
        handleSubmit,
        control,
      } = useForm();
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });
      errors = tempErrors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => remove(0)}>
            remove
          </button>
          <button type="button" onClick={() => remove()}>
            remove all
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    await waitFor(() => expect(errors.test).toHaveLength(2));

    fireEvent.click(screen.getByRole('button', { name: 'remove all' }));

    expect(errors.test).toBeUndefined();
  });

  it('should remove nested field array error', async () => {
    type FormValues = {
      test: {
        nested: {
          test: string;
          key: number;
        }[];
      }[];
    };

    let mockKey = 0;
    const callback = jest.fn();

    const Nested = ({
      errors,
      control,
      index,
    }: {
      control: Control<FormValues>;
      errors: DeepMap<Record<string, any>, FieldError>;
      index: number;
    }) => {
      const { fields, append, remove } = useFieldArray<
        FormValues,
        'test.0.nested'
      >({
        name: `test.${index}.nested` as 'test.0.nested',
        control,
      });

      return (
        <fieldset>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input
                {...control.register(
                  `test.${index}.nested.${i}.test` as const,
                  {
                    required: 'required',
                  },
                )}
              />
              {errors?.test &&
                errors.test[index]?.nested &&
                errors.test[index].nested[i]?.test && (
                  <span data-testid="nested-error">
                    {errors.test[index].nested[i].test.message}
                  </span>
                )}
              <button type="button" onClick={() => remove(i)}>
                nested delete
              </button>
            </div>
          ))}
          <button
            type="button"
            onClick={() => append({ test: 'test', key: mockKey++ })}
          >
            nested append
          </button>
        </fieldset>
      );
    };

    const Component = () => {
      const {
        formState: { errors, isValid },
        handleSubmit,
        control,
      } = useForm<FormValues>({
        defaultValues: {
          test: [{ nested: [{ test: '', key: mockKey }] }],
        },
      });
      const { fields } = useFieldArray({ name: 'test', control });

      return (
        <>
          <p>Valid: {isValid.toString()}</p>
          <form onSubmit={handleSubmit(callback)}>
            {fields.map((_, i) => (
              <Nested
                key={i.toString()}
                errors={errors}
                control={control}
                index={i}
              />
            ))}
            <button>submit</button>
          </form>
        </>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));
    expect(await screen.findByTestId('nested-error')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: /nested delete/i }));
    await waitFor(() =>
      expect(screen.queryByTestId('nested-error')).not.toBeInTheDocument(),
    );
    expect(await screen.findByText('Valid: true')).toBeVisible();

    fireEvent.click(screen.getByRole('button', { name: /nested append/i }));

    expect(screen.queryByTestId('nested-error')).not.toBeInTheDocument();
  });

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => remove(0)}>
            remove
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    expect(watched).toEqual([
      {}, // first render
      { test: [] }, // render inside useEffect in useFieldArray
      { test: [{ value: '' }] }, // render inside append method
      { test: [{ value: '' }] }, // render inside useEffect in useFieldArray
      { test: [] }, // render inside remove method
      { test: [] }, // render inside useEffect in useFieldArray
    ]);
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, remove } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      const isRemoved = React.useRef(false);
      if (isRemoved.current) {
        renderedItems.push(watched);
      }

      return (
        <div>
          {fields.map((field, i) => (
            <div key={`${field.id}`}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: '' })}>append</button>
          <button
            onClick={() => {
              remove(2);
              isRemoved.current = true;
            }}
          >
            remove
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.change(inputs[0], {
      target: { name: 'test[0].value', value: '111' },
    });
    fireEvent.change(inputs[1], {
      target: { name: 'test[1].value', value: '222' },
    });
    fireEvent.change(inputs[2], {
      target: { name: 'test[2].value', value: '333' },
    });

    fireEvent.click(screen.getByRole('button', { name: /remove/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        [{ value: '111' }, { value: '222' }],
        [{ value: '111' }, { value: '222' }],
      ]),
    );
  });

  it('should remove dirtyFields fields with nested field inputs', () => {
    const { result } = renderHook(() => {
      const { register, formState, control } = useForm({
        defaultValues: {
          test: {
            data: [{ value: 'default' }],
          },
        },
      });
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test.data',
      });

      return { register, formState, fields, append, remove };
    });

    result.current.formState.dirtyFields as Record<string, any>;
    result.current.formState.isDirty;

    act(() => {
      result.current.append({ value: 'test' });
    });

    expect(result.current.formState.isDirty).toBeTruthy();
    expect(result.current.formState.dirtyFields).toEqual({
      test: { data: [{ value: false }, { value: true }] },
    });

    act(() => {
      result.current.remove(1);
    });

    expect(result.current.formState.isDirty).toBeFalsy();
    expect(result.current.formState.dirtyFields).toEqual({
      test: { data: [{ value: false }] },
    });
  });

  it('should remove Controller by index without error', () => {
    const Component = () => {
      const { control, handleSubmit } = useForm<{
        test: {
          firstName: string;
        }[];
      }>({
        defaultValues: {
          test: [],
        },
      });
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <ul>
            {fields.map((item, index) => {
              return (
                <li key={item.id}>
                  <Controller
                    render={({ field }) => <input {...field} />}
                    name={`test.${index}.firstName` as const}
                    control={control}
                  />
                  <button type="button" onClick={() => remove(index)}>
                    delete
                  </button>
                </li>
              );
            })}
          </ul>
          <section>
            <button
              type="button"
              onClick={() => {
                append({ firstName: 'appendBill' });
              }}
            >
              append
            </button>
          </section>

          <input type="submit" />
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));
    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getAllByRole('button', { name: 'delete' })[1]);
    fireEvent.click(screen.getAllByRole('button', { name: 'delete' })[1]);
    fireEvent.click(screen.getAllByRole('button', { name: 'delete' })[1]);
    fireEvent.click(screen.getAllByRole('button', { name: 'delete' })[0]);
  });

  it("should not reset Controller's value during remove when Field Array name is already registered", async () => {
    function Component() {
      const { control, handleSubmit } = useForm({
        defaultValues: {
          test: [{ firstName: 'Bill', lastName: '' }],
        },
      });
      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <ul>
            {fields.map((item, index) => {
              return (
                <li key={item.id}>
                  <Controller
                    name={`test.${index}.lastName` as const}
                    control={control}
                    render={({ field }) => <input {...field} />}
                  />
                  <button type="button" onClick={() => remove(index)}>
                    Delete
                  </button>
                </li>
              );
            })}
          </ul>
          <button
            type="button"
            onClick={() => {
              append({ firstName: 'appendBill', lastName: 'appendLuo' });
            }}
          >
            append
          </button>
        </form>
      );
    }

    render(<Component />);

    fireEvent.input(screen.getAllByRole('textbox')[0], {
      target: { name: 'test[0].lastName', value: '111' },
    });

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getAllByRole('button', { name: 'Delete' })[1]);

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('111');
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: 'test' }],
          },
        });
        const { remove } = useFieldArray({ control, name: 'test' });
        return { formState, remove };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.remove(0);
      });

      expect(resolver).toBeCalledWith(
        {
          test: [],
        },
        undefined,
        { criteriaMode: undefined, fields: {}, names: [] },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: 'test' }],
          },
        });
        const { remove } = useFieldArray({ control, name: 'test' });
        return { formState, remove };
      });

      act(() => {
        result.current.remove(0);
      });

      expect(resolver).toBeCalled();
    });

    it('should remove the first index correctly', async () => {
      let output: unknown;

      type FormValues = {
        test: {
          firstName: string;
          lastName: string;
        }[];
      };

      const Component = () => {
        const { control, handleSubmit, register } = useForm<FormValues>({
          defaultValues: {
            test: [
              {
                firstName: 'test',
                lastName: 'test',
              },
              {
                firstName: 'test1',
                lastName: 'test1',
              },
            ],
          },
        });
        const { fields, remove } = useFieldArray({
          control,
          name: 'test',
        });

        const onSubmit = (data: FormValues) => (output = data);

        return (
          <form onSubmit={handleSubmit(onSubmit)}>
            {fields.map((field, index) => {
              return (
                <div key={field.id}>
                  <input {...register(`test.${index}.firstName` as const)} />
                  <Controller
                    name={`test.${index}.lastName` as const}
                    control={control}
                    render={() => <div />}
                  />
                  <button
                    type={'button'}
                    onClick={() => {
                      remove(index);
                    }}
                  >
                    Remove
                  </button>
                </div>
              );
            })}
            <button>Submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

      await waitFor(() =>
        expect(output).toEqual({
          test: [
            {
              firstName: 'test',
              lastName: 'test',
            },
            {
              firstName: 'test1',
              lastName: 'test1',
            },
          ],
        }),
      );

      fireEvent.click(screen.getAllByRole('button', { name: 'Remove' })[0]);

      fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

      await waitFor(() =>
        expect(output).toEqual({
          test: [
            {
              firstName: 'test1',
              lastName: 'test1',
            },
          ],
        }),
      );
    });
  });

  it('should remove correct value with async reset', async () => {
    let output = {};

    function App() {
      const { handleSubmit, control, reset } = useForm({
        defaultValues: {
          test: [
            {
              title: '',
              description: '',
            },
            {
              title: '',
              description: '',
            },
          ],
        },
      });
      const { fields, remove } = useFieldArray({
        name: 'test',
        control,
      });

      React.useEffect(() => {
        setTimeout(() => {
          reset({
            test: [
              {
                title: 'title1',
                description: 'description1',
              },
              {
                title: 'title2',
                description: 'description2',
              },
            ],
          });
        }, 2000);
      }, [reset]);

      return (
        <form onSubmit={handleSubmit((data) => (output = data))}>
          {fields.map((field, index) => (
            <div
              key={field.id}
              style={{ display: 'flex', alignItems: 'center' }}
            >
              <Controller
                name={`test.${index}.title`}
                control={control}
                render={({ field }) => <input {...field} />}
              />
              <button type="button" onClick={() => remove(index)}>
                remove
              </button>
            </div>
          ))}
          <button type="submit">submit</button>
        </form>
      );
    }

    render(<App />);

    act(() => {
      jest.advanceTimersByTime(2000);
    });

    fireEvent.click(screen.getAllByRole('button', { name: 'remove' })[1]);

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    await waitFor(() =>
      expect(output).toEqual({
        test: [{ title: 'title1', description: 'description1' }],
      }),
    );
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [
            { id: '1234', test: 'data' },
            { id: '4567', test: 'data1' },
          ],
        },
      });

      const { fields, remove } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              remove(0);
            }}
          >
            remove
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"4567","test":"data1"}]}'),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };
    let k = 0;

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, append, remove } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              remove(0);
            }}
          >
            remove
          </button>

          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever' + k,
                test: '1234' + k,
              });
              k = 1;
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'remove' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever1","test":"12341"}]}'),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/prepend.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Control, FieldPath } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('prepend', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should pre-append data into the fields', async () => {
    let currentFields: any = [];

    const Component = () => {
      const { control, register } = useForm<{
        test: {
          test: string;
        }[];
      }>();
      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });

      currentFields = fields;

      return (
        <form>
          {fields.map((field, index) => (
            <div key={field.id}>
              <input {...register(`test.${index}.test` as const)} />
            </div>
          ))}
          <button type={'button'} onClick={() => prepend({ test: 'test' })}>
            prepend
          </button>
          <button
            type={'button'}
            onClick={() =>
              prepend([{ test: 'test-batch' }, { test: 'test-batch1' }])
            }
          >
            prependBatch
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    expect(currentFields).toEqual([{ id: '0', test: 'test' }]);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    expect(currentFields).toEqual([
      { id: '2', test: 'test' },
      { id: '0', test: 'test' },
    ]);

    fireEvent.click(screen.getByRole('button', { name: 'prependBatch' }));

    expect(currentFields).toEqual([
      { id: '5', test: 'test-batch' },
      { id: '6', test: 'test-batch1' },
      { id: '2', test: 'test' },
      { id: '0', test: 'test' },
    ]);
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should be dirtyFields when value is prepended with %s',
    () => {
      const { result } = renderHook(() => {
        const { register, formState, control } = useForm();
        const { fields, prepend } = useFieldArray({
          control,
          name: 'test',
        });

        return { register, formState, fields, prepend };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.prepend({ value: 'test' });
      });

      act(() => {
        result.current.prepend({ value: 'test1' });
      });

      act(() => {
        result.current.prepend({ value: 'test2' });
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [{ value: true }, { value: true }, { value: true }],
      });
    },
  );

  it('should set prepended values to formState.touchedFields', () => {
    let touched: any;

    const Component = () => {
      const { register, formState, control } = useForm();
      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value`)} />
          ))}
          <button type="button" onClick={() => prepend({ value: `test${1}` })}>
            prepend
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));
    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    expect(touched).toEqual({
      test: [undefined, { value: true }, { value: true }],
    });
  });

  it('should prepend error', async () => {
    let errors: any;
    const Component = () => {
      const {
        register,
        formState: { errors: tempErrors },
        handleSubmit,
        control,
      } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });
      errors = tempErrors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => prepend({ value: '' })}>
            prepend
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    expect(errors.test).toBeUndefined();

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() => {
      expect(errors.test).toHaveLength(1);
    });

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    await waitFor(() => {
      expect(errors.test).toHaveLength(2);
    });
  });

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => prepend({ value: '' })}>
            prepend
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    expect(watched).toEqual([
      {}, // first render
      { test: [] }, // render inside useEffect in useFieldArray
      { test: [{ value: '' }] }, // render inside prepend method
      { test: [{ value: '' }] }, // render inside useEffect in useFieldArray
    ]);
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, prepend } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      const isPrepended = React.useRef(false);
      if (isPrepended.current) {
        renderedItems.push(watched);
      }
      return (
        <div>
          {fields.map((field, i) => (
            <div key={`${field.id}`}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: '' })}>append</button>
          <button
            onClick={() => {
              prepend({ value: 'test' });
              isPrepended.current = true;
            }}
          >
            prepend
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.input(inputs[0], {
      target: { name: 'test[0].value', value: '111' },
    });
    fireEvent.input(inputs[1], {
      target: { name: 'test[1].value', value: '222' },
    });

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        [{ value: 'test' }, { value: '111' }, { value: '222' }],
        [{ value: 'test' }, { value: '111' }, { value: '222' }],
      ]),
    );
  });

  it('should focus if shouldFocus is true', () => {
    const Component = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, prepend } = useFieldArray({ name: 'test', control });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => prepend({ value: '' })}>
            prepend
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));

    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);
    expect(document.activeElement).toEqual(inputs[0]);
  });

  it('should not focus if shouldFocus is false', () => {
    const Component = () => {
      const { register, control } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, prepend } = useFieldArray({ name: 'test', control });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => prepend({ value: '' }, { shouldFocus: false })}
          >
            prepend
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /prepend/i }));
    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);
    expect(document.activeElement).toEqual(document.body);
  });

  it('should append nested field value without its reference', () => {
    type FormValues = {
      test: { name: { deep: string } }[];
    };

    function Input({
      name,
      control,
    }: {
      name: FieldPath<FormValues>;
      control: Control<FormValues>;
    }) {
      const { field } = useController({
        name: name as 'test.0.name.deep',
        control,
      });

      return <input type="text" {...field} />;
    }

    function FieldArray({
      control,
      name,
      itemDefaultValue,
    }: {
      control: Control<FormValues>;
      name: FieldPath<FormValues>;
      itemDefaultValue: { name: { deep: string } };
    }) {
      const { fields, prepend } = useFieldArray({
        control,
        name: name as 'test',
      });

      return (
        <>
          {fields.map((item, index) => (
            <Input
              key={item.id}
              name={`test.${index}.name.deep`}
              control={control}
            />
          ))}
          <button type="button" onClick={() => prepend(itemDefaultValue)}>
            Append
          </button>
        </>
      );
    }

    function App() {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: [],
        },
      });

      return (
        <form>
          <FieldArray
            name="test"
            control={control}
            itemDefaultValue={{ name: { deep: '' } }}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: '1234' },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('');
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { prepend } = useFieldArray({ control, name: 'test' });
        return { formState, prepend };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.prepend({ value: '1' });
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { prepend } = useFieldArray({ control, name: 'test' });
        return { formState, prepend };
      });

      act(() => {
        result.current.prepend({ value: '1' });
      });

      expect(resolver).toBeCalled();
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [{ id: '1234', test: 'data' }],
        },
      });

      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              prepend({
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            prepend
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"whatever","test":"1234"},{"id":"1234","test":"data"}]}',
      ),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, prepend } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              prepend({
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            prepend
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'prepend' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"1234"}]}'),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/update.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Control } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('update', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should update dirtyFields fields correctly', async () => {
    let dirtyInputs = {};
    const Component = () => {
      const {
        register,
        control,
        formState: { dirtyFields },
      } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [
            { value: 'plz change' },
            { value: 'dont change' },
            { value: 'dont change' },
          ],
        },
      });
      const { fields, update } = useFieldArray({
        control,
        name: 'test',
      });

      dirtyInputs = dirtyFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => update(0, { value: 'changed' })}>
            update
          </button>
          {dirtyFields.test?.length && 'dirty'}
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('dirty')).toBeVisible();

    expect(dirtyInputs).toEqual({
      test: [{ value: true }, { value: false }, { value: false }],
    });
  });

  it.each(['isDirty', 'dirtyFields'])('should update state with %s', () => {
    let isDirtyValue;
    let dirtyValue;

    const Component = () => {
      const {
        register,
        control,
        formState: { isDirty, dirtyFields },
      } = useForm<{
        test: { test: string }[];
      }>({
        defaultValues: {},
      });
      const { fields, update } = useFieldArray({
        control,
        name: 'test',
      });

      isDirtyValue = isDirty;
      dirtyValue = dirtyFields;

      return (
        <form>
          {fields.map((field, index) => {
            return (
              <input
                key={field.id}
                {...register(`test.${index}.test` as const)}
              />
            );
          })}
          <button type={'button'} onClick={() => update(2, { test: 'test1' })}>
            update
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'update' }));

    expect(isDirtyValue).toBeTruthy();
    expect(dirtyValue).toEqual({
      test: [undefined, undefined, { test: true }],
    });
  });

  it('should trigger reRender when user update input and is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, update } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => update(0, { value: '' })}>
            update
          </button>
        </form>
      );
    };

    render(<Component />);

    expect(watched).toEqual([
      {},
      {
        test: [],
      },
    ]);

    fireEvent.click(screen.getByRole('button', { name: /update/i }));

    expect(watched).toEqual([
      {},
      {
        test: [],
      },
      {
        test: [
          {
            value: '',
          },
        ],
      },
      {
        test: [
          {
            value: '',
          },
        ],
      },
    ]);
  });

  it('should return watched value with update and watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: { value: string }[];
      }>();
      const { fields, update } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      renderedItems.push(watched);
      return (
        <div>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => update(0, { value: 'test' })}>update</button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /update/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        undefined,
        [],
        [{ value: 'test' }],
        [{ value: 'test' }],
      ]),
    );
  });

  it('should update group input correctly', () => {
    type FormValues = {
      test: {
        value: {
          firstName: string;
          lastName: string;
        };
      }[];
    };

    const fieldArrayValues: unknown[] = [];

    const GroupInput = ({
      control,
      index,
    }: {
      control: Control<FormValues>;
      index: number;
    }) => {
      const { field } = useController({
        control,
        name: `test.${index}.value` as const,
      });

      return (
        <div>
          <input
            value={field.value.firstName}
            onChange={(e) => {
              field.onChange({
                ...field.value,
                firstName: e.target.name,
              });
            }}
          />
          <input
            value={field.value.lastName}
            onChange={(e) => {
              field.onChange({
                ...field.value,
                lastName: e.target.name,
              });
            }}
          />
        </div>
      );
    };

    const App = () => {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: [
            {
              value: {
                firstName: 'bill',
                lastName: 'luo',
              },
            },
          ],
        },
      });
      const { fields, update } = useFieldArray({
        name: 'test',
        control,
      });

      fieldArrayValues.push(fields);

      return (
        <div>
          {fields.map((field, i) => (
            <div key={field.id}>
              <GroupInput control={control} index={i} />
            </div>
          ))}
          <button
            onClick={() =>
              update(0, {
                value: { firstName: 'firstName', lastName: 'lastName' },
              })
            }
          >
            update
          </button>
        </div>
      );
    };

    render(<App />);

    expect(fieldArrayValues.at(-1)).toEqual([
      {
        id: '0',
        value: {
          firstName: 'bill',
          lastName: 'luo',
        },
      },
    ]);

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('firstName');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('lastName');

    // Let's check all values of renders with implicitly the number of render (for each value)
    expect(fieldArrayValues).toEqual([
      [
        {
          id: '0',
          value: {
            firstName: 'bill',
            lastName: 'luo',
          },
        },
      ],
      [
        {
          id: '1',
          value: {
            firstName: 'firstName',
            lastName: 'lastName',
          },
        },
      ],
    ]);
  });

  it('should update field array with single value', () => {
    let fieldArrayValues: { value: string }[] | [] = [];
    const App = () => {
      const { register, control } = useForm<{
        test: { value: string }[];
      }>({
        defaultValues: {
          test: [
            {
              value: 'bill',
            },
          ],
        },
      });
      const { fields, update } = useFieldArray({
        name: 'test',
        control,
      });

      fieldArrayValues = fields;

      return (
        <div>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => update(0, { value: 'test' })}>update</button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
      'test',
    );

    expect(fieldArrayValues[0].value).toEqual('test');
  });

  it('should update field array with multiple values', () => {
    let fieldArrayValues: { firstName: string; lastName: string }[] | [] = [];

    const App = () => {
      const { register, control } = useForm<{
        test: { firstName: string; lastName: string }[];
      }>({
        defaultValues: {
          test: [
            {
              firstName: 'bill',
              lastName: 'luo',
            },
            {
              firstName: 'bill1',
              lastName: 'luo1',
            },
          ],
        },
      });
      const { fields, update } = useFieldArray({
        name: 'test',
        control,
      });

      fieldArrayValues = fields;

      return (
        <div>
          {fields.map((field, i) => (
            <div key={field.id}>
              <input {...register(`test.${i}.firstName` as const)} />
              <input {...register(`test.${i}.lastName` as const)} />
            </div>
          ))}
          <button
            onClick={() => {
              update(0, { firstName: 'test1', lastName: 'test2' });
              update(1, { firstName: 'test3', lastName: 'test4' });
            }}
          >
            update
          </button>
        </div>
      );
    };

    render(<App />);

    expect(fieldArrayValues).toEqual([
      {
        firstName: 'bill',
        id: '0',
        lastName: 'luo',
      },
      {
        firstName: 'bill1',
        id: '1',
        lastName: 'luo1',
      },
    ]);

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('test1');
    expect(
      (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
    ).toEqual('test2');
    expect(
      (screen.getAllByRole('textbox')[2] as HTMLInputElement).value,
    ).toEqual('test3');
    expect(
      (screen.getAllByRole('textbox')[3] as HTMLInputElement).value,
    ).toEqual('test4');

    expect(fieldArrayValues).toEqual([
      {
        firstName: 'test1',
        id: '2',
        lastName: 'test2',
      },
      {
        firstName: 'test3',
        id: '3',
        lastName: 'test4',
      },
    ]);
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { update } = useFieldArray({ control, name: 'test' });
        return { formState, update };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.update(0, { value: '1' });
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { update } = useFieldArray({ control, name: 'test' });
        return { formState, update };
      });

      act(() => {
        result.current.update(0, { value: '1' });
      });

      expect(resolver).toBeCalled();
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [{ id: '1234', test: 'data' }],
        },
      });

      const { fields, update } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              update(0, {
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            update
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'update' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"1234"}]}'),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, update } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              update(0, {
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            update
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'update' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"1234"}]}'),
    ).toBeVisible();
  });

  it('should not update errors state', async () => {
    const App = () => {
      const {
        control,
        register,
        trigger,
        formState: { errors },
      } = useForm({
        defaultValues: {
          test: [
            {
              firstName: '',
            },
          ],
        },
      });
      const { fields, update } = useFieldArray({
        name: 'test',
        control,
      });

      React.useEffect(() => {
        trigger();
      }, [trigger]);

      return (
        <form>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.firstName` as const, {
                required: 'This is required',
              })}
            />
          ))}
          <p>{errors?.test?.[0]?.firstName?.message}</p>
          <button
            type={'button'}
            onClick={() =>
              update(0, {
                firstName: 'firstName',
              })
            }
          >
            update
          </button>
        </form>
      );
    };

    render(<App />);

    expect(await screen.findByText('This is required')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('This is required')).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/swap.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('swap', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should swap into pointed position', () => {
    const { result } = renderHook(() => {
      const { register, control } = useForm({
        defaultValues: { test: [{ value: '1' }] },
      });
      const methods = useFieldArray({
        control,
        name: 'test',
      });

      return { register, ...methods };
    });

    act(() => {
      result.current.append({ value: '2' });
    });

    act(() => {
      result.current.swap(0, 1);
    });

    expect(result.current.fields).toEqual([
      { id: '1', value: '2' },
      { id: '0', value: '1' },
    ]);
  });

  it('should swap data order', () => {
    const { result } = renderHook(() => {
      const { register, control } = useForm({
        defaultValues: { test: [{ value: '1' }] },
      });
      const methods = useFieldArray({
        control,
        name: 'test',
      });

      return { register, ...methods };
    });

    act(() => {
      result.current.append({ value: '2' });
    });

    act(() => {
      result.current.swap(0, 1);
    });

    expect(result.current.fields).toEqual([
      { id: '1', value: '2' },
      { id: '0', value: '1' },
    ]);
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should swap dirtyFields order when formState.%s is defined',
    () => {
      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          defaultValues: { test: [{ value: '1' }] },
        });
        const methods = useFieldArray({
          control,
          name: 'test',
        });
        return {
          formState,
          ...methods,
        };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.append({ value: '2' });
      });

      act(() => {
        result.current.append({ value: '3' });
      });

      act(() => {
        result.current.swap(0, 1);
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [{ value: true }, { value: true }, { value: true }],
      });
    },
  );

  it('should swap errors', async () => {
    let errors: any;
    const Component = () => {
      const { register, handleSubmit, control, ...rest } = useForm({
        defaultValues: { test: [{ value: 'test' }] },
      });
      const { fields, append, swap } = useFieldArray({
        control,
        name: 'test',
      });
      errors = rest.formState.errors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value` as const, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => swap(0, 1)}>
            swap
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() => expect(errors.test[0]).toBeUndefined());
    expect(errors.test[1]).toBeDefined();

    fireEvent.click(screen.getByRole('button', { name: /swap/i }));

    expect(errors.test[0]).toBeDefined();
    expect(errors.test[1]).toBeUndefined();
  });

  it('should swap touched fields', async () => {
    let touched: any;
    const Component = () => {
      const { register, formState, control } = useForm({
        defaultValues: { test: [{ value: 'test' }] },
      });
      const { fields, append, swap } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => swap(0, 1)}>
            swap
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.blur(screen.getAllByRole('textbox')[0]);

    fireEvent.click(screen.getByRole('button', { name: /swap/i }));

    expect(touched).toEqual({
      test: [undefined, { value: true }],
    });
  });

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, swap } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => swap(0, 1)}>
            swap
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'swap' }));

    expect(watched).toEqual([
      { test: [{ value: '1' }, { value: '2' }] }, // first render
      { test: [{ value: '1' }, { value: '2' }] }, // render inside useEffect in useFieldArray
      { test: [{ value: '2' }, { value: '1' }] }, // render inside swap method
      { test: [{ value: '2' }, { value: '1' }] }, // render inside useEffect in useFieldArray
    ]);
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, swap } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      const isSwapped = React.useRef(false);
      if (isSwapped.current) {
        renderedItems.push(watched);
      }
      return (
        <div>
          {fields.map((field, i) => (
            <div key={`${field.id}`}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: '' })}>append</button>
          <button
            onClick={() => {
              swap(0, 1);
              isSwapped.current = true;
            }}
          >
            swap
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.input(inputs[0], {
      target: { name: 'test[0].value', value: '111' },
    });
    fireEvent.input(inputs[1], {
      target: { name: 'test[1].value', value: '222' },
    });

    fireEvent.click(screen.getByRole('button', { name: /swap/i }));

    await waitFor(() =>
      expect(renderedItems).toEqual([
        [{ value: '222' }, { value: '111' }],
        [{ value: '222' }, { value: '111' }],
      ]),
    );
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: '1' }, { value: '2' }],
          },
        });
        const { swap } = useFieldArray({ control, name: 'test' });
        return { formState, swap };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.swap(0, 1);
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '2' }, { value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
          defaultValues: {
            test: [{ value: '1' }, { value: '2' }],
          },
        });
        const { swap } = useFieldArray({ control, name: 'test' });
        return { formState, swap };
      });

      act(() => {
        result.current.swap(0, 1);
      });

      expect(resolver).toBeCalled();
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [
            { id: '1234', test: 'data' },
            { id: '4567', test: 'data1' },
          ],
        },
      });

      const { fields, swap } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              swap(0, 1);
            }}
          >
            swap
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'swap' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"4567","test":"data1"},{"id":"1234","test":"data"}]}',
      ),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };
    let k = 0;

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, append, swap } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              swap(0, 1);
            }}
          >
            swap
          </button>

          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever' + k,
                test: '1234' + k,
              });
              k = 1;
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'swap' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"whatever1","test":"12341"},{"id":"whatever0","test":"12340"}]}',
      ),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/insert.test.tsx
================================================
import React from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../../constants';
import { Control, FieldPath } from '../../types';
import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import noop from '../../utils/noop';

jest.useFakeTimers();

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('insert', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should insert data at index with single value', () => {
    const { result } = renderHook(() => {
      const { control } = useForm({
        defaultValues: {
          test: [{ test: '1' }, { test: '2' }],
        },
      });
      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });
      return { fields, insert };
    });

    act(() => {
      result.current.insert(1, { test: '3' });
    });

    expect(result.current.fields).toEqual([
      { id: '0', test: '1' },
      { id: '2', test: '3' },
      { id: '1', test: '2' },
    ]);
  });

  it('should insert data at index with array value', () => {
    const { result } = renderHook(() => {
      const { control } = useForm({
        defaultValues: {
          test: [{ test: '1' }, { test: '2' }],
        },
      });
      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });
      return { fields, insert };
    });

    act(() => {
      result.current.insert(1, [{ test: '3' }, { test: '4' }]);
    });

    expect(result.current.fields).toEqual([
      { id: '0', test: '1' },
      { id: '2', test: '3' },
      { id: '3', test: '4' },
      { id: '1', test: '2' },
    ]);
  });

  it.each(['isDirty', 'dirtyFields'])(
    'should insert data to formState.%s at index with single value',
    () => {
      const { result } = renderHook(() => {
        const { formState, control } = useForm<{
          test: { value: string; value1: string }[];
        }>({
          defaultValues: { test: [{ value: '1' }] },
        });
        const { fields, append, insert } = useFieldArray({
          control,
          name: 'test',
        });

        return { formState, fields, append, insert };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.append({ value: '2', value1: '' });
      });

      act(() => {
        result.current.insert(1, { value1: '3', value: '' });
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [
          { value: false },
          { value1: true, value: true },
          { value: true, value1: true },
        ],
      });
    },
  );

  it.each(['isDirty', 'dirtyFields'])(
    'should insert data to formState.%s at index with array value',
    () => {
      const { result } = renderHook(() => {
        const { formState, control } = useForm<{
          test: { value1: string; value2: string; value: string }[];
        }>({
          defaultValues: { test: [{ value: '1' }] },
        });
        const { fields, append, insert } = useFieldArray({
          control,
          name: 'test',
        });

        return { formState, fields, append, insert };
      });

      result.current.formState.isDirty;
      result.current.formState.dirtyFields;

      act(() => {
        result.current.append({ value: '2', value1: '', value2: '' });
      });

      act(() => {
        result.current.insert(1, [
          { value1: '3', value: '', value2: '' },
          { value2: '4', value: '', value1: '' },
        ]);
      });

      expect(result.current.formState.isDirty).toBeTruthy();
      expect(result.current.formState.dirtyFields).toEqual({
        test: [
          { value: false },
          { value1: true, value: true, value2: true },
          { value2: true, value: true, value1: true },
          { value: true, value1: true, value2: true },
        ],
      });
    },
  );

  it('should insert touched fields with single value', () => {
    let touched: any;
    const Component = () => {
      const { register, formState, control } = useForm({
        defaultValues: { test: [{ value: '1' }, { value: '2' }] },
      });
      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => insert(1, { value: `${fields.length}` })}
          >
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.blur(screen.getAllByRole('textbox')[0]);
    fireEvent.blur(screen.getAllByRole('textbox')[1]);

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    expect(touched).toEqual({
      test: [{ value: true }, undefined, { value: true }],
    });
  });

  it('should insert touched fields with array value', () => {
    let touched: any;
    const Component = () => {
      const { register, formState, control } = useForm({
        defaultValues: { test: [{ value: '1' }, { value: '2' }] },
      });
      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });

      touched = formState.touchedFields;

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() =>
              insert(1, [
                { value: `${fields.length}` },
                { value: `${fields.length + 1}` },
              ])
            }
          >
            insert array
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.blur(screen.getAllByRole('textbox')[0]);
    fireEvent.blur(screen.getAllByRole('textbox')[1]);

    fireEvent.click(screen.getByRole('button', { name: /insert array/i }));

    expect(touched).toEqual({
      test: [{ value: true }, undefined, undefined, { value: true }],
    });
  });

  it('should insert error with single value', async () => {
    let errors: any;
    const Component = () => {
      const { register, handleSubmit, control, ...rest } = useForm();
      const { fields, append, insert } = useFieldArray({
        control,
        name: 'test',
      });

      errors = rest.formState.errors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value`, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button type="button" onClick={() => insert(1, { value: '' })}>
            insert
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    await waitFor(() => expect(errors.test[0]).toBeDefined());
    expect(errors.test[1]).toBeUndefined();
    expect(errors.test[2]).toBeDefined();
  });

  it('should insert error with array value', async () => {
    let errors: any;
    const Component = () => {
      const { register, handleSubmit, control, ...rest } = useForm();
      const { fields, append, insert } = useFieldArray({
        control,
        name: 'test',
      });

      errors = rest.formState.errors;

      return (
        <form onSubmit={handleSubmit(noop)}>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.value`, { required: true })}
            />
          ))}
          <button type="button" onClick={() => append({ value: '' })}>
            append
          </button>
          <button
            type="button"
            onClick={() => insert(1, [{ value: '' }, { value: '' }])}
          >
            insert array
          </button>
          <button>submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    fireEvent.click(screen.getByRole('button', { name: /insert array/i }));

    await waitFor(() => expect(errors.test[0]).toBeDefined());
    expect(errors.test[1]).toBeUndefined();
    expect(errors.test[2]).toBeUndefined();
    expect(errors.test[3]).toBeDefined();
  });

  it('should focus if shouldFocus is true', () => {
    const Component = () => {
      const { register, control } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, insert } = useFieldArray({ name: 'test', control });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => insert(1, { value: '' })}>
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);
    expect(document.activeElement).toEqual(inputs[1]);
  });

  it('should not focus if shouldFocus is false', () => {
    const Component = () => {
      const { register, control } = useForm({
        defaultValues: {
          test: [{ value: '1' }, { value: '2' }],
        },
      });
      const { fields, insert } = useFieldArray({ name: 'test', control });

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button
            type="button"
            onClick={() => insert(1, { value: '' }, { shouldFocus: false })}
          >
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    const inputs = screen.getAllByRole('textbox');

    expect(inputs).toHaveLength(3);
    expect(document.activeElement).toEqual(document.body);
  });

  it('should trigger reRender when user is watching the all field array', () => {
    const watched: any[] = [];
    const Component = () => {
      const { register, watch, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });
      watched.push(watch());

      return (
        <form>
          {fields.map((field, i) => (
            <input key={field.id} {...register(`test.${i}.value` as const)} />
          ))}
          <button type="button" onClick={() => insert(0, { value: '' })}>
            insert
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: 'insert' }));

    expect(watched).toEqual([
      {}, // first render
      { test: [] }, // render inside useEffect in useFieldArray
      { test: [{ value: '' }] }, // render inside insert method
      { test: [{ value: '' }] }, // render inside useEffect in useFieldArray
    ]);
  });

  it('should return watched value with watch API', async () => {
    const renderedItems: any = [];
    const Component = () => {
      const { watch, register, control } = useForm<{
        test: {
          value: string;
        }[];
      }>();
      const { fields, append, insert } = useFieldArray({
        name: 'test',
        control,
      });
      const watched = watch('test');
      const isInserted = React.useRef(false);
      if (isInserted.current) {
        renderedItems.push(watched);
      }
      return (
        <div>
          {fields.map((field, i) => (
            <div key={`${field.id}`}>
              <input {...register(`test.${i}.value` as const)} />
            </div>
          ))}
          <button onClick={() => append({ value: '' })}>append</button>
          <button
            onClick={() => {
              insert(1, { value: 'test' });
              isInserted.current = true;
            }}
          >
            insert
          </button>
        </div>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: /append/i }));
    fireEvent.click(screen.getByRole('button', { name: /append/i }));

    const inputs = screen.getAllByRole('textbox');

    fireEvent.change(inputs[0], {
      target: { name: 'test[0].value', value: '111' },
    });
    fireEvent.change(inputs[1], {
      target: { name: 'test[1].value', value: '222' },
    });

    fireEvent.click(screen.getByRole('button', { name: /insert/i }));

    expect(renderedItems).toEqual([
      [{ value: '111' }, { value: 'test' }, { value: '222' }],
      [{ value: '111' }, { value: 'test' }, { value: '222' }],
    ]);
  });

  it('should append nested field value without its reference', () => {
    type FormValues = {
      test: { name: { deep: string } }[];
    };

    function Input({
      name,
      control,
    }: {
      name: FieldPath<FormValues>;
      control: Control<FormValues>;
    }) {
      const { field } = useController({
        name: name as 'test.0.name.deep',
        control,
      });

      return <input type="text" {...field} />;
    }

    function FieldArray({
      control,
      name,
      itemDefaultValue,
    }: {
      control: Control<FormValues>;
      name: FieldPath<FormValues>;
      itemDefaultValue: { name: { deep: string } };
    }) {
      const { fields, insert } = useFieldArray({
        control,
        name: name as 'test',
      });

      return (
        <>
          {fields.map((item, index) => (
            <Input
              key={item.id}
              name={`test.${index}.name.deep`}
              control={control}
            />
          ))}
          <button type="button" onClick={() => insert(0, itemDefaultValue)}>
            Append
          </button>
        </>
      );
    }

    function App() {
      const { control } = useForm<FormValues>({
        defaultValues: {
          test: [],
        },
      });

      return (
        <form>
          <FieldArray
            name="test"
            control={control}
            itemDefaultValue={{ name: { deep: '' } }}
          />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: '1234' },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(
      (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
    ).toEqual('');
  });

  describe('with resolver', () => {
    it('should invoke resolver when formState.isValid true', async () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { insert } = useFieldArray({ control, name: 'test' });
        return { formState, insert };
      });

      result.current.formState.isValid;

      await act(async () => {
        result.current.insert(0, { value: '1' });
      });

      expect(resolver).toBeCalledWith(
        {
          test: [{ value: '1' }],
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {},
          names: [],
        },
      );
    });

    it('should not invoke resolver when formState.isValid false', () => {
      const resolver = jest.fn().mockReturnValue({});

      const { result } = renderHook(() => {
        const { formState, control } = useForm({
          mode: VALIDATION_MODE.onChange,
          resolver,
        });
        const { insert } = useFieldArray({ control, name: 'test' });
        return { formState, insert };
      });

      act(() => {
        result.current.insert(0, { value: '1' });
      });

      expect(resolver).toBeCalled();
    });

    it('should insert update fields during async submit', () => {
      type FormValues = {
        test: { name: string }[];
      };

      function App() {
        const { register, control } = useForm<FormValues>();
        const [value, setValue] = React.useState('');
        const { fields, insert } = useFieldArray({
          control,
          name: 'test',
        });

        return (
          <div>
            <form>
              {fields.map((field, index) => {
                return (
                  <fieldset key={field.id}>
                    <input {...register(`test.${index}.name`)} />
                  </fieldset>
                );
              })}
            </form>

            <form
              onSubmit={(e) => {
                e.preventDefault();
                const target = e.target as HTMLFormElement;

                setTimeout(() => {
                  insert(0, {
                    name: value,
                  });
                }, 1000);

                target.reset();
              }}
            >
              <input
                name="name"
                data-testid="input"
                value={value}
                onChange={(e) => setValue(e.target.value)}
              />
              <button>submit</button>
            </form>
          </div>
        );
      }

      render(<App />);

      fireEvent.change(screen.getByTestId('input'), {
        target: {
          value: 'test',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      act(() => {
        jest.advanceTimersByTime(1000);
      });

      expect(
        (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
      ).toEqual('test');

      fireEvent.change(screen.getByTestId('input'), {
        target: {
          value: 'test1',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      act(() => {
        jest.advanceTimersByTime(1000);
      });

      expect(
        (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
      ).toEqual('test1');
    });
  });

  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [{ id: '1234', test: 'data' }],
        },
      });

      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              insert(1, {
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            insert
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'insert' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText(
        '{"test":[{"id":"1234","test":"data"},{"id":"whatever","test":"1234"}]}',
      ),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, insert } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              insert(0, {
                id: 'whatever',
                test: '1234',
              });
            }}
          >
            insert
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'insert' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"1234"}]}'),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/useFieldArray/replace.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';

import { useController } from '../../useController';
import { useFieldArray } from '../../useFieldArray';
import { useForm } from '../../useForm';
import { FormProvider } from '../../useFormContext';

interface TestValue {
  x: string;
}

interface DefaultValues {
  test: TestValue[];
}

let i = 0;

jest.mock('../../logic/generateId', () => () => String(i++));

describe('replace', () => {
  beforeEach(() => {
    i = 0;
  });

  it('should replace fields correctly', () => {
    let currentFields: any = [];
    const defaultValues: DefaultValues = {
      test: [{ x: '101' }, { x: '102' }, { x: '103' }],
    };

    const labelSingle = 'replace';

    const labelBatch = 'replaceBatch';

    const Component = () => {
      const { register, control } = useForm<DefaultValues>({
        defaultValues,
      });
      const { fields, replace } = useFieldArray({
        control,
        name: 'test',
      });

      currentFields = fields;

      const handleSingleReplace = () => replace({ x: '201' });

      const handleBatchReplace = () => replace([{ x: '301' }, { x: '302' }]);

      return (
        <form>
          {fields.map((field, index) => {
            return (
              <input key={field.id} {...register(`test.${index}.x` as const)} />
            );
          })}
          <button type="button" onClick={handleSingleReplace}>
            {labelSingle}
          </button>
          <button type="button" onClick={handleBatchReplace}>
            {labelBatch}
          </button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button', { name: labelSingle }));

    expect(currentFields).toEqual([{ id: '3', x: '201' }]);

    fireEvent.click(screen.getByRole('button', { name: labelBatch }));

    expect(currentFields).toEqual([
      { id: '5', x: '301' },
      { id: '6', x: '302' },
    ]);
  });
  it('should not omit keyName when provided', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>({
        defaultValues: {
          test: [
            { id: '1234', test: 'data' },
            { id: '4567', test: 'data1' },
          ],
        },
      });

      const { fields, replace } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              replace([{ id: 'test', test: 'data' }]);
            }}
          >
            replace
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'replace' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"test","test":"data"}]}'),
    ).toBeVisible();
  });

  it('should not omit keyName when provided and defaultValue is empty', async () => {
    type FormValues = {
      test: {
        test: string;
        id: string;
      }[];
    };
    let k = 0;

    const App = () => {
      const [data, setData] = React.useState<FormValues>();
      const { control, register, handleSubmit } = useForm<FormValues>();

      const { fields, append, replace } = useFieldArray({
        control,
        name: 'test',
      });

      return (
        <form onSubmit={handleSubmit(setData)}>
          {fields.map((field, index) => {
            return <input key={field.id} {...register(`test.${index}.test`)} />;
          })}
          <button
            type={'button'}
            onClick={() => {
              replace([{ id: 'whatever', test: 'data' }]);
            }}
          >
            replace
          </button>

          <button
            type={'button'}
            onClick={() => {
              append({
                id: 'whatever' + k,
                test: '1234' + k,
              });
              k = 1;
            }}
          >
            append
          </button>
          <button>submit</button>
          <p>{JSON.stringify(data)}</p>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'append' }));

    fireEvent.click(screen.getByRole('button', { name: 'replace' }));

    fireEvent.click(screen.getByRole('button', { name: 'submit' }));

    expect(
      await screen.findByText('{"test":[{"id":"whatever","test":"data"}]}'),
    ).toBeVisible();
  });

  it('should not replace errors state', async () => {
    const App = () => {
      const {
        control,
        register,
        trigger,
        formState: { errors },
      } = useForm({
        defaultValues: {
          test: [
            {
              firstName: '',
            },
          ],
        },
      });
      const { fields, replace } = useFieldArray({
        name: 'test',
        control,
      });

      React.useEffect(() => {
        trigger();
      }, [trigger]);

      return (
        <form>
          {fields.map((field, i) => (
            <input
              key={field.id}
              {...register(`test.${i}.firstName` as const, {
                required: 'This is required',
              })}
            />
          ))}
          <p>{errors?.test?.[0]?.firstName?.message}</p>
          <button
            type={'button'}
            onClick={() =>
              replace([
                {
                  firstName: 'firstName',
                },
              ])
            }
          >
            update
          </button>
        </form>
      );
    };

    render(<App />);

    expect(await screen.findByText('This is required')).toBeVisible();

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('This is required')).toBeVisible();
  });

  it('should not affect other formState during replace action', () => {
    const ControlledInput = ({ index }: { index: number }) => {
      const { field } = useController({
        name: `fieldArray.${index}.firstName`,
      });
      return <input {...field} />;
    };

    const defaultValue = {
      firstName: 'test',
    };

    const FieldArray = () => {
      const { fields, replace } = useFieldArray({
        name: 'fieldArray',
      });

      React.useEffect(() => {
        replace([defaultValue]);
      }, [replace]);

      return (
        <div>
          {fields.map((field, index) => {
            return <ControlledInput key={field.id} index={index} />;
          })}

          <button type="button" onClick={() => replace(defaultValue)}>
            replace
          </button>
        </div>
      );
    };

    function App() {
      const form = useForm({
        mode: 'onChange',
      });
      const [, updateState] = React.useState(0);

      return (
        <FormProvider {...form}>
          <FieldArray />
          <p>{JSON.stringify(form.formState.touchedFields)}</p>
          <button onClick={() => updateState(1)}>updateState</button>
        </FormProvider>
      );
    }

    render(<App />);

    fireEvent.focus(screen.getByRole('textbox'));
    fireEvent.blur(screen.getByRole('textbox'));
    fireEvent.click(screen.getByRole('button', { name: 'replace' }));
    fireEvent.click(screen.getByRole('button', { name: 'updateState' }));

    expect(
      screen.getByText('{"fieldArray":[{"firstName":true}]}'),
    ).toBeVisible();
  });
});


================================================
File: /src/__tests__/form.test.tsx
================================================
import 'whatwg-fetch';

import React from 'react';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';
import { http, HttpResponse } from 'msw';
import { setupServer } from 'msw/node';

import { Form } from '../form';
import { useForm } from '../useForm';
import { FormProvider } from '../useFormContext';

const server = setupServer(
  http.post('/success', () => {
    return HttpResponse.json({ message: 'ok' });
  }),
  http.post('/error', () => {
    return new Response(null, {
      status: 500,
    });
  }),
  http.post('/status', () => {
    return new HttpResponse(null, { status: 201 });
  }),
  http.post('/get', () => {
    return new HttpResponse(null, { status: 200 });
  }),
  http.post('/json', ({ request }) => {
    if (request.headers.get('content-type') === 'application/json') {
      return new HttpResponse(null, { status: 200 });
    }

    return new HttpResponse(null, { status: 500 });
  }),
);

describe('Form', () => {
  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());

  it('should support render with both form tag and headless', () => {
    const WithContext = () => {
      return (
        <>
          <Form />
          <Form
            render={() => {
              return null;
            }}
          />
        </>
      );
    };

    const App = () => {
      const methods = useForm();
      return (
        <div>
          <Form control={methods.control}>
            <input />
          </Form>
          <Form
            control={methods.control}
            render={() => {
              return null;
            }}
          />

          <FormProvider {...methods}>
            <WithContext />
          </FormProvider>
        </div>
      );
    };

    render(<App />);
  });

  it('should handle success request callback', async () => {
    const onSubmit = jest.fn();
    const onError = jest.fn();

    const App = () => {
      const [message, setMessage] = React.useState('');
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form
          encType={'application/json'}
          action={'/success'}
          onSubmit={({ data, formData, formDataJson }) => {
            data;
            formData;
            formDataJson;
            onSubmit();
          }}
          control={control}
          onError={onError}
          onSuccess={async ({ response }) => {
            if (response) {
              const data: { message: string } = await response.json();
              setMessage(data.message);
            }
          }}
        >
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
          <p>{message}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(onSubmit).toBeCalled();
      expect(onError).not.toBeCalled();
      screen.getByText('submitSuccessful');
      screen.getByText('ok');
    });
  });

  it('should handle error request callback', async () => {
    const onSubmit = jest.fn();
    const onSuccess = jest.fn();

    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful, errors },
      } = useForm();

      return (
        <Form
          encType={'application/json'}
          action={'/error'}
          onSubmit={onSubmit}
          control={control}
        >
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
          {errors.root?.server && 'This is a server error'}
          <p>{errors.root?.server?.type}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(onSubmit).toBeCalled();
      expect(onSuccess).not.toBeCalled();
      screen.getByText('This is a server error');
      screen.getByText('500');
      screen.getByText('submitFailed');
    });
  });

  it('should validate custom status code', async () => {
    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form
          encType={'application/json'}
          action={'/status'}
          control={control}
          validateStatus={(status) => status === 200}
        >
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('submitFailed');
    });
  });

  it('should support other request type', async () => {
    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form encType={'application/json'} action={'/get'} control={control}>
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('submitSuccessful');
    });
  });

  it('should support render props for react native', async () => {
    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form
          control={control}
          render={({ submit }) => {
            return (
              <>
                <button onClick={() => submit()}>Submit</button>
                <p>
                  {isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}
                </p>
              </>
            );
          }}
        />
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('submitSuccessful');
    });
  });

  it('should support fetcher prop with external request', async () => {
    const fetcher = jest.fn();
    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form
          control={control}
          onSubmit={async () => {
            await fetcher();
          }}
        >
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      screen.getByText('submitSuccessful');

      expect(fetcher).toBeCalled();
    });
  });

  it('should include application/json header with encType supplied', async () => {
    const onSuccess = jest.fn();
    const App = () => {
      const {
        control,
        formState: { isSubmitSuccessful },
      } = useForm();

      return (
        <Form
          encType={'application/json'}
          action={'/json'}
          control={control}
          onSuccess={onSuccess}
        >
          <button>Submit</button>
          <p>{isSubmitSuccessful ? 'submitSuccessful' : 'submitFailed'}</p>
        </Form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(onSuccess).toBeCalled();
    });
  });
});


================================================
File: /src/__tests__/useForm.server.test.tsx
================================================
import React from 'react';
import { renderToString } from 'react-dom/server';

import { useForm } from '../useForm';

describe('useForm with SSR', () => {
  it('should not output error', () => {
    const Component = () => {
      const { register } = useForm<{
        test: string;
      }>();
      return (
        <div>
          <input {...register('test')} />
        </div>
      );
    };

    const spy = jest.spyOn(console, 'error');

    expect(renderToString(<Component />)).toEqual(
      '<div><input name="test"/></div>',
    );

    expect(spy).not.toHaveBeenCalled();
  });

  it('should display error with errors prop', () => {
    const App = () => {
      const {
        register,
        formState: { errors },
      } = useForm<{
        test: string;
      }>({
        errors: {
          test: { type: 'test', message: 'test error' },
        },
      });

      return (
        <div>
          <input {...register('test')} />
          <span role="alert">{errors.test && errors.test.message}</span>
        </div>
      );
    };

    expect(renderToString(<App />)).toEqual(
      '<div><input name="test"/><span role="alert">test error</span></div>',
    );
  });

  it('should not pass down constrained API for server side rendering', () => {
    const App = () => {
      const { register } = useForm<{
        test: string;
      }>();

      return (
        <div>
          <input
            {...register('test', {
              required: true,
              min: 2,
              max: 2,
              maxLength: 2,
              minLength: 2,
            })}
          />
        </div>
      );
    };

    expect(renderToString(<App />)).toEqual('<div><input name="test"/></div>');
  });

  it('should pass down constrained API for server side rendering', () => {
    const App = () => {
      const { register } = useForm<{
        test: string;
      }>({
        shouldUseNativeValidation: true,
      });

      return (
        <div>
          <input
            {...register('test', {
              required: true,
              min: 2,
              max: 2,
              maxLength: 2,
              minLength: 2,
            })}
          />
        </div>
      );
    };

    expect(renderToString(<App />)).toEqual('<div><input name="test"/></div>');
  });

  it('should support progress enhancement for form', () => {
    const App = () => {
      const { register } = useForm<{
        test: string;
      }>({
        progressive: true,
      });

      return (
        <div>
          <input
            {...register('test', {
              required: true,
              min: 2,
              max: 2,
              maxLength: 2,
              minLength: 2,
            })}
          />
        </div>
      );
    };

    expect(renderToString(<App />)).toEqual(
      '<div><input required="" min="2" max="2" minLength="2" maxLength="2" name="test"/></div>',
    );
  });
});


================================================
File: /src/__tests__/useFormState.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';

import { Controller } from '../controller';
import { Control } from '../types';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { FormProvider } from '../useFormContext';
import { useFormState } from '../useFormState';
import deepEqual from '../utils/deepEqual';
import noop from '../utils/noop';

describe('useFormState', () => {
  it('should render correct form state with isDirty, dirty, touched', () => {
    let count = 0;
    const Test = ({
      control,
    }: {
      control: Control<{
        test: string;
      }>;
    }) => {
      const { isDirty, dirtyFields, touchedFields } = useFormState({
        control,
      });

      return (
        <>
          <div>{isDirty ? 'isDirty' : ''}</div>
          <div>{dirtyFields['test'] ? 'dirty field' : ''}</div>
          <div>{touchedFields['test'] ? 'isTouched' : ''}</div>
        </>
      );
    };

    const Component = () => {
      const { register, control } = useForm<{
        test: string;
      }>();

      count++;

      return (
        <div>
          <input aria-label="test" {...register('test')} />
          <Test control={control} />
        </div>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByLabelText('test'), {
      target: {
        value: 'test',
      },
    });

    expect(screen.getByText('isDirty')).toBeVisible();
    expect(screen.getByText('dirty field')).toBeVisible();
    expect(count).toEqual(1);

    fireEvent.blur(screen.getByLabelText('test'));
    expect(screen.getByText('isTouched')).toBeVisible();
    expect(count).toEqual(1);
  });

  it('should render correct isolated errors message', async () => {
    let count = 0;
    const Test = ({ control }: { control: Control }) => {
      const { errors, isValid } = useFormState({
        control,
      });

      return (
        <>
          <div>{errors['test'] ? 'error' : 'valid'}</div>
          <div>{isValid ? 'yes' : 'no'}</div>
        </>
      );
    };

    const Component = () => {
      const { register, control } = useForm({
        mode: 'onChange',
      });

      count++;

      return (
        <div>
          <input aria-label="test" {...register('test', { minLength: 5 })} />
          <Test control={control} />
        </div>
      );
    };
    render(<Component />);

    await waitFor(() => expect(screen.getByText('yes')).toBeVisible());

    fireEvent.input(screen.getByLabelText('test'), {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByText('error')).toBeVisible();
    expect(screen.getByText('no')).toBeVisible();

    fireEvent.input(screen.getByLabelText('test'), {
      target: {
        value: 'testtest',
      },
    });

    expect(await screen.findByText('valid')).toBeVisible();
    expect(screen.getByText('yes')).toBeVisible();

    expect(count).toEqual(1);
  });

  it('should update isValidating correctly', async () => {
    function Child() {
      const { isDirty, isValid, isValidating } = useFormState();
      const enabled = !isValidating && isDirty && isValid;

      return (
        <button disabled={!enabled} type="submit">
          Submit
        </button>
      );
    }

    function App() {
      const formFunctions = useForm({
        mode: 'onChange',
      });
      const { register } = formFunctions;

      return (
        <FormProvider {...formFunctions}>
          <form>
            <input {...register('value', { required: true })} />
            <Child />
          </form>
        </FormProvider>
      );
    }

    render(<App />);

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '1',
      },
    });

    await waitFor(() => {
      expect(screen.getByRole('button')).not.toBeDisabled();
    });

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: '12',
      },
    });

    await waitFor(() => {
      expect(screen.getByRole('button')).not.toBeDisabled();
    });
  });

  it('should update formState separately with useFormState', async () => {
    let count = 0;
    let testCount = 0;
    let test1Count = 0;

    const Test1 = ({ control }: { control: Control }) => {
      const { isDirty, dirtyFields } = useFormState({
        control,
      });

      testCount++;

      return (
        <>
          <div>
            {dirtyFields['test'] ? 'hasDirtyField' : 'notHasDirtyField'}
          </div>
          <div>{isDirty ? 'isDirty' : 'notDirty'}</div>
        </>
      );
    };

    const Test = ({ control }: { control: Control }) => {
      const { touchedFields } = useFormState({
        control,
      });

      test1Count++;

      return (
        <>
          <div>{touchedFields['test'] ? 'isTouched' : 'notTouched'}</div>
        </>
      );
    };

    const Component = () => {
      const { register, control } = useForm({
        mode: 'onChange',
      });

      count++;

      return (
        <div>
          <input aria-label="test" {...register('test', { minLength: 5 })} />
          <Test control={control} />
          <Test1 control={control} />
        </div>
      );
    };

    render(<Component />);

    fireEvent.input(screen.getByLabelText('test'), {
      target: {
        value: 'test',
      },
    });

    expect(await screen.findByText('hasDirtyField')).toBeVisible();
    expect(screen.getByText('isDirty')).toBeVisible();

    expect(count).toEqual(1);
    expect(testCount).toEqual(2);
    expect(test1Count).toEqual(1);

    fireEvent.blur(screen.getByLabelText('test'));
    expect(screen.getByText('isTouched')).toBeVisible();

    expect(count).toEqual(1);
    expect(testCount).toEqual(2);
    expect(test1Count).toEqual(2);

    fireEvent.input(screen.getByLabelText('test'), {
      target: {
        value: '',
      },
    });

    expect(count).toEqual(1);
    expect(testCount).toEqual(2);
    expect(test1Count).toEqual(2);
  });

  it('should render correct submit state', async () => {
    let count = 0;
    const Test = ({ control }: { control: Control }) => {
      const { isSubmitted, submitCount } = useFormState({
        control,
      });

      return (
        <>
          <div>{isSubmitted ? 'isSubmitted' : ''}</div>
          <div>{submitCount}</div>
        </>
      );
    };

    const Component = () => {
      const { control, handleSubmit } = useForm();

      count++;

      return (
        <form onSubmit={handleSubmit(noop)}>
          <Test control={control} />
          <button>Submit</button>
        </form>
      );
    };

    render(<Component />);

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.findByText('isSubmitted')).toBeVisible();
    expect(screen.getByText('1')).toBeVisible();

    expect(count).toEqual(1);
  });

  it('should only re-render when subscribed field name updated', async () => {
    let count = 0;

    type FormValues = {
      firstName: string;
      lastName: string;
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { errors } = useFormState({
        control,
        name: 'firstName',
      });

      count++;

      return <>{errors?.firstName?.message}</>;
    };

    const Component = () => {
      const { control, register } = useForm<FormValues>({
        mode: 'onChange',
        defaultValues: {
          firstName: 'a',
          lastName: 'b',
        },
      });

      return (
        <form>
          <Test control={control} />
          <input
            {...register('firstName', { required: true })}
            placeholder={'firstName'}
          />
          <input {...register('lastName')} />
        </form>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: {
        value: '',
      },
    });

    await waitFor(() => expect(count).toEqual(2));
  });

  it('should not re-render when subscribed field name is not included', async () => {
    let count = 0;

    type FormValues = {
      firstName: string;
      lastName: string;
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { errors } = useFormState({
        control,
        name: 'lastName',
      });

      count++;

      return <>{errors?.lastName?.message}</>;
    };

    const Component = () => {
      const { control, register } = useForm<FormValues>({
        mode: 'onChange',
        defaultValues: {
          firstName: 'a',
          lastName: 'b',
        },
      });

      return (
        <form>
          <Test control={control} />
          <input
            {...register('firstName', { required: true })}
            placeholder={'firstName'}
          />
          <input {...register('lastName')} />
        </form>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: {
        value: '',
      },
    });

    expect(count).toEqual(1);
  });

  it('should only re-render when subscribed field names updated', async () => {
    let count = 0;

    type FormValues = {
      firstName: string;
      lastName: string;
      age: number;
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { errors } = useFormState({
        control,
        name: ['firstName', 'lastName'],
      });

      count++;

      return <>{errors?.firstName?.message}</>;
    };

    const Component = () => {
      const { control, register } = useForm<FormValues>({
        mode: 'onChange',
        defaultValues: {
          firstName: 'a',
          lastName: 'b',
        },
      });

      return (
        <form>
          <Test control={control} />
          <input
            {...register('firstName', { required: true })}
            placeholder={'firstName'}
          />
          <input
            {...register('lastName', { required: true })}
            placeholder={'lastName'}
          />
          <input
            {...register('age', { valueAsNumber: true, required: true })}
            type="number"
          />
        </form>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: {
        value: '',
      },
    });

    fireEvent.change(screen.getByPlaceholderText('lastName'), {
      target: {
        value: '',
      },
    });

    await waitFor(() => expect(count).toEqual(2));
  });

  it('should only re-render when subscribed field names updated', async () => {
    let count = 0;

    type FormValues = {
      firstName: string;
      lastName: string;
      age: number;
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const { errors } = useFormState({
        control,
        name: ['age', 'lastName'],
      });

      count++;

      return <>{errors?.firstName?.message}</>;
    };

    const Component = () => {
      const { control, register } = useForm<FormValues>({
        mode: 'onChange',
        defaultValues: {
          firstName: 'a',
          lastName: 'b',
        },
      });

      return (
        <form>
          <Test control={control} />
          <input
            {...register('firstName', { required: true })}
            placeholder={'firstName'}
          />
          <input {...register('lastName')} placeholder={'lastName'} />
          <input
            {...register('age', { valueAsNumber: true, required: true })}
            type="number"
          />
        </form>
      );
    };

    render(<Component />);

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: {
        value: '',
      },
    });

    expect(count).toEqual(1);
  });

  it('should be able to stop the formState subscription', async () => {
    type FormValues = {
      test: string;
    };

    function Child({ control }: { control: Control<FormValues> }) {
      const [disabled, setDisabled] = React.useState(true);
      const { errors } = useFormState({
        control,
        name: 'test',
        disabled,
      });

      return (
        <div>
          {errors.test && <p>error</p>}
          <button onClick={() => setDisabled(!disabled)}>toggle</button>
        </div>
      );
    }

    const App = () => {
      const { trigger, register, control } = useForm<FormValues>();

      return (
        <div>
          <input {...register('test', { required: true })} />
          <Child control={control} />
          <button
            onClick={() => {
              trigger();
            }}
          >
            trigger
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    expect(screen.queryByText('error')).not.toBeInTheDocument();

    fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

    fireEvent.click(screen.getByRole('button', { name: 'trigger' }));

    expect(await screen.findByText('error')).toBeVisible();
  });

  it('should not start early subscription and throw warning at strict mode', async () => {
    type FormValues = { test: { data: string }[] };

    function FieldArray() {
      const { reset, control } = useForm<FormValues>({
        defaultValues: { test: [] },
      });
      const { fields, append } = useFieldArray({ control, name: 'test' });
      return (
        <div>
          {fields.map((field, index) => (
            <div key={field.id}>
              <Controller
                control={control}
                name={`test.${index}.data` as const}
                render={({ field }) => <input {...field} />}
              />
            </div>
          ))}
          <button
            onClick={() =>
              append({
                data: 'data',
              })
            }
          >
            add
          </button>
          <button onClick={() => reset({})}>reset</button>
        </div>
      );
    }

    const App = () => {
      return (
        <React.StrictMode>
          <FieldArray />
        </React.StrictMode>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: 'add' }));

    fireEvent.click(screen.getByRole('button', { name: 'reset' }));

    fireEvent.click(screen.getByRole('button', { name: 'add' }));

    expect(await screen.findAllByRole('textbox')).toHaveLength(1);
  });

  it('should subscribe to exact form state update', () => {
    const App = () => {
      const { control, register } = useForm();
      const [exact, setExact] = React.useState(true);
      const { touchedFields } = useFormState({
        name: 'test',
        control,
        exact,
      });

      return (
        <div>
          <input {...register('testData')} />
          <p>{touchedFields.testData && 'touched'}</p>

          <button
            onClick={() => {
              setExact(false);
            }}
          >
            toggle
          </button>
        </div>
      );
    };

    render(<App />);

    fireEvent.focus(screen.getByRole('textbox'));

    fireEvent.blur(screen.getByRole('textbox'));

    expect(screen.queryByText('touched')).not.toBeInTheDocument();

    fireEvent.click(screen.getByRole('button'));

    fireEvent.focus(screen.getByRole('textbox'));

    fireEvent.blur(screen.getByRole('textbox'));

    expect(screen.getByText('touched')).toBeVisible();
  });

  it('should be able to access defaultValues', () => {
    type FormValues = {
      firstName: string;
      lastName: string;
    };

    const defaultValues = {
      firstName: 'a',
      lastName: 'b',
    };

    const Test = ({ control }: { control: Control<FormValues> }) => {
      const formState = useFormState({
        control,
      });

      return (
        <p>
          {deepEqual(formState.defaultValues, defaultValues) ? 'yes' : 'no'}
        </p>
      );
    };

    const Component = () => {
      const { control } = useForm<FormValues>({
        defaultValues,
      });

      return <Test control={control} />;
    };

    render(<Component />);

    expect(screen.getByText('yes')).toBeVisible();
  });

  it('should conditionally update formState after mount', async () => {
    function DirtyState() {
      const { isDirty, isValid } = useFormState();
      return (
        <div>
          <p>{isDirty ? 'dirty' : 'pristine'}</p>
          <p>{isValid ? 'valid' : 'error'}</p>
        </div>
      );
    }

    function App() {
      const [showDirty, toggleShowDirty] = React.useReducer(
        (prev) => !prev,
        false,
      );
      const formMethods = useForm({
        defaultValues: {
          firstname: '',
        },
      });

      return (
        <FormProvider {...formMethods}>
          {showDirty && <DirtyState />}
          <input {...formMethods.register('firstname', { required: true })} />
          <button type="button" onClick={toggleShowDirty} />
        </FormProvider>
      );
    }

    render(<App />);

    expect(screen.queryByRole('pristine')).not.toBeInTheDocument();

    fireEvent.change(screen.getByRole('textbox'), {
      target: {
        value: 'test',
      },
    });

    fireEvent.click(screen.getByRole('button'));

    expect(await screen.queryByText('dirty')).toBeNull();
    expect(await screen.findByText('valid')).toBeVisible();
  });

  it('should subscribe and update formState', async () => {
    function App() {
      const { register, control, handleSubmit } = useForm({
        defaultValues: {
          firstName: '',
        },
      });
      const { errors } = useFormState({ control });

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input {...register('firstName', { required: 'Required' })} />
          <p>{errors.firstName?.message}</p>
          <button>Submit</button>
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    waitFor(() => screen.getByText('Required'));

    fireEvent.change(screen.getByRole('textbox'), {
      target: { value: 'data' },
    });

    waitFor(() =>
      expect(screen.queryByText('Required')).not.toBeInTheDocument(),
    );
  });

  it('should return the latest values with async values', async () => {
    type FormValues = {
      firstName: string;
    };

    function Input({ control }: { control: Control<FormValues> }) {
      const { isValid } = useFormState({ control });

      return <p>{isValid}</p>;
    }

    function Form({ values }: { values: FormValues }) {
      const { getValues, control } = useForm<FormValues>({
        defaultValues: {
          firstName: '',
        },
        values,
        resetOptions: {
          keepDefaultValues: true,
        },
      });

      return (
        <>
          <p>{getValues().firstName}</p>
          <Input control={control} />
        </>
      );
    }

    function App() {
      return <Form values={{ firstName: 'test' }} />;
    }

    render(<App />);

    await waitFor(() => {
      screen.getByText('test');
    });
  });

  it('should update form state with disabled state', async () => {
    function Form({ control }: { control: Control }) {
      const { disabled } = useFormState({
        control,
      });

      return <p>{disabled ? 'disabled' : ''}</p>;
    }

    function App() {
      const { control } = useForm({
        disabled: true,
      });

      return <Form control={control} />;
    }

    render(<App />);

    await waitFor(() => {
      screen.getByText('disabled');
    });
  });
});


================================================
File: /src/__tests__/useFormContext.server.test.tsx
================================================
import React from 'react';
import { renderToString } from 'react-dom/server';

import { useController } from '../useController';
import { useForm } from '../useForm';
import { FormProvider, useFormContext } from '../useFormContext';
import { useFormState } from '../useFormState';
import { useWatch } from '../useWatch';

describe('FormProvider', () => {
  it('should work correctly with Controller, useWatch, useFormState.', () => {
    const App = () => {
      const { field } = useController({
        name: 'test',
        defaultValue: '',
      });
      return <input {...field} />;
    };

    const TestWatch = () => {
      const value = useWatch({
        name: 'test',
      });

      return <p>{value}</p>;
    };

    const TestFormState = () => {
      const { isDirty } = useFormState();

      return <div>{isDirty ? 'yes' : 'no'}</div>;
    };

    const TestUseFormContext = () => {
      const methods = useFormContext();
      methods.register('test');
      return null;
    };

    const Component = () => {
      const methods = useForm();

      return (
        <FormProvider {...methods}>
          <App />
          <TestUseFormContext />
          <TestWatch />
          <TestFormState />
        </FormProvider>
      );
    };

    const output = renderToString(<Component />);

    expect(output).toEqual('<input name="test" value=""/><p></p><div>no</div>');
  });
});


================================================
File: /src/__tests__/utils/set.test.ts
================================================
import set from '../../utils/set';

describe('set', () => {
  it('should set the correct values', () => {
    const test1 = { a: [{ b: { c: 3 } }] };
    expect(set(test1, 'a[0].b.c', 4)).toEqual(4);
    expect(test1.a[0].b.c).toEqual(4);

    const test2 = { foo: { bar: 'baz' } };
    expect(set(test2, 'foo.arr[0]', 3)).toEqual(3);
    expect(test2).toEqual({
      foo: {
        bar: 'baz',
        arr: [3],
      },
    });

    const test3 = { foo: { bar: 'baz' } };
    expect(set(test3, 'foo.arr["1"]', true)).toEqual(true);
    expect(test3).toEqual({
      foo: {
        bar: 'baz',
        arr: [, true],
      },
    });

    const test4 = { foo: { bar: 'baz' } };
    expect(set(test4, 'foo.obj.key', 'test')).toEqual('test');
    expect(test4).toEqual({
      foo: {
        bar: 'baz',
        obj: { key: 'test' },
      },
    });

    const test5 = { foo: 1 };
    expect(set(test5, 'foo.obj.key', 3)).toEqual(3);
    expect(test5).toEqual({
      foo: {
        obj: {
          key: 3,
        },
      },
    });

    const test6 = {};
    expect(set(test6, 'foo.arr[0].obj.key', 1)).toEqual(1);
    expect(test6).toEqual({
      foo: {
        arr: [
          {
            obj: {
              key: 1,
            },
          },
        ],
      },
    });
  });

  it('should not populate prototype', () => {
    set({}, '__proto__[test2]', '456');
    expect(Object.prototype).toEqual({});
  });
});


================================================
File: /src/__tests__/utils/prepend.test.ts
================================================
import prepend from '../../utils/prepend';

describe('prepend', () => {
  it('should prepend value to an array', () => {
    expect(prepend([2, 3, 4], 1)).toEqual([1, 2, 3, 4]);
    expect(
      prepend(
        [
          {
            firstName: '2',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '3',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '4',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
        ],
        {
          firstName: '1',
          lastName: 'Luo',
          id: '75309979-e340-49eb-8016-5f67bfb56c1c',
        },
      ),
    ).toEqual([
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '4',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ]);
  });

  it('should prepend undefined as value when value to be prepended is falsy', () => {
    expect(prepend([2, 3, 4], 0)).toEqual([0, 2, 3, 4]);
    expect(prepend([2, 3, 4] as (number | boolean)[], false)).toEqual([
      false,
      2,
      3,
      4,
    ]);
    expect(prepend([2, 3, 4] as (number | string)[], '')).toEqual([
      '',
      2,
      3,
      4,
    ]);
    expect(prepend([2, 3, 4], undefined)).toEqual([undefined, 2, 3, 4]);
  });

  it('should spread value when it is an array at one deep-level', () => {
    expect(prepend([3, 4], [1, 2])).toEqual([1, 2, 3, 4]);
    expect(prepend([3, 4], [[1], 2])).toEqual([[1], 2, 3, 4]);
  });
});


================================================
File: /src/__tests__/utils/isObject.test.ts
================================================
import isObject from '../../utils/isObject';

describe('isObject', () => {
  it('should return true when value is an object', () => {
    expect(isObject({})).toBeTruthy();
    expect(isObject({ foo: 'bar' })).toBeTruthy();
    expect(isObject(new Blob())).toBeTruthy();
  });

  it('should return false when value is not an object or is null', () => {
    expect(isObject(null)).toBeFalsy();
    expect(isObject(undefined)).toBeFalsy();
    expect(isObject(-1)).toBeFalsy();
    expect(isObject(0)).toBeFalsy();
    expect(isObject(1)).toBeFalsy();
    expect(isObject('')).toBeFalsy();
    expect(isObject([])).toBeFalsy();
    expect(isObject(['foo', 'bar'])).toBeFalsy();
    expect(isObject(() => null)).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/isBoolean.test.ts
================================================
import isBoolean from '../../utils/isBoolean';

describe('isBoolean', () => {
  it('should return true when value is a boolean', () => {
    expect(isBoolean(true)).toBeTruthy();
    expect(isBoolean(false)).toBeTruthy();
  });

  it('should return false when value is not a boolean', () => {
    expect(isBoolean(null)).toBeFalsy();
    expect(isBoolean(undefined)).toBeFalsy();
    expect(isBoolean(-1)).toBeFalsy();
    expect(isBoolean(0)).toBeFalsy();
    expect(isBoolean(1)).toBeFalsy();
    expect(isBoolean('')).toBeFalsy();
    expect(isBoolean({})).toBeFalsy();
    expect(isBoolean([])).toBeFalsy();
    expect(isBoolean(() => null)).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/flatten.test.ts
================================================
import { flatten } from '../../utils/flatten';

describe('flatten', () => {
  it('should flatten form values into flat form data', () => {
    expect(
      flatten({
        hey: 'test',
        array: [
          {
            test: '1',
            test2: '2',
            test3: null,
          },
        ],
        test: {
          nested: {
            test: 'bill',
            test3: null,
          },
        },
        test1: null,
      }),
    ).toMatchSnapshot();
  });
});


================================================
File: /src/__tests__/utils/remove.test.ts
================================================
import remove from '../../utils/remove';

describe('remove', () => {
  it('should remove item accordingly', () => {
    expect(
      remove([, , { type: 'required', message: '', ref: 'test' }], 1),
    ).toEqual([undefined, { type: 'required', message: '', ref: 'test' }]);

    expect(
      remove([, , { type: 'required', message: '', ref: 'test' }], [1, 2]),
    ).toEqual([]);

    expect(
      remove([, , { type: 'required', message: '', ref: 'test' }], [0, 1]),
    ).toEqual([{ type: 'required', message: '', ref: 'test' }]);

    expect(
      remove(
        [
          ,
          ,
          { type: 'required', message: '', ref: 'test' },
          { type: 'required', message: '', ref: 'test' },
          null,
          ,
        ],
        [3, 2],
      ),
    ).toEqual([]);

    expect(
      remove(
        [
          ,
          ,
          { type: 'required', message: '', ref: 'test' },
          { type: 'required', message: '', ref: 'test' },
          null,
          ,
        ],
        [1, 4],
      ),
    ).toEqual([
      undefined,
      { type: 'required', message: '', ref: 'test' },
      { type: 'required', message: '', ref: 'test' },
      undefined,
    ]);

    expect(remove([true, true, true], [1])).toEqual([true, true]);
    expect(remove([true, true, true], [0])).toEqual([true, true]);

    expect(
      remove([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [6, 7, 8, 9, 10, 11]),
    ).toEqual([0, 1, 2, 3, 4, 5]);
    expect(
      remove([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [11, 10, 9, 8, 7, 6]),
    ).toEqual([0, 1, 2, 3, 4, 5]);
  });

  it('should remove correctly with indexes which contains gap', () => {
    expect(
      remove(
        [
          ,
          ,
          { type: 'required', message: '', ref: 'test' },
          { type: 'required', message: '', ref: 'test' },
          null,
          { type: 'required', message: '', ref: 'test' },
          ,
          { type: 'required', message: '', ref: 'test' },
        ],
        [2, 5],
      ),
    ).toEqual([
      ,
      ,
      { type: 'required', message: '', ref: 'test' },
      null,
      ,
      { type: 'required', message: '', ref: 'test' },
    ]);
  });

  it('should remove all items', () => {
    expect(
      remove(
        [
          {
            firstName: '1',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '2',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '3',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '4',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '5',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '6',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '7',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '8',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '9',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
        ],
        [0, 1, 2, 3, 4, 5, 6, 7, 8],
      ),
    ).toEqual([]);
  });
});


================================================
File: /src/__tests__/utils/isRadioInput.test.ts
================================================
import isRadioInput from '../../utils/isRadioInput';

describe('isRadioInput', () => {
  it('should return true when type is radio', () => {
    expect(isRadioInput({ name: 'test', type: 'radio' })).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/isFileInput.test.ts
================================================
import isFileInput from '../../utils/isFileInput';

describe('isFileInput', () => {
  it('should return true when type is file', () => {
    expect(isFileInput({ name: 'test', type: 'file' })).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/isMessage.test.ts
================================================
import isMessage from '../../utils/isMessage';

describe('isBoolean', () => {
  it('should return true when value is a Message', () => {
    expect(isMessage('test')).toBeTruthy();
  });

  it('should return false when value is not a Message', () => {
    expect(isMessage(null)).toBeFalsy();
    expect(isMessage(undefined)).toBeFalsy();
    expect(isMessage(-1)).toBeFalsy();
    expect(isMessage(1)).toBeFalsy();
    expect(isMessage({})).toBeFalsy();
    expect(isMessage([])).toBeFalsy();
    expect(isMessage(() => null)).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/createSubject.test.ts
================================================
import createSubject from '../../utils/createSubject';

describe('createSubject', () => {
  it('should subscribe to all the correct observer', () => {
    const subject = createSubject();
    const next = jest.fn();

    subject.subscribe({
      next,
    });

    subject.subscribe({
      next,
    });

    expect(subject.observers.length).toBe(2);

    subject.next(2);

    expect(next).toBeCalledTimes(2);
    expect(next).toBeCalledWith(2);
  });

  it('should unsubscribe observers', () => {
    const subject = createSubject();
    const next1 = jest.fn();
    const next2 = jest.fn();

    const subscription = subject.subscribe({
      next: next1,
    });

    subject.subscribe({
      next: next2,
    });

    expect(subject.observers.length).toBe(2);

    subscription.unsubscribe();

    expect(subject.observers.length).toBe(1);

    subject.next(2);

    expect(next1).not.toBeCalled();
    expect(next2).toBeCalledWith(2);
  });

  it('should unsubscribe all observers', () => {
    const subject = createSubject();
    const next = jest.fn();

    subject.subscribe({
      next,
    });

    subject.subscribe({
      next,
    });

    expect(subject.observers.length).toBe(2);

    subject.unsubscribe();

    expect(subject.observers.length).toBe(0);

    subject.next(2);
    subject.next(2);

    expect(next).not.toBeCalled();
  });
});


================================================
File: /src/__tests__/utils/validationModeChecker.test.ts
================================================
import { VALIDATION_MODE } from '../../constants';
import validationModeChecker from '../../logic/getValidationModes';

describe('validationModeChecker', () => {
  it('should return correct mode', () => {
    expect(validationModeChecker(VALIDATION_MODE.onBlur)).toEqual({
      isOnSubmit: false,
      isOnBlur: true,
      isOnChange: false,
      isOnAll: false,
      isOnTouch: false,
    });

    expect(validationModeChecker(VALIDATION_MODE.onChange)).toEqual({
      isOnSubmit: false,
      isOnBlur: false,
      isOnChange: true,
      isOnAll: false,
      isOnTouch: false,
    });

    expect(validationModeChecker(VALIDATION_MODE.onSubmit)).toEqual({
      isOnSubmit: true,
      isOnBlur: false,
      isOnChange: false,
      isOnAll: false,
      isOnTouch: false,
    });

    expect(validationModeChecker(undefined)).toEqual({
      isOnSubmit: true,
      isOnBlur: false,
      isOnChange: false,
      isOnAll: false,
      isOnTouch: false,
    });

    expect(validationModeChecker(VALIDATION_MODE.all)).toEqual({
      isOnSubmit: false,
      isOnBlur: false,
      isOnChange: false,
      isOnAll: true,
      isOnTouch: false,
    });

    expect(validationModeChecker(VALIDATION_MODE.onTouched)).toEqual({
      isOnSubmit: false,
      isOnBlur: false,
      isOnChange: false,
      isOnAll: false,
      isOnTouch: true,
    });
  });
});


================================================
File: /src/__tests__/utils/insert.test.ts
================================================
import insert from '../../utils/insert';

describe('insert', () => {
  it('should insert value at specific index in array', () => {
    expect(insert([1, 3, 4], 1, 2)).toEqual([1, 2, 3, 4]);
    expect(
      insert(
        [
          {
            firstName: '1',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '2',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
          {
            firstName: '4',
            lastName: 'Luo',
            id: '75309979-e340-49eb-8016-5f67bfb56c1c',
          },
        ],
        2,
        {
          firstName: '3',
          lastName: 'Luo',
          id: '75309979-e340-49eb-8016-5f67bfb56c1c',
        },
      ),
    ).toEqual([
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '4',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ]);
  });

  it('should insert undefined as value when value to be inserted is falsy', () => {
    expect(insert([1, 2, 4], 2)).toEqual([1, 2, undefined, 4]);
    expect(insert([1, 2, 4], 2, 0)).toEqual([1, 2, 0, 4]);
    expect(insert([1, 2, 4] as (boolean | number)[], 2, false)).toEqual([
      1,
      2,
      false,
      4,
    ]);
    expect(insert([1, 2, 4] as (number | string)[], 2, '')).toEqual([
      1,
      2,
      '',
      4,
    ]);
    expect(insert([1, 2, 4], 2, undefined)).toEqual([1, 2, undefined, 4]);
  });

  it('should spread value when it is an array at one deep-level', () => {
    expect(insert([1, 2], 2, [3, 4])).toEqual([1, 2, 3, 4]);
    expect(insert([1, 2], 2, [3, [4]])).toEqual([1, 2, 3, [4]]);
  });
});


================================================
File: /src/__tests__/utils/isRadioOrCheckbox.test.ts
================================================
import isRadioOrCheckbox from '../../utils/isRadioOrCheckbox';

describe('isRadioOrCheckbox', () => {
  it('should return true when type is either radio or checkbox', () => {
    expect(isRadioOrCheckbox({ name: 'test', type: 'radio' })).toBeTruthy();
    expect(isRadioOrCheckbox({ name: 'test', type: 'checkbox' })).toBeTruthy();
  });

  it('shoudl return false when type is neither radio nor checkbox', () => {
    expect(isRadioOrCheckbox({ name: 'test', type: 'text' })).toBeFalsy();
    expect(isRadioOrCheckbox({ name: 'test', type: 'email' })).toBeFalsy();
    expect(isRadioOrCheckbox({ name: 'test', type: 'date' })).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/isMultipleSelect.test.ts
================================================
import isMultipleSelect from '../../utils/isMultipleSelect';

describe('isMultipleSelect', () => {
  it('should return true when type is select-multiple', () => {
    expect(
      isMultipleSelect({ name: 'test', type: 'select-multiple' }),
    ).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/isFunction.test.ts
================================================
import isFunction from '../../utils/isFunction';

describe('isFunction', () => {
  it('should return true when value is a function', () => {
    expect(isFunction(() => null)).toBeTruthy();
    expect(
      isFunction(function foo() {
        return null;
      }),
    ).toBeTruthy();
  });

  it('should return false when value is not a function', () => {
    expect(isFunction(null)).toBeFalsy();
    expect(isFunction(undefined)).toBeFalsy();
    expect(isFunction(-1)).toBeFalsy();
    expect(isFunction(0)).toBeFalsy();
    expect(isFunction(1)).toBeFalsy();
    expect(isFunction('')).toBeFalsy();
    expect(isFunction({})).toBeFalsy();
    expect(isFunction([])).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/cloneObject.test.ts
================================================
import cloneObject from '../../utils/cloneObject';
import noop from '../../utils/noop';

describe('clone', () => {
  it('should clone object and not mutate the original object', () => {
    const fileData = new File([''], 'filename');
    const data: Record<string, any> = {
      items: [],
      test: {
        date: new Date('2020-10-15'),
        test0: 12,
        test1: '12',
        test2: [1, 2, 3, 4],
        deep: {
          date: new Date('2020-10-15'),
          test0: 12,
          test1: '12',
          test2: [
            1,
            2,
            3,
            4,
            {
              file: fileData,
            },
          ],
          file: fileData,
        },
      },
      file: fileData,
      test2: new Set([1, 2]),
      test1: new Map([
        [1, 'one'],
        [2, 'two'],
        [3, 'three'],
      ]),
    };

    const copy = cloneObject(data);
    expect(cloneObject(data)).toEqual(copy);

    copy.test.what = '1243';
    copy.test.date = new Date('2020-10-16');
    copy.items[0] = 2;

    expect(data).toEqual({
      items: [],
      test: {
        date: new Date('2020-10-15'),
        test0: 12,
        test1: '12',
        test2: [1, 2, 3, 4],
        deep: {
          date: new Date('2020-10-15'),
          test0: 12,
          test1: '12',
          test2: [
            1,
            2,
            3,
            4,
            {
              file: fileData,
            },
          ],
          file: fileData,
        },
      },
      file: fileData,
      test2: new Set([1, 2]),
      test1: new Map([
        [1, 'one'],
        [2, 'two'],
        [3, 'three'],
      ]),
    });

    data.items = [1, 2, 3];

    expect(copy.items).toEqual([2]);
  });

  it('should skip clone if a node is instance of function', () => {
    const data = {
      test: {
        testFunction: noop,
        test: 'inner-string',
        deep: {
          testFunction: noop,
          test: 'deep-string',
        },
      },
      testFunction: noop,
      other: 'string',
    };

    const copy = cloneObject(data);
    data.test.deep.test = 'changed-deep-string';

    expect(copy).toEqual({
      test: {
        test: 'inner-string',
        deep: {
          testFunction: noop,
          test: 'deep-string',
        },
        testFunction: noop,
      },
      testFunction: noop,
      other: 'string',
    });
  });

  it('should skip clone if a node is not planeObject', () => {
    class Foo {
      a = 1;
      b = 1;

      static c = function () {};
    }

    const object = new Foo();
    const copy = cloneObject(object);

    expect(copy).toBe(object);
  });

  describe('FileList not defined', () => {
    const fileList = globalThis.FileList;

    beforeAll(() => {
      // @ts-expect-error we want to test that clone skips if FileList is not defined.
      delete globalThis.FileList;
    });

    afterAll(() => {
      globalThis.FileList = fileList;
    });

    it('should skip clone if FileList is not defined', () => {
      const data = {
        a: 1,
        b: 2,
      };
      const copy = cloneObject(data);

      expect(copy).toEqual(data);
    });
  });

  describe('in presence of Array polyfills', () => {
    beforeAll(() => {
      // @ts-expect-error we want to test that clone skips polyfill
      Array.prototype.somePolyfill = () => 123;
    });

    it('should skip polyfills while cloning', () => {
      const data = [1];
      const copy = cloneObject(data);

      expect(Object.hasOwn(copy, 'somePolyfill')).toBe(false);
    });

    afterAll(() => {
      // @ts-expect-error we want to test that clone skips polyfill
      delete Array.prototype.somePolyfill;
    });
  });
});


================================================
File: /src/__tests__/utils/fillEmptyArray.test.ts
================================================
import fillEmptyArray from '../../utils/fillEmptyArray';

describe('fillEmptyArray', () => {
  it('should return an array of undefined or empty array when value is an array', () => {
    expect(fillEmptyArray([1])).toEqual([undefined]);
    expect(fillEmptyArray([])).toEqual([]);
    expect(fillEmptyArray(['2', true])).toEqual([undefined, undefined]);
    expect(fillEmptyArray([{}, {}])).toEqual([undefined, undefined]);
    expect(fillEmptyArray([[], [3]])).toEqual([undefined, undefined]);
  });

  it('should return undefined when value is not an array', () => {
    expect(fillEmptyArray(1)).toEqual(undefined);
    expect(fillEmptyArray({})).toEqual(undefined);
    expect(fillEmptyArray('')).toEqual(undefined);
    expect(fillEmptyArray(true)).toEqual(undefined);
  });
});


================================================
File: /src/__tests__/utils/isKey.test.ts
================================================
import isKey from '../../utils/isKey';

describe('isKey', () => {
  it('should return true when it is not a deep key', () => {
    expect(isKey('test')).toBeTruthy();
    expect(isKey('fooBar')).toBeTruthy();
  });

  it('should return false when it is a deep key', () => {
    expect(isKey('test.foo')).toBeFalsy();
    expect(isKey('test.foo[0]')).toBeFalsy();
    expect(isKey('test[1]')).toBeFalsy();
    expect(isKey('test.foo[0].bar')).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/isCheckBoxInput.test.ts
================================================
import isCheckBoxInput from '../../utils/isCheckBoxInput';

describe('isCheckBoxInput', () => {
  it('should return true when type is checkbox', () => {
    expect(isCheckBoxInput({ name: 'test', type: 'checkbox' })).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/__snapshots__/flatten.test.ts.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`flatten should flatten form values into flat form data 1`] = `
{
  "array.0.test": "1",
  "array.0.test2": "2",
  "array.0.test3": null,
  "hey": "test",
  "test.nested.test": "bill",
  "test.nested.test3": null,
  "test1": null,
}
`;


================================================
File: /src/__tests__/utils/isUndefined.test.ts
================================================
import isUndefined from '../../utils/isUndefined';

describe('isUndefined', () => {
  it('should return true when it is an undefined value', () => {
    expect(isUndefined(undefined)).toBeTruthy();
  });

  it('should return false when it is not an undefined value', () => {
    expect(isUndefined(null)).toBeFalsy();
    expect(isUndefined('')).toBeFalsy();
    expect(isUndefined('undefined')).toBeFalsy();
    expect(isUndefined(0)).toBeFalsy();
    expect(isUndefined([])).toBeFalsy();
    expect(isUndefined({})).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/isHTMLElement.test.ts
================================================
import isHTMLElement from '../../utils/isHTMLElement';

describe('isHTMLElement', () => {
  it('should return true when value is HTMLElement', () => {
    expect(isHTMLElement(document.createElement('input'))).toBeTruthy();
  });

  it('should return true when HTMLElement is inside an iframe', () => {
    const iframe = document.createElement('iframe');
    document.body.append(iframe);

    const iframeDocument = iframe.contentDocument!;
    const input = iframeDocument.createElement('input');
    iframeDocument.body.append(input);
    expect(isHTMLElement(input)).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/isEmptyObject.test.ts
================================================
import isEmptyObject from '../../utils/isEmptyObject';

describe('isEmptyObject', () => {
  it('should return true when value is an empty object', () => {
    expect(isEmptyObject({})).toBeTruthy();
  });

  it('should return false when value is not an empty object', () => {
    expect(isEmptyObject(null)).toBeFalsy();
    expect(isEmptyObject(undefined)).toBeFalsy();
    expect(isEmptyObject(-1)).toBeFalsy();
    expect(isEmptyObject(0)).toBeFalsy();
    expect(isEmptyObject(1)).toBeFalsy();
    expect(isEmptyObject('')).toBeFalsy();
    expect(isEmptyObject(() => null)).toBeFalsy();
    expect(isEmptyObject({ foo: 'bar' })).toBeFalsy();
    expect(isEmptyObject([])).toBeFalsy();
    expect(isEmptyObject(['foo', 'bar'])).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/unset.test.ts
================================================
import unset from '../../utils/unset';

describe('unset', () => {
  it('should unset the array', () => {
    const test = ['test', 'test1', 'test2'];
    expect(unset(test, '[0]')).toEqual([undefined, 'test1', 'test2']);
    expect(unset(test, '[1]')).toEqual([undefined, undefined, 'test2']);
    expect(unset(test, '[2]')).toEqual([undefined, undefined, undefined]);
  });

  it('should return original object when path is not defined', () => {
    const test = {
      test: 'test',
    };

    expect(unset(test, '')).toEqual(test);
  });

  it('should unset the flat object', () => {
    const test = {
      test: 'test',
    };

    expect(unset(test, 'test')).toEqual({});
  });

  it('should not unset if specified field is undefined', () => {
    const test = {
      test: {
        test1: 'test',
      },
    };

    expect(unset(test, 'testDummy.test1')).toEqual({ test: { test1: 'test' } });
  });

  it('should unset the nest object', () => {
    const test = {
      test: {
        min: 'test',
      },
    };

    expect(unset(test, 'test.min')).toEqual({});
  });

  it('should unset deep object', () => {
    const test = {
      test: {
        bill: {
          min: 'test',
        },
      },
    };

    expect(unset(test, 'test.bill.min')).toEqual({});
  });

  it('should unset the including multiple field object', () => {
    const deep = {
      data: {
        firstName: 'test',
        clear: undefined,
        test: [{ data1: '' }, { data2: '' }],
        data: {
          test: undefined,
          test1: {
            ref: {
              test: '',
            },
          },
        },
      },
    };

    const test = {
      test: {
        bill: {
          min: [{ deep }],
        },
        test: 'ha',
      },
    };

    expect(unset(test, 'test.bill.min[0].deep')).toEqual({
      test: {
        test: 'ha',
      },
    });
  });

  it('should unset the object in array', () => {
    const test = {
      test: [{ min: 'required' }],
    };
    expect(unset(test, 'test[0].min')).toEqual({});
  });

  it('should return empty object when inner object is empty object', () => {
    const test = {
      data: {
        firstName: {},
      },
    };

    expect(unset(test, 'data.firstName')).toEqual({});
  });

  it('should clear empty array', () => {
    const test = {
      data: {
        firstName: {
          test: [
            { name: undefined, email: undefined },
            { name: 'test', email: 'last' },
          ],
          deep: {
            last: [
              { name: undefined, email: undefined },
              { name: 'test', email: 'last' },
            ],
          },
        },
      },
    };

    expect(unset(test, 'data.firstName.test[0]')).toEqual({
      data: {
        firstName: {
          test: [undefined, { name: 'test', email: 'last' }],
          deep: {
            last: [
              { name: undefined, email: undefined },
              { name: 'test', email: 'last' },
            ],
          },
        },
      },
    });

    const test2 = {
      arrayItem: [
        {
          test1: undefined,
          test2: undefined,
        },
      ],
      data: 'test',
    };

    expect(unset(test2, 'arrayItem[0].test1')).toEqual({
      arrayItem: [
        {
          test2: undefined,
        },
      ],
      data: 'test',
    });
  });

  it('should only remove relevant data', () => {
    const data = {
      test: {},
      testing: {
        key1: 1,
        key2: [
          {
            key4: 4,
            key5: [],
            key6: null,
            key7: '',
            key8: undefined,
            key9: {},
          },
        ],
        key3: [],
      },
    };

    expect(unset(data, 'test')).toEqual({
      testing: {
        key1: 1,
        key2: [
          {
            key4: 4,
            key5: [],
            key6: null,
            key7: '',
            key8: undefined,
            key9: {},
          },
        ],
        key3: [],
      },
    });
  });

  it('should remove empty array item', () => {
    const data = {
      name: [
        {
          message: 'test',
        },
      ],
    };

    expect(unset(data, 'name[0]')).toEqual({});
  });

  it('should not remove nested empty array item', () => {
    const data = {
      scenario: {
        steps: [
          {
            content: {
              question: 'isRequired',
            },
          },
        ],
      },
    };

    expect(unset(data, 'scenario.steps[1].messages[0]')).toEqual({
      scenario: {
        steps: [
          {
            content: {
              question: 'isRequired',
            },
          },
        ],
      },
    });
  });

  it('should not remove parent if boolean value exists in array', () => {
    const data = {
      test: [true, undefined, true],
    };

    expect(unset(data, 'test[2]')).toEqual({
      test: [true, undefined, undefined],
    });
  });

  it('should reset the array index', () => {
    const data = {
      test: [[{ name: 'test' }], [{ name: 'test1' }]],
    };
    unset(data, 'test.0.0.name');

    expect(data).toEqual({
      test: [undefined, [{ name: 'test1' }]],
    });

    const data1 = {
      test: [[{ name: 'test' }], [{ name: 'test1' }]],
    };
    unset(data1, 'test.1.0.name');

    expect(data1).toEqual({
      test: [[{ name: 'test' }], undefined],
    });

    const data2 = {
      test: [[[{ name: 'test' }]], [{ name: 'test1' }]],
    };
    unset(data2, 'test.0.0.0.name');

    expect(data2).toEqual({
      test: [undefined, [{ name: 'test1' }]],
    });

    const data3 = {
      test: [[[{ name: 'test' }]], [[{ name: 'test1' }]]],
    };
    unset(data3, 'test.1.0.0.name');

    expect(data3).toEqual({
      test: [[[{ name: 'test' }]], undefined],
    });

    const data4 = {
      test: {
        fields: ['1', '2'],
      },
    };
    unset(data4, 'test.fields.1');

    expect(data4).toEqual({
      test: {
        fields: ['1', undefined],
      },
    });
  });

  describe('when there are remaining props', () => {
    it('should not unset the array', () => {
      const test: Record<string, any> = {
        test: [{ firstName: 'test' }],
      };

      test.test.root = {
        test: 'message',
      };

      unset(test, 'test.0.firstName');

      expect(test.test.root).toBeDefined();
    });
  });

  describe('in presence of Array polyfills', () => {
    beforeAll(() => {
      // @ts-expect-error we want to test unset in presence of polyfills
      Array.prototype.somePolyfill = () => 123;
    });

    it('should delete empty arrays', () => {
      const data = {
        prop: [],
      };
      unset(data, 'prop.0');

      expect(data.prop).toBeUndefined();
    });

    afterAll(() => {
      // @ts-expect-error we want to test unset in presence of polyfills
      delete Array.prototype.somePolyfill;
    });
  });
});


================================================
File: /src/__tests__/utils/objectHasFunction.test.ts
================================================
import noop from '../../utils/noop';
import objectHasFunction from '../../utils/objectHasFunction';

describe('objectHasFunction', () => {
  it('should detect if any object has function', () => {
    expect(objectHasFunction({})).toBeFalsy();
    expect(
      objectHasFunction({
        test: '',
      }),
    ).toBeFalsy();

    expect(
      objectHasFunction({
        test: noop,
      }),
    ).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/swap.test.ts
================================================
import swap from '../../utils/swap';

describe('swap', () => {
  it('should swap value positions', () => {
    const test1 = [1, 2, 3, 4];
    swap(test1, 1, 2);
    expect(test1).toEqual([1, 3, 2, 4]);

    const test2 = [
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ];
    swap(test2, 0, 2);
    expect(test2).toEqual([
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ]);
  });

  it('should swap undefined position when index is not exists', () => {
    const test1 = [1, 2, 3, 4];
    swap(test1, 0, 4);
    expect(test1).toEqual([undefined, 2, 3, 4, 1]);

    const test2 = [1, 2, 3, 4];
    swap(test2, 2, 6);
    expect(test2).toEqual([1, 2, undefined, 4, undefined, undefined, 3]);
  });
});


================================================
File: /src/__tests__/utils/isString.test.ts
================================================
import isString from '../../utils/isString';

describe('isString', () => {
  it('should return true when value is a string', () => {
    expect(isString('')).toBeTruthy();
    expect(isString('foobar')).toBeTruthy();
  });

  it('should return false when value is not a string', () => {
    expect(isString(null)).toBeFalsy();
    expect(isString(undefined)).toBeFalsy();
    expect(isString(-1)).toBeFalsy();
    expect(isString(0)).toBeFalsy();
    expect(isString(1)).toBeFalsy();
    expect(isString({})).toBeFalsy();
    expect(isString([])).toBeFalsy();
    expect(isString(new String('test'))).toBeFalsy();
    expect(isString(() => null)).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/get.test.ts
================================================
import get from '../../utils/get';

describe('get', () => {
  it('should get the right data', () => {
    const test = {
      bill: [1, 2, 3],
      luo: [1, 3, { betty: 'test' }],
      betty: { test: { test1: [{ test2: 'bill' }] } },
      'betty.test.test1[0].test1': 'test',
      'dotted.filled': 'content',
      'dotted.empty': '',
    };
    expect(get(test, 'bill')).toEqual([1, 2, 3]);
    expect(get(test, 'bill[0]')).toEqual(1);
    expect(get(test, 'luo[2].betty')).toEqual('test');
    expect(get(test, 'betty.test.test1[0].test2')).toEqual('bill');
    expect(get(test, 'betty.test.test1[0].test1')).toEqual('test');
    expect(get(test, 'betty.test.test1[0].test3')).toEqual(undefined);
    expect(get(test, 'dotted.filled')).toEqual(test['dotted.filled']);
    expect(get(test, 'dotted.empty')).toEqual(test['dotted.empty']);
    expect(get(test, 'dotted.nonexistent', 'default')).toEqual('default');
  });

  it('should get from the flat data', () => {
    const test = {
      bill: 'test',
    };
    expect(get(test, 'bill')).toEqual('test');
  });

  it('should return undefined when provided with empty path', () => {
    const test = {
      bill: 'test',
    };
    expect(get(test, '')).toEqual(undefined);
    expect(get(test, undefined)).toEqual(undefined);
    expect(get(test, null)).toEqual(undefined);
  });
});


================================================
File: /src/__tests__/utils/stringToPath.test.ts
================================================
import stringToPath from '../../utils/stringToPath';

describe('stringToPath', () => {
  it('should convert string to path', () => {
    expect(stringToPath('test')).toEqual(['test']);

    expect(stringToPath('[test]]')).toEqual(['test']);

    expect(stringToPath('test.test[2].data')).toEqual([
      'test',
      'test',
      '2',
      'data',
    ]);

    expect(stringToPath('test.test["2"].data')).toEqual([
      'test',
      'test',
      '2',
      'data',
    ]);

    expect(stringToPath("test.test['test'].data")).toEqual([
      'test',
      'test',
      'test',
      'data',
    ]);

    expect(stringToPath('test.test.2.data')).toEqual([
      'test',
      'test',
      '2',
      'data',
    ]);
  });
});


================================================
File: /src/__tests__/utils/noop.test.ts
================================================
import noop from '../../utils/noop';

describe('noop', () => {
  it('should be a function', () => {
    expect(noop instanceof Function).toBeTruthy();
  });

  it('should return undefined', () => {
    const result = noop();

    expect(result).toBeUndefined();
  });
});


================================================
File: /src/__tests__/utils/isNullOrUndefined.test.ts
================================================
import isNullOrUndefined from '../../utils/isNullOrUndefined';

describe('isNullOrUndefined', () => {
  it('should return true when object is null or undefined', () => {
    expect(isNullOrUndefined(null)).toBeTruthy();
    expect(isNullOrUndefined(undefined)).toBeTruthy();
  });

  it('should return false when object is neither null nor undefined', () => {
    expect(isNullOrUndefined(-1)).toBeFalsy();
    expect(isNullOrUndefined(0)).toBeFalsy();
    expect(isNullOrUndefined(1)).toBeFalsy();
    expect(isNullOrUndefined('')).toBeFalsy();
    expect(isNullOrUndefined({})).toBeFalsy();
    expect(isNullOrUndefined([])).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/isPrimitive.test.ts
================================================
import isPrimitive from '../../utils/isPrimitive';

describe('isPrimitive', () => {
  it('should return true when value is a string', () => {
    expect(isPrimitive('foobar')).toBeTruthy();
  });

  it('should return true when value is a boolean', () => {
    expect(isPrimitive(false)).toBeTruthy();
  });

  it('should return true when value is a number', () => {
    expect(isPrimitive(123)).toBeTruthy();
  });

  it('should return true when value is a symbol', () => {
    expect(isPrimitive(Symbol())).toBeTruthy();
  });

  it('should return true when value is null', () => {
    expect(isPrimitive(null)).toBeTruthy();
  });

  it('should return true when value is undefined', () => {
    expect(isPrimitive(undefined)).toBeTruthy();
  });

  it('should return false when value is an object', () => {
    expect(isPrimitive({})).toBeFalsy();
  });

  it('should return false when value is an array', () => {
    expect(isPrimitive([])).toBeFalsy();
  });
});


================================================
File: /src/__tests__/utils/move.test.ts
================================================
import move from '../../utils/move';

describe('move', () => {
  it('should be able to move element of array', () => {
    const data = [
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ];
    move(data, 0, 2);
    expect(data).toEqual([
      {
        firstName: '2',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '3',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
      {
        firstName: '1',
        lastName: 'Luo',
        id: '75309979-e340-49eb-8016-5f67bfb56c1c',
      },
    ]);
  });

  it('should return empty array when data passed was not an array', () => {
    // @ts-expect-error we want to test function on non-array input
    expect(move({}, 0, 3)).toEqual([]);
  });

  it('should move nested item with empty slot', () => {
    expect(move([{ subFields: [{ test: '1' }] }], 0, 1)).toEqual([
      undefined,
      { subFields: [{ test: '1' }] },
    ]);

    expect(move([{ subFields: [{ test: '1' }] }], 0, 2)).toEqual([
      undefined,
      undefined,
      { subFields: [{ test: '1' }] },
    ]);
  });
});


================================================
File: /src/__tests__/utils/deepMerge.test.ts
================================================
import deepMerge from '../../utils/deepMerge';

describe('deepMerge', () => {
  it('should deep merge object correctly', () => {
    expect(
      deepMerge(
        { test: { value: 1, data: { test: 1 } } },
        { test: { value2: 2 } },
      ),
    ).toEqual({
      test: { value: 1, value2: 2, data: { test: 1 } },
    });

    expect(deepMerge({ test: { value: 1 } }, {})).toEqual({
      test: { value: 1 },
    });

    expect(deepMerge({}, { test: [{ value: '1' }] })).toEqual({
      test: [{ value: '1' }],
    });

    expect(deepMerge({ data: {} }, { test: [{ value: '1' }] })).toEqual({
      data: {},
      test: [{ value: '1' }],
    });
  });

  it('should overwrite array value ', () => {
    expect(
      deepMerge({ test: [{ value: '2' }] }, { test: [{ value: '1' }] }),
    ).toEqual({
      test: [{ value: '1' }],
    });
  });

  it('should overwrite different data type', () => {
    expect(deepMerge({ test: [{ value: '2' }] }, { test: {} })).toEqual({
      test: {},
    });
  });

  it('should not merge object with date type', () => {
    expect(
      deepMerge({ test: new Date() }, { test: new Date('1999-02-02') }),
    ).toEqual({
      test: new Date('1999-02-02'),
    });
  });

  it('should deep merge array values  ', () => {
    expect(deepMerge([{ hey: 'test' }], [{ id: 'id', text: '' }])).toEqual([
      { hey: 'test', id: 'id', text: '' },
    ]);

    expect(deepMerge([{ id: 'id', text: '' }], [{ hey: 'test' }])).toEqual([
      { hey: 'test', id: 'id', text: '' },
    ]);

    expect(
      deepMerge(
        {
          test: [{ id: 'id', text: '' }],
        },
        {
          test: [{ hey: 'test' }],
        },
      ),
    ).toEqual({
      test: [{ hey: 'test', id: 'id', text: '' }],
    });
  });

  it("should never merge non-objects, and always return the 'source' object", () => {
    expect(deepMerge({}, 0)).toEqual(0);
    expect(deepMerge(0, {})).toEqual({});
  });
});


================================================
File: /src/__tests__/utils/isRegex.test.ts
================================================
import isRegex from '../../utils/isRegex';

describe('isRegex', () => {
  it('should return true when it is a regex', () => {
    expect(isRegex(new RegExp('[a-z]'))).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/deepEqual.test.ts
================================================
import deepEqual from '../../utils/deepEqual';

describe('deepEqual', () => {
  it('should return false when two sets not match', () => {
    expect(
      deepEqual([{ test: '123' }, { test: '455' }, { test: '455' }], []),
    ).toBeFalsy();

    expect(
      deepEqual(
        [{ test: '123' }, { test: '455' }, { test: '455' }],
        [{ test: '123' }, { test: '455' }, { test: '455', test1: 'what' }],
      ),
    ).toBeFalsy();

    expect(deepEqual([{}], [])).toBeFalsy();

    expect(deepEqual([], [{}])).toBeFalsy();
    expect(deepEqual(new Date(), new Date('1999'))).toBeFalsy();

    expect(
      deepEqual(
        {
          unknown: undefined,
          userName: '',
          fruit: '',
        },
        {
          userName: '',
          fruit: '',
          break: {},
        },
      ),
    ).toBeFalsy();
  });

  it('should return false when either type is primitive', () => {
    expect(deepEqual(null, [])).toBeFalsy();
    expect(deepEqual([], null)).toBeFalsy();
    expect(deepEqual({}, undefined)).toBeFalsy();
    expect(deepEqual(undefined, {})).toBeFalsy();
  });

  it('should return true when two sets matches', () => {
    expect(
      deepEqual([{ name: 'useFieldArray' }], [{ name: 'useFieldArray' }]),
    ).toBeTruthy();

    expect(
      deepEqual(
        [{ test: '123' }, { test: '455' }, { test: '455' }],
        [{ test: '123' }, { test: '455' }, { test: '455' }],
      ),
    ).toBeTruthy();

    expect(deepEqual({}, {})).toBeTruthy();

    expect(deepEqual([], [])).toBeTruthy();

    expect(
      deepEqual(
        [{ test: '123' }, { test: '455' }],
        [{ test: '123' }, { test: '455' }],
      ),
    ).toBeTruthy();

    expect(
      deepEqual(
        [
          {
            test: '123',
            nestedArray: [{ test: '123' }, { test: '455' }, { test: '455' }],
          },
          {
            test: '455',
            nestedArray: [{ test: '123' }, { test: '455' }, { test: '455' }],
          },
        ],
        [
          {
            test: '123',
            nestedArray: [{ test: '123' }, { test: '455' }, { test: '455' }],
          },
          {
            test: '455',
            nestedArray: [{ test: '123' }, { test: '455' }, { test: '455' }],
          },
        ],
      ),
    ).toBeTruthy();
  });

  it('should compare date time object valueOf', () => {
    expect(
      deepEqual({ test: new Date('1990') }, { test: new Date('1990') }),
    ).toBeTruthy();
  });
});


================================================
File: /src/__tests__/utils/compact.test.ts
================================================
import filterOutFalsy from '../../utils/compact';

describe('filterOutFalsy', () => {
  it('should return filtered array when array value is falsy ', () => {
    expect(filterOutFalsy([1, 2, 3, 4])).toEqual([1, 2, 3, 4]);
    expect(filterOutFalsy([1, 2, false, 4])).toEqual([1, 2, 4]);
    expect(filterOutFalsy([1, 2, '', 4])).toEqual([1, 2, 4]);
    expect(filterOutFalsy([1, 2, undefined, 4])).toEqual([1, 2, 4]);
    expect(filterOutFalsy([0, 1, 2, 3, 4])).toEqual([1, 2, 3, 4]);
  });
});


================================================
File: /src/__tests__/useForm.test.tsx
================================================
import React, { useState } from 'react';
import {
  act,
  fireEvent,
  render,
  renderHook,
  screen,
  waitFor,
  waitForElementToBeRemoved,
} from '@testing-library/react';

import { VALIDATION_MODE } from '../constants';
import {
  Control,
  FieldErrors,
  FieldValues,
  FormState,
  RegisterOptions,
  UseFormGetFieldState,
  UseFormRegister,
  UseFormReturn,
  UseFormUnregister,
} from '../types';
import isFunction from '../utils/isFunction';
import noop from '../utils/noop';
import sleep from '../utils/sleep';
import { Controller, useFieldArray, useForm } from '../';

jest.useFakeTimers();

describe('useForm', () => {
  describe('when component unMount', () => {
    it('should call unSubscribe', () => {
      const { result, unmount } = renderHook(() => useForm<{ test: string }>());

      result.current.register('test');
      unmount();

      expect(result.current.getValues()).toEqual({});
    });

    it('should remain array field values when inputs gets unmounted', () => {
      const { result, unmount } = renderHook(() =>
        useForm<{ test: string[] }>(),
      );

      result.current.register('test.0');
      result.current.register('test.1');
      result.current.register('test.2');

      unmount();

      expect(result.current.getValues()).toEqual({
        test: [undefined, undefined, undefined],
      });
    });

    it('should not unregister errors when unmounted', async () => {
      const { result, unmount } = renderHook(() =>
        useForm<{
          test: string;
        }>(),
      );

      result.current.formState.errors;
      result.current.register('test', { required: true });

      await act(async () => {
        await result.current.handleSubmit(noop)({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });

      expect(result.current.formState.errors.test).toBeDefined();

      unmount();

      expect(result.current.formState.errors.test).toBeDefined();
    });

    it('should only unregister errors when unregister method invoked', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string;
        }>(),
      );

      result.current.formState.errors;
      result.current.register('test', { required: true });

      await act(async () => {
        await result.current.handleSubmit(noop)({
          preventDefault: noop,
          persist: noop,
        } as React.SyntheticEvent);
      });

      expect(result.current.formState.errors.test).toBeDefined();

      await act(async () => {
        result.current.unregister('test');
      });

      expect(result.current.formState.errors.test).not.toBeDefined();
    });

    it('should not unregister touched', () => {
      let formState: any;
      const Component = () => {
        const { register, formState: tempFormState } = useForm<{
          test: string;
        }>();
        formState = tempFormState;

        formState.touchedFields;

        return (
          <div>
            <input {...register('test', { required: true })} />
          </div>
        );
      };
      const { unmount } = render(<Component />);

      fireEvent.blur(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      expect(formState.touchedFields.test).toBeDefined();
      expect(formState.isDirty).toBeFalsy();

      unmount();

      expect(formState.touchedFields.test).toBeDefined();
      expect(formState.isDirty).toBeFalsy();
    });

    it('should update dirtyFields during unregister', () => {
      let formState: any;
      const Component = () => {
        const { register, formState: tempFormState } = useForm<{
          test: string;
        }>();
        formState = tempFormState;

        formState.isDirty;
        formState.dirtyFields;

        return <input {...register('test', { required: true })} />;
      };
      const { unmount } = render(<Component />);

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      expect(formState.dirtyFields.test).toBeDefined();
      expect(formState.isDirty).toBeTruthy();

      unmount();

      expect(formState.dirtyFields.test).toBeDefined();
      expect(formState.isDirty).toBeTruthy();
    });

    it('should only validate input which are mounted even with shouldUnregister: false', async () => {
      const Component = () => {
        const [show, setShow] = React.useState(true);
        const {
          handleSubmit,
          register,
          formState: { errors },
        } = useForm<{
          firstName: string;
          lastName: string;
        }>();

        return (
          <form onSubmit={handleSubmit(noop)}>
            {show && <input {...register('firstName', { required: true })} />}
            {errors.firstName && <p>First name is required.</p>}

            <input {...register('lastName', { required: true })} />
            {errors.lastName && <p>Last name is required.</p>}

            <button type={'button'} onClick={() => setShow(!show)}>
              toggle
            </button>
            <button type={'submit'}>submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(await screen.findByText('First name is required.')).toBeVisible();
      expect(screen.getByText('Last name is required.')).toBeVisible();

      fireEvent.click(screen.getByRole('button', { name: 'toggle' }));

      fireEvent.click(screen.getByRole('button', { name: 'submit' }));

      expect(screen.getByText('Last name is required.')).toBeVisible();

      await waitForElementToBeRemoved(
        screen.queryByText('First name is required.'),
      );
    });
  });

  describe('when shouldUnregister set to true', () => {
    describe('with useFieldArray', () => {
      type FormValues = {
        test: string;
        test1: string;
        test2: {
          value: string;
        }[];
      };

      const Child = ({
        control,
        register,
      }: {
        control: Control<FormValues>;
        register: UseFormRegister<FormValues>;
      }) => {
        const { fields } = useFieldArray({
          control,
          name: 'test2',
          shouldUnregister: true,
        });

        return (
          <>
            {fields.map((field, i) => (
              <input
                key={field.id}
                {...register(`test2.${i}.value` as const)}
              />
            ))}
          </>
        );
      };

      it('should remove and unregister inputs when inputs gets unmounted', async () => {
        let submittedData: FormValues;

        const Component = () => {
          const [show, setShow] = React.useState(true);
          const { register, handleSubmit, control } = useForm<FormValues>({
            shouldUnregister: true,
            defaultValues: {
              test: 'bill',
              test1: 'bill1',
              test2: [{ value: 'bill2' }],
            },
          });

          return (
            <form onSubmit={handleSubmit((data) => (submittedData = data))}>
              {show && (
                <>
                  <input {...register('test')} />
                  <Controller
                    control={control}
                    render={({ field }) => <input {...field} />}
                    name={'test1'}
                  />
                  <Child control={control} register={register} />
                </>
              )}
              <button>Submit</button>
              <button type={'button'} onClick={() => setShow(false)}>
                Toggle
              </button>
            </form>
          );
        };

        render(<Component />);

        fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

        await waitFor(() =>
          expect(submittedData).toEqual({
            test: 'bill',
            test1: 'bill1',
            test2: [
              {
                value: 'bill2',
              },
            ],
          }),
        );

        fireEvent.click(screen.getByRole('button', { name: 'Toggle' }));

        fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

        await waitFor(() => expect(submittedData).toEqual({}));
      });
    });

    it('should not mutate defaultValues', () => {
      const defaultValues = {
        test: {
          test: '123',
          test1: '1234',
        },
      };

      const Form = () => {
        const { register, control } = useForm({
          defaultValues,
        });
        return (
          <>
            <input {...register('test.test', { shouldUnregister: true })} />
            <Controller
              control={control}
              shouldUnregister
              render={() => {
                return <input />;
              }}
              name={'test.test1'}
            />
          </>
        );
      };

      const App = () => {
        const [show, setShow] = React.useState(true);
        return (
          <>
            {show && <Form />}
            <button
              type={'button'}
              onClick={() => {
                setShow(!show);
              }}
            >
              toggle
            </button>
          </>
        );
      };

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      fireEvent.click(screen.getByRole('button'));

      fireEvent.click(screen.getByRole('button'));

      expect(defaultValues).toEqual({
        test: {
          test: '123',
          test1: '1234',
        },
      });
    });

    it('should not register or shallow defaultValues into submission data', () => {
      let data = {};

      const App = () => {
        const { handleSubmit } = useForm({
          defaultValues: {
            test: 'test',
          },
        });

        return (
          <button
            onClick={handleSubmit((d) => {
              data = d;
            })}
          >
            submit
          </button>
        );
      };

      render(<App />);

      fireEvent.click(screen.getByRole('button'));

      expect(data).toEqual({});
    });

    it('should keep validation during unmount', async () => {
      const onSubmit = jest.fn();

      function Component() {
        const {
          register,
          handleSubmit,
          watch,
          formState: { errors, submitCount },
        } = useForm<{
          firstName: string;
          moreDetail: boolean;
        }>({
          shouldUnregister: true,
        });
        const moreDetail = watch('moreDetail');

        return (
          <>
            <p>Submit count: {submitCount}</p>
            <form onSubmit={handleSubmit(onSubmit)}>
              <input
                placeholder="firstName"
                {...register('firstName', { maxLength: 3 })}
              />
              {errors.firstName && <p>max length</p>}
              <input
                type="checkbox"
                {...register('moreDetail')}
                placeholder={'checkbox'}
              />

              {moreDetail && <p>show more</p>}
              <button>Submit</button>
            </form>
          </>
        );
      }

      render(<Component />);

      fireEvent.change(screen.getByPlaceholderText('firstName'), {
        target: {
          value: 'testtesttest',
        },
      });

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('Submit count: 1')).toBeVisible();
      expect(screen.getByText('max length')).toBeVisible();

      fireEvent.click(screen.getByPlaceholderText('checkbox'));

      expect(screen.getByText('show more')).toBeVisible();

      fireEvent.click(screen.getByRole('button'));

      expect(await screen.findByText('Submit count: 2')).toBeVisible();
      expect(screen.getByText('max length')).toBeVisible();
    });

    it('should only unregister inputs when all checkboxes are unmounted', async () => {
      let result: Record<string, string> | undefined = undefined;

      const Component = () => {
        const { register, handleSubmit } = useForm({
          shouldUnregister: true,
        });
        const [radio1, setRadio1] = React.useState(true);
        const [radio2, setRadio2] = React.useState(true);

        return (
          <form
            onSubmit={handleSubmit((data) => {
              result = data;
            })}
          >
            {radio1 && (
              <input {...register('test')} type={'radio'} value={'1'} />
            )}
            {radio2 && (
              <input {...register('test')} type={'radio'} value={'2'} />
            )}
            <button type={'button'} onClick={() => setRadio1(!radio1)}>
              setRadio1
            </button>
            <button type={'button'} onClick={() => setRadio2(!radio2)}>
              setRadio2
            </button>
            <button>Submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button', { name: 'setRadio1' }));

      fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

      await waitFor(() => expect(result).toEqual({ test: null }));

      fireEvent.click(screen.getByRole('button', { name: 'setRadio2' }));

      fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

      await waitFor(() => expect(result).toEqual({}));
    });
  });

  describe('when errors changes', () => {
    it('should display the latest error message', async () => {
      const Form = () => {
        const {
          register,
          setError,
          formState: { errors },
        } = useForm<{
          test: string;
        }>();

        React.useEffect(() => {
          setError('test', {
            type: 'data',
            message: 'data',
          });
        }, [setError]);

        return (
          <div>
            <input
              {...register('test', {
                maxLength: {
                  message: 'max',
                  value: 3,
                },
              })}
              placeholder="test"
              type="text"
            />
            <span role="alert">{errors.test && errors.test.message}</span>
          </div>
        );
      };

      render(<Form />);

      const span = screen.getByRole('alert');

      await waitFor(() => expect(span.textContent).toBe('data'));

      fireEvent.input(screen.getByRole('textbox'), {
        target: {
          value: 'test',
        },
      });

      await waitFor(() => expect(span.textContent).toBe('data'));
    });

    it('should display the latest error message with errors prop', () => {
      const Form = () => {
        type FormValues = {
          test1: string;
          test2: string;
        };
        const [errorsState, setErrorsState] = React.useState<
          FieldErrors<FormValues>
        >({
          test1: { type: 'test1', message: 'test1 error' },
        });
        const {
          register,
          formState: { errors },
        } = useForm<FormValues>({
          errors: errorsState,
        });

        return (
          <div>
            <input {...register('test1')} type="text" />
            <span role="alert">{errors.test1 && errors.test1.message}</span>
            <input {...register('test2')} type="text" />
            <span role="alert">{errors.test2 && errors.test2.message}</span>
            <button
              onClick={() =>
                setErrorsState((errors) => ({
                  ...errors,
                  test2: { type: 'test2', message: 'test2 error' },
                }))
              }
            >
              Set Errors
            </button>
          </div>
        );
      };

      render(<Form />);

      const alert1 = screen.getAllByRole('alert')[0];
      expect(alert1.textContent).toBe('test1 error');

      fireEvent.click(screen.getByRole('button'));

      const alert2 = screen.getAllByRole('alert')[1];
      expect(alert2.textContent).toBe('test2 error');
    });
  });

  describe('handleChangeRef', () => {
    const Component = ({
      resolver,
      mode,
      rules = { required: 'required' },
      onSubmit = noop,
    }: {
      resolver?: any;
      mode?: 'onBlur' | 'onSubmit' | 'onChange';
      rules?: RegisterOptions<{ test: string }, 'test'>;
      onSubmit?: () => void;
    }) => {
      const internationalMethods = useForm<{ test: string }>({
        resolver,
        mode,
      });
      const {
        register,
        handleSubmit,
        formState: { errors, isValid, isDirty },
      } = internationalMethods;
      methods = internationalMethods;

      return (
        <div>
          <input type="text" {...register('test', resolver ? {} : rules)} />
          <span role="alert">
            {errors?.test?.message && errors.test.message}
          </span>
          <button onClick={handleSubmit(onSubmit)}>button</button>
          <p>{isValid ? 'valid' : 'invalid'}</p>
          <p>{isDirty ? 'dirty' : 'pristine'}</p>
        </div>
      );
    };
    let methods: UseFormReturn<{ test: string }>;

    describe('onSubmit mode', () => {
      it('should not contain error if value is valid', async () => {
        const onSubmit = jest.fn();

        render(<Component onSubmit={onSubmit} />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        const alert = await screen.findByRole('alert');
        expect(alert.textContent).toBe('');

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        expect(alert.textContent).toBe('');
      });

      it('should not contain error if name is invalid', async () => {
        const onSubmit = jest.fn();

        render(<Component onSubmit={onSubmit} />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        const alert = await screen.findByRole('alert');
        expect(alert.textContent).toBe('');

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'wrongName', value: '' },
        });

        expect(alert.textContent).toBe('');
      });

      it('should contain error if value is invalid with revalidateMode is onChange', async () => {
        const onSubmit = jest.fn();

        render(<Component onSubmit={onSubmit} />);

        const input = screen.getByRole('textbox');

        fireEvent.input(input, { target: { name: 'test', value: 'test' } });

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        expect(screen.getByRole('alert').textContent).toBe('');

        fireEvent.input(input, { target: { name: 'test', value: '' } });

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );
      });

      it('should not call reRender method if the current error is the same as the previous error', async () => {
        render(<Component />);

        const input = screen.getByRole('textbox');

        fireEvent.input(input, { target: { name: 'test', value: '' } });

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );

        fireEvent.input(input, { target: { name: 'test', value: '' } });

        expect(screen.getByRole('alert').textContent).toBe('required');
      });

      it('should set name to formState.touchedFields when formState.touchedFields is defined', async () => {
        const onSubmit = jest.fn();

        render(<Component onSubmit={onSubmit} rules={{}} />);

        methods.formState.touchedFields;

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        fireEvent.blur(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        await waitFor(() =>
          expect(methods.formState.touchedFields).toEqual({
            test: true,
          }),
        );
        expect(screen.getByRole('alert').textContent).toBe('');
      });

      // check https://github.com/react-hook-form/react-hook-form/issues/2153
      it('should perform correct behavior when reValidateMode is onBlur', async () => {
        const onSubmit = jest.fn();

        const Component = () => {
          const {
            register,
            handleSubmit,
            formState: { errors },
          } = useForm<{
            test: string;
          }>({
            reValidateMode: 'onBlur',
          });
          return (
            <form onSubmit={handleSubmit(onSubmit)}>
              <input type="text" {...register('test', { required: true })} />
              {errors.test && <span role="alert">required</span>}
              <button>submit</button>
            </form>
          );
        };

        render(<Component />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: {
            value: 'test',
          },
        });

        fireEvent.click(screen.getByRole('button', { name: /submit/i }));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        fireEvent.input(screen.getByRole('textbox'), {
          target: { value: '' },
        });

        expect(screen.queryByRole('alert')).not.toBeInTheDocument();

        fireEvent.blur(screen.getByRole('textbox'));

        expect(await screen.findByRole('alert')).toBeVisible();
      });
    });

    describe('onChange', () => {
      it('should display error with onChange', async () => {
        render(<Component mode="onChange" />);

        fireEvent.change(screen.getByRole('textbox'), {
          target: {
            value: 'test',
          },
        });

        await waitFor(() => screen.getByText('valid'));

        fireEvent.change(screen.getByRole('textbox'), {
          target: {
            value: '',
          },
        });

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );
      });

      it('should display error with onSubmit', async () => {
        render(<Component mode="onChange" />);

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );
      });

      it('should not display error with onBlur', async () => {
        render(<Component mode="onChange" />);

        fireEvent.blur(screen.getByRole('textbox'), {
          target: {
            value: '',
          },
        });

        expect(screen.getByRole('alert').textContent).toBe('');
      });
    });

    describe('onBlur', () => {
      it('should display error with onBlur', async () => {
        render(<Component mode="onBlur" />);

        fireEvent.blur(screen.getByRole('textbox'), {
          target: {
            value: '',
          },
        });

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );
      });

      it('should display error with onSubmit', async () => {
        render(<Component mode="onBlur" />);

        fireEvent.click(screen.getByRole('button'));

        await waitFor(() =>
          expect(screen.getByRole('alert').textContent).toBe('required'),
        );
      });

      it('should not display error with onChange', async () => {
        render(<Component mode="onBlur" />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: {
            value: '',
          },
        });

        expect(screen.getByRole('alert').textContent).toBe('');
      });
    });

    describe('with watch', () => {
      it('should be return undefined or null value', () => {
        const { result } = renderHook(() =>
          useForm<{
            test: string | null;
            test1?: string;
          }>(),
        );

        result.current.register('test');
        result.current.register('test1');

        act(() => {
          result.current.setValue('test', null);
        });

        act(() => {
          result.current.setValue('test1', undefined);
        });

        const test = result.current.watch('test');
        const test1 = result.current.watch('test1');

        expect(test).toBeNull();
        expect(test1).toBeUndefined();
      });

      it('should be called reRender method if isWatchAllRef is true', async () => {
        let watchedField: any;
        const Component = () => {
          const { register, handleSubmit, watch } = useForm<{
            test: string;
          }>();
          watchedField = watch();
          return (
            <form onSubmit={handleSubmit(noop)}>
              <input {...register('test')} />
              <button>button</button>
            </form>
          );
        };
        render(<Component />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        expect(watchedField).toEqual({ test: 'test' });
      });

      it('should be called reRender method if field is watched', async () => {
        let watchedField: any;
        const Component = () => {
          const { register, handleSubmit, watch } = useForm<{
            test: string;
          }>();
          watchedField = watch('test');
          return (
            <form onSubmit={handleSubmit(noop)}>
              <input {...register('test')} />
              <button>button</button>
            </form>
          );
        };
        render(<Component />);

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        expect(watchedField).toBe('test');
      });

      it('should be called reRender method if array field is watched', async () => {
        let watchedField: any;
        const Component = () => {
          const { register, handleSubmit, watch } = useForm<{
            test: string[];
          }>();
          watchedField = watch('test');
          return (
            <form onSubmit={handleSubmit(noop)}>
              <input {...register('test.0')} />
              <input {...register('test.1')} />
              <input {...register('test.2')} />
              <button>button</button>
            </form>
          );
        };
        render(<Component />);

        fireEvent.input(screen.getAllByRole('textbox')[0], {
          target: { name: 'test.0', value: 'test' },
        });

        expect(watchedField).toEqual(['test', '', '']);
      });
    });

    describe('with resolver', () => {
      it('should contain error if value is invalid with resolver', async () => {
        const resolver = jest.fn(async (data: any) => {
          if (data.test) {
            return { values: data, errors: {} };
          }
          return {
            values: data,
            errors: {
              test: {
                message: 'resolver error',
              },
            },
          };
        });

        render(<Component resolver={resolver} mode="onChange" />);

        methods.formState.isValid;

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });
        expect(await screen.findByText('dirty')).toBeVisible();
        expect(resolver).toHaveBeenCalled();

        expect(screen.getByRole('alert').textContent).toBe('');
        expect(methods.formState.isValid).toBeTruthy();

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: '' },
        });

        await waitFor(() => {
          expect(screen.getByRole('alert')).toHaveTextContent('resolver error');
        });
        expect(resolver).toHaveBeenCalled();
        expect(methods.formState.isValid).toBeFalsy();
      });

      it('with sync resolver it should contain error if value is invalid with resolver', async () => {
        const resolver = jest.fn((data: any) => {
          if (data.test) {
            return { values: data, errors: {} };
          }
          return {
            values: data,
            errors: {
              test: {
                message: 'resolver error',
              },
            },
          };
        });

        render(<Component resolver={resolver} mode="onChange" />);

        methods.formState.isValid;

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        await waitFor(() => expect(methods.formState.isValid).toBe(true));
        expect(screen.getByRole('alert').textContent).toBe('');

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: '' },
        });

        expect(await screen.findByText('invalid')).toBeVisible();
        expect(methods.formState.isValid).toBe(false);
        expect(screen.getByRole('alert')).toHaveTextContent('resolver error');
        expect(resolver).toHaveBeenCalled();
      });

      it('should make isValid change to false if it contain error that is not related name with onChange mode', async () => {
        const resolver = jest.fn(async (data: any) => {
          if (data.test) {
            return { values: data, errors: {} };
          }
          return {
            values: data,
            errors: {
              notRelatedName: {
                message: 'resolver error',
              },
            },
          };
        });

        render(<Component resolver={resolver} mode="onChange" />);

        methods.formState.isValid;

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: 'test' },
        });

        await waitFor(() => expect(methods.formState.isValid).toBeTruthy());
        expect(screen.getByRole('alert').textContent).toBe('');

        fireEvent.input(screen.getByRole('textbox'), {
          target: { name: 'test', value: '' },
        });

        await waitFor(() => expect(methods.formState.isValid).toBeFalsy());
        expect(resolver).toHaveBeenCalled();
        expect(screen.getByRole('alert').textContent).toBe('');
      });

      it("should call the resolver with the field being validated when an input's value change", async () => {
        const resolver = jest.fn((values: any) => ({ values, errors: {} }));
        const onSubmit = jest.fn();

        render(
          <Component resolver={resolver} onSubmit={onSubmit} mode="onChange" />,
        );

        expect(await screen.findByText('valid')).toBeVisible();

        const input = screen.getByRole('textbox');

        expect(resolver).toHaveBeenCalledWith(
          {
            test: '',
          },
          undefined,
          {
            criteriaMode: undefined,
            fields: {
              test: {
                mount: true,
                name: 'test',
                ref: input,
              },
            },
            names: ['test'],
            shouldUseNativeValidation: undefined,
          },
        );

        resolver.mockClear();

        fireEvent.input(input, {
          target: { name: 'test', value: 'test' },
        });

        expect(await screen.findByText('dirty')).toBeVisible();

        expect(resolver).toHaveBeenCalledWith(
          {
            test: 'test',
          },
          undefined,
          {
            criteriaMode: undefined,
            fields: {
              test: {
                mount: true,
                name: 'test',
                ref: input,
              },
            },
            names: ['test'],
            shouldUseNativeValidation: undefined,
          },
        );

        resolver.mockClear();

        fireEvent.click(screen.getByText(/button/i));

        await waitFor(() => expect(onSubmit).toHaveBeenCalled());

        expect(resolver).toHaveBeenCalledWith(
          {
            test: 'test',
          },
          undefined,
          {
            criteriaMode: undefined,
            fields: {
              test: {
                mount: true,
                name: 'test',
                ref: input,
              },
            },
            names: ['test'],
            shouldUseNativeValidation: undefined,
          },
        );
      });

      it('should call the resolver with the field being validated when `trigger` is called', async () => {
        const resolver = jest.fn((values: any) => ({ values, errors: {} }));
        const defaultValues = { test: { sub: 'test' }, test1: 'test1' };

        const { result } = renderHook(() =>
          useForm<typeof defaultValues>({
            mode: VALIDATION_MODE.onChange,
            resolver,
            defaultValues,
          }),
        );

        expect(resolver).not.toHaveBeenCalled();

        await act(async () => {
          await result.current.register('test.sub');
          await result.current.register('test1');
        });

        await act(async () => {
          result.current.trigger('test.sub');
        });

        const fields = {
          test: {
            sub: {
              mount: true,
              name: 'test.sub',
              ref: { name: 'test.sub' },
            },
          },
          test1: {
            mount: true,
            name: 'test1',
            ref: {
              name: 'test1',
            },
          },
        };

        expect(resolver).toHaveBeenCalledWith(defaultValues, undefined, {
          criteriaMode: undefined,
          fields: { test: fields.test },
          names: ['test.sub'],
        });

        await act(async () => {
          result.current.trigger();
        });

        expect(resolver).toHaveBeenNthCalledWith(2, defaultValues, undefined, {
          criteriaMode: undefined,
          fields,
          names: ['test.sub', 'test1'],
        });

        await act(async () => {
          result.current.trigger(['test.sub', 'test1']);
        });

        expect(resolver).toHaveBeenNthCalledWith(3, defaultValues, undefined, {
          criteriaMode: undefined,
          fields,
          names: ['test.sub', 'test1'],
        });
      });
    });
  });

  describe('updateValid', () => {
    it('should be called resolver with default values if default value is defined', async () => {
      type FormValues = {
        test: string;
      };

      const resolver = jest.fn(async (data: FormValues) => {
        return {
          values: data,
          errors: {},
        };
      });

      const { result } = renderHook(() =>
        useForm<FormValues>({
          resolver,
          defaultValues: { test: 'default' },
        }),
      );

      const { ref } = result.current.register('test');

      isFunction(ref) &&
        ref({
          target: {
            value: '',
          },
        });

      await act(async () => {
        await result.current.trigger();
      });

      expect(resolver).toHaveBeenCalledWith(
        {
          test: 'default',
        },
        undefined,
        {
          criteriaMode: undefined,
          fields: {
            test: {
              mount: true,
              name: 'test',
              ref: {
                target: {
                  value: '',
                },
                value: 'default',
              },
            },
          },
          names: ['test'],
        },
      );
    });

    it('should be called resolver with field values if value is undefined', async () => {
      type FormValues = {
        test: string;
      };

      const resolver = jest.fn(async (data: FormValues) => {
        return {
          values: data,
          errors: {},
        };
      });

      const { result } = renderHook(() =>
        useForm<FormValues>({
          resolver,
        }),
      );

      result.current.register('test');

      result.current.setValue('test', 'value');

      result.current.trigger();

      expect(resolver).toHaveBeenCalledWith({ test: 'value' }, undefined, {
        criteriaMode: undefined,
        fields: {
          test: {
            mount: true,
            name: 'test',
            ref: { name: 'test', value: 'value' },
          },
        },
        names: ['test'],
      });
    });
  });

  describe('mode with onTouched', () => {
    it('should validate form only when input is been touched', async () => {
      const Component = () => {
        const {
          register,
          formState: { errors },
        } = useForm<{
          test: string;
        }>({
          mode: 'onTouched',
        });

        return (
          <>
            <input
              type="text"
              {...register('test', { required: 'This is required.' })}
            />
            {errors.test?.message}
          </>
        );
      };

      render(<Component />);

      const input = screen.getByRole('textbox');

      fireEvent.focus(input);

      fireEvent.blur(input);

      expect(await screen.findByText('This is required.')).toBeVisible();

      fireEvent.input(input, {
        target: {
          value: 'test',
        },
      });

      await waitFor(() =>
        expect(screen.queryByText('This is required.')).not.toBeInTheDocument(),
      );

      fireEvent.input(input, {
        target: {
          value: '',
        },
      });

      expect(await screen.findByText('This is required.')).toBeVisible();
    });

    it('should validate onFocusout event', async () => {
      const Component = () => {
        const {
          register,
          formState: { errors },
        } = useForm<{
          test: string;
        }>({
          mode: 'onTouched',
        });

        return (
          <>
            <input
              type="text"
              {...register('test', { required: 'This is required.' })}
            />
            {errors.test?.message}
          </>
        );
      };

      render(<Component />);

      const input = screen.getByRole('textbox');

      fireEvent.focus(input);

      fireEvent.focusOut(input);

      expect(await screen.findByText('This is required.')).toBeVisible();

      fireEvent.input(input, {
        target: {
          value: 'test',
        },
      });

      await waitFor(() =>
        expect(screen.queryByText('This is required.')).not.toBeInTheDocument(),
      );

      fireEvent.input(input, {
        target: {
          value: '',
        },
      });

      expect(await screen.findByText('This is required.')).toBeVisible();
    });
  });

  describe('with schema validation', () => {
    it('should trigger and clear errors for group errors object', async () => {
      let errorsObject = {};

      const Component = () => {
        const {
          formState: { errors },
          register,
          handleSubmit,
        } = useForm<{
          checkbox: string[];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            return {
              errors: {
                ...(data.checkbox.every((value) => !value)
                  ? { checkbox: { type: 'error', message: 'wrong' } }
                  : {}),
              },
              values: {},
            };
          },
        });
        errorsObject = errors;

        return (
          <form onSubmit={handleSubmit(noop)}>
            {[1, 2, 3].map((value, index) => (
              <div key={`test.${index}`}>
                <label
                  htmlFor={`checkbox.${index}`}
                >{`checkbox.${index}`}</label>
                <input
                  type={'checkbox'}
                  key={index}
                  id={`checkbox.${index}`}
                  {...register(`checkbox.${index}` as const)}
                  value={value}
                />
              </div>
            ))}

            <button>Submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByLabelText('checkbox.0'));

      fireEvent.click(screen.getByLabelText('checkbox.0'));

      await waitFor(() =>
        expect(errorsObject).toEqual({
          checkbox: { type: 'error', message: 'wrong' },
        }),
      );

      fireEvent.click(screen.getByLabelText('checkbox.0'));

      await waitFor(() => expect(errorsObject).toEqual({}));

      fireEvent.click(screen.getByLabelText('checkbox.0'));

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(errorsObject).toEqual({
          checkbox: { type: 'error', message: 'wrong' },
        }),
      );

      fireEvent.click(screen.getByLabelText('checkbox.0'));

      await waitFor(() => expect(errorsObject).toEqual({}));
    });

    it('should not clear errors for non checkbox parent inputs', async () => {
      let errorsObject = {};

      const Component = () => {
        const {
          formState: { errors },
          register,
          handleSubmit,
        } = useForm<{
          checkbox: [{ test: string }, { test1: string }];
        }>({
          mode: 'onChange',
          resolver: (data) => {
            return {
              errors: {
                ...(!data.checkbox[0].test || !data.checkbox[1].test1
                  ? {
                      checkbox: [
                        {
                          ...(!data.checkbox[0].test
                            ? { test: { type: 'error', message: 'wrong' } }
                            : {}),
                          ...(!data.checkbox[1].test1
                            ? { test1: { type: 'error', message: 'wrong' } }
                            : {}),
                        },
                      ],
                    }
                  : {}),
              },
              values: {},
            };
          },
        });
        errorsObject = errors;

        return (
          <form onSubmit={handleSubmit(noop)}>
            <input type={'checkbox'} {...register(`checkbox.0.test`)} />

            <input {...register(`checkbox.1.test1`)} />
            <button>Submit</button>
          </form>
        );
      };

      render(<Component />);

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(errorsObject).toEqual({
          checkbox: [
            {
              test: { type: 'error', message: 'wrong' },
              test1: { type: 'error', message: 'wrong' },
            },
          ],
        }),
      );

      fireEvent.click(screen.getByRole('checkbox'));

      fireEvent.click(screen.getByRole('button'));

      await waitFor(() =>
        expect(errorsObject).toEqual({
          checkbox: [
            {
              test1: { type: 'error', message: 'wrong' },
            },
          ],
        }),
      );
    });

    it('should have formState.isValid equals true with defined default values after executing resolver', async () => {
      const Toggle = () => {
        const [toggle, setToggle] = React.useState(false);

        const { register, formState } = useForm({
          defaultValues: { test: 'Test' },
          mode: 'onChange',
          resolver: async (values) => {
            if (!values.test) {
              return {
                values: {},
                errors: {
                  test: {
                    type: 'required',
                  },
                },
              };
            }

            return {
              values,
              errors: {},
            };
          },
        });

        return (
          <>
            <button onClick={() => setToggle(!toggle)}>Toggle</button>
            {toggle && <input id="test" {...register('test')} />}
            <button disabled={!formState.isValid}>Submit</button>
          </>
        );
      };

      render(<Toggle />);

      const toggle = () => fireEvent.click(screen.getByText('Toggle'));

      toggle();

      await waitFor(() => expect(screen.getByText('Submit')).toBeEnabled());

      toggle();
      toggle();

      expect(screen.getByText('Submit')).toBeEnabled();
    });
  });

  describe('control', () => {
    it('does not change across re-renders', () => {
      let control;

      const Component = () => {
        const form = useForm<{
          test: string;
        }>();

        control = form.control;

        return (
          <>
            <input type="text" {...form.register('test')} />
          </>
        );
      };

      const { rerender } = render(<Component />);

      const firstRenderControl = control;

      rerender(<Component />);

      const secondRenderControl = control;

      expect(Object.is(firstRenderControl, secondRenderControl)).toBe(true);
    });
  });

  describe('when input is not registered', () => {
    it('trigger should not throw warn', async () => {
      const { result } = renderHook(() =>
        useForm<{
          test: string;
        }>(),
      );

      await act(async () =>
        expect(await result.current.trigger('test')).toBeTruthy(),
      );
    });
  });

  it('should unsubscribe to all subject when hook unmounts', () => {
    let tempControl: any;

    const App = () => {
      const { control } = useForm();
      tempControl = control;

      return null;
    };

    const { unmount } = render(<App />);

    expect(tempControl._subjects.state.observers.length).toBeTruthy();

    unmount();

    expect(tempControl._subjects.state.observers.length).toBeFalsy();
  });

  it('should update isValidating form and field states correctly', async () => {
    jest.useFakeTimers();

    let formState = {} as FormState<FieldValues>;
    let getFieldState = {} as UseFormGetFieldState<FieldValues>;
    const App = () => {
      const [stateValidation, setStateValidation] = React.useState(false);
      const {
        register,
        formState: tmpFormState,
        getFieldState: tmpGetFieldState,
      } = useForm({ mode: 'all' });
      formState = tmpFormState;
      getFieldState = tmpGetFieldState;

      formState.isValidating;

      return (
        <div>
          <p>stateValidation: {String(stateValidation)}</p>
          <form>
            <input
              {...register('lastName', {
                required: true,
                validate: () => {
                  setStateValidation(true);
                  return new Promise((resolve) => {
                    setTimeout(() => {
                      setStateValidation(false);
                      resolve(true);
                    }, 5000);
                  });
                },
              })}
              placeholder="async"
            />

            <input
              {...register('firstName', { required: true })}
              placeholder="required"
            />
          </form>
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByPlaceholderText('async'), {
      target: { value: 'test' },
    });
    fireEvent.change(screen.getByPlaceholderText('required'), {
      target: { value: 'test' },
    });

    expect(formState.isValidating).toBe(true);
    expect(formState.validatingFields).toStrictEqual({
      lastName: true,
      firstName: true,
    });
    expect(getFieldState('lastName').isValidating).toBe(true);
    expect(getFieldState('firstName').isValidating).toBe(true);
    screen.getByText('stateValidation: true');

    await act(async () => {
      jest.advanceTimersByTime(1000);
    });

    expect(formState.isValidating).toBe(true);
    expect(formState.validatingFields).toStrictEqual({
      lastName: true,
    });
    expect(getFieldState('lastName').isValidating).toBe(true);
    expect(getFieldState('firstName').isValidating).toBe(false);
    screen.getByText('stateValidation: true');

    await act(async () => {
      jest.advanceTimersByTime(4000);
    });

    expect(formState.isValidating).toBe(false);
    expect(formState.validatingFields).toStrictEqual({});
    expect(getFieldState('lastName').isValidating).toBe(false);
    expect(getFieldState('firstName').isValidating).toBe(false);
    screen.getByText('stateValidation: false');
  });

  it('should correctly handle multiple async validation triggers', async () => {
    jest.useFakeTimers();

    let formState = {} as FormState<FieldValues>;
    let getFieldState = {} as UseFormGetFieldState<FieldValues>;
    const App = () => {
      const [stateValidation, setStateValidation] = React.useState(false);
      const {
        register,
        formState: tmpFormState,
        getFieldState: tmpGetFieldState,
      } = useForm({ mode: 'onChange' });
      formState = tmpFormState;
      getFieldState = tmpGetFieldState;

      formState.validatingFields;
      formState.isDirty;

      return (
        <div>
          <p>stateValidation: {String(stateValidation)}</p>
          <form>
            <input
              {...register('lastName', {
                required: true,
                validate: () => {
                  setStateValidation(true);
                  return new Promise((resolve) => {
                    setTimeout(() => {
                      setStateValidation(false);
                      resolve(true);
                    }, 2000);
                  });
                },
              })}
              placeholder="async"
            />
          </form>
        </div>
      );
    };

    render(<App />);

    expect(formState.validatingFields).toStrictEqual({});
    expect(formState.isDirty).toStrictEqual(false);
    expect(formState.dirtyFields).toStrictEqual({});
    expect(getFieldState('lastName').isDirty).toStrictEqual(false);

    fireEvent.change(screen.getByPlaceholderText('async'), {
      target: { value: 'test' },
    });

    expect(formState.isDirty).toStrictEqual(true);
    expect(formState.dirtyFields).toStrictEqual({ lastName: true });
    expect(getFieldState('lastName').isDirty).toStrictEqual(true);

    await act(async () => {
      jest.advanceTimersByTime(1000);
    });

    expect(formState.validatingFields).toStrictEqual({ lastName: true });

    fireEvent.change(screen.getByPlaceholderText('async'), {
      target: { value: 'test1' },
    });

    expect(formState.validatingFields).toStrictEqual({ lastName: true });
    expect(getFieldState('lastName').isValidating).toBe(true);

    await act(async () => {
      jest.advanceTimersByTime(1500);
    });

    expect(formState.validatingFields).toStrictEqual({});
    expect(getFieldState('lastName').isValidating).toBe(false);
  });

  it('should update isValidating to true when using with resolver', async () => {
    jest.useFakeTimers();

    let formState = {} as FormState<FieldValues>;
    let getFieldState = {} as UseFormGetFieldState<FieldValues>;
    const App = () => {
      const {
        register,
        formState: tmpFormState,
        getFieldState: tmpGetFieldState,
      } = useForm<{
        firstName: string;
        lastName: string;
      }>({
        mode: 'all',
        defaultValues: {
          lastName: '',
          firstName: '',
        },
        resolver: async () => {
          await sleep(2000);

          return {
            errors: {},
            values: {},
          };
        },
      });
      getFieldState = tmpGetFieldState;
      formState = tmpFormState;

      formState.isValidating;

      return (
        <div>
          <input {...register('lastName')} placeholder="async" />
          <input {...register('firstName')} placeholder="required" />
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByPlaceholderText('async'), {
      target: { value: 'test' },
    });
    fireEvent.change(screen.getByPlaceholderText('async'), {
      target: { value: 'test1' },
    });
    fireEvent.change(screen.getByPlaceholderText('required'), {
      target: { value: 'test2' },
    });
    fireEvent.change(screen.getByPlaceholderText('required'), {
      target: { value: 'test3' },
    });

    expect(formState.isValidating).toBe(true);
    expect(formState.validatingFields).toStrictEqual({
      lastName: true,
      firstName: true,
    });
    expect(getFieldState('lastName').isValidating).toBe(true);
    expect(getFieldState('firstName').isValidating).toBe(true);

    await act(async () => {
      jest.runAllTimers();
    });

    expect(formState.isValidating).toBe(false);
    expect(formState.validatingFields).toStrictEqual({});
    expect(getFieldState('lastName').isValidating).toBe(false);
    expect(getFieldState('firstName').isValidating).toBe(false);
  });

  it('should remove field from validatingFields on unregister', async () => {
    jest.useFakeTimers();
    let unregister: UseFormUnregister<FieldValues>;
    let formState = {} as FormState<FieldValues>;
    const App = () => {
      const {
        register,
        unregister: tmpUnregister,
        formState: tmpFormState,
      } = useForm({ mode: 'all' });
      unregister = tmpUnregister;
      formState = tmpFormState;

      formState.validatingFields;

      return (
        <div>
          <form>
            <input
              {...register('firstName', {
                required: true,
              })}
              placeholder="firstName"
            />
          </form>
        </div>
      );
    };

    render(<App />);

    fireEvent.change(screen.getByPlaceholderText('firstName'), {
      target: { value: 'test' },
    });

    expect(formState.validatingFields).toEqual({ firstName: true });
    await act(async () => {
      unregister('firstName');
      jest.runAllTimers();
    });
    expect(formState.validatingFields).toEqual({});
  });

  it('should update defaultValues async', async () => {
    const App = () => {
      const {
        register,
        formState: { isLoading },
      } = useForm<{
        test: string;
      }>({
        defaultValues: async () => {
          await sleep(100);

          return {
            test: 'test',
          };
        },
      });

      return (
        <form>
          <input {...register('test')} />
          <p>{isLoading ? 'loading...' : 'done'}</p>
        </form>
      );
    };

    render(<App />);

    await waitFor(() => {
      screen.getByText('loading...');
    });

    await waitFor(() => {
      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        'test',
      );
    });

    await waitFor(() => {
      screen.getByText('done');
    });
  });

  it('should update async default values for controlled components', async () => {
    const App = () => {
      const { control } = useForm<{
        test: string;
      }>({
        defaultValues: async () => {
          await sleep(100);

          return {
            test: 'test',
          };
        },
      });

      return (
        <form>
          <Controller
            control={control}
            render={({ field }) => <input {...field} />}
            defaultValue=""
            name={'test'}
          />
        </form>
      );
    };

    render(<App />);

    await waitFor(() => {
      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        'test',
      );
    });
  });

  it('should update async form values', async () => {
    type FormValues = {
      test: string;
    };

    function Loader() {
      const [values, setValues] = React.useState<FormValues>({
        test: '',
      });

      const loadData = React.useCallback(async () => {
        await sleep(100);

        setValues({
          test: 'test',
        });
      }, []);

      React.useEffect(() => {
        loadData();
      }, [loadData]);

      return <App values={values} />;
    }

    const App = ({ values }: { values: FormValues }) => {
      const { register } = useForm({
        values,
      });

      return (
        <form>
          <input {...register('test')} />
        </form>
      );
    };

    render(<Loader />);

    await waitFor(() => {
      expect((screen.getByRole('textbox') as HTMLInputElement).value).toEqual(
        'test',
      );
    });
  });

  it('should only update async form values which are not interacted', async () => {
    type FormValues = {
      test: string;
      test1: string;
    };

    function Loader() {
      const [values, setValues] = React.useState<FormValues>({
        test: '',
        test1: '',
      });

      const loadData = React.useCallback(async () => {
        await sleep(100);

        setValues({
          test: 'test',
          test1: 'data',
        });
      }, []);

      React.useEffect(() => {
        loadData();
      }, [loadData]);

      return <App values={values} />;
    }

    const App = ({ values }: { values: FormValues }) => {
      const { register } = useForm({
        values,
        resetOptions: {
          keepDirtyValues: true,
        },
      });

      return (
        <form>
          <input {...register('test')} />
          <input {...register('test1')} />
        </form>
      );
    };

    render(<Loader />);

    fireEvent.change(screen.getAllByRole('textbox')[0], {
      target: {
        value: 'test1',
      },
    });

    await waitFor(() => {
      expect(
        (screen.getAllByRole('textbox')[0] as HTMLInputElement).value,
      ).toEqual('test1');
    });

    await waitFor(() => {
      expect(
        (screen.getAllByRole('textbox')[1] as HTMLInputElement).value,
      ).toEqual('data');
    });
  });

  it('should not update isLoading when literal defaultValues are provided', async () => {
    const { result } = renderHook(() =>
      useForm({ defaultValues: { test: 'default' } }),
    );

    expect(result.current.formState.isLoading).toBe(false);
  });

  it('should update form values when values updates even with the same values', async () => {
    type FormValues = {
      firstName: string;
    };

    function App() {
      const [firstName, setFirstName] = React.useState('C');
      const values = React.useMemo(() => ({ firstName }), [firstName]);

      const {
        register,
        formState: { isDirty },
        watch,
      } = useForm<FormValues>({
        defaultValues: {
          firstName: 'C',
        },
        values,
        resetOptions: { keepDefaultValues: true },
      });
      const formValues = watch();

      return (
        <form>
          <button type="button" onClick={() => setFirstName('A')}>
            1
          </button>
          <button type="button" onClick={() => setFirstName('B')}>
            2
          </button>
          <button type="button" onClick={() => setFirstName('C')}>
            3
          </button>
          <input {...register('firstName')} placeholder="First Name" />
          <p>{isDirty ? 'dirty' : 'pristine'}</p>
          <p>{formValues.firstName}</p>
          <input type="submit" />
        </form>
      );
    }

    render(<App />);

    fireEvent.click(screen.getByRole('button', { name: '1' }));

    await waitFor(() => {
      screen.getByText('A');
      screen.getByText('dirty');
    });

    fireEvent.click(screen.getByRole('button', { name: '2' }));

    await waitFor(() => {
      screen.getByText('B');
      screen.getByText('dirty');
    });

    fireEvent.click(screen.getByRole('button', { name: '3' }));

    await waitFor(() => {
      screen.getByText('C');
      screen.getByText('pristine');
    });
  });

  it('should disable the entire form inputs', async () => {
    function App() {
      const { register } = useForm({
        disabled: true,
        defaultValues: {
          lastName: '',
          firstName: '',
        },
      });

      return (
        <form>
          <input {...register('firstName')} placeholder="firstName" />
          <input {...register('lastName')} placeholder="lastName" />
        </form>
      );
    }

    render(<App />);

    await waitFor(() => {
      expect(
        (screen.getByPlaceholderText('firstName') as HTMLInputElement).disabled,
      ).toBeTruthy();
      expect(
        (screen.getByPlaceholderText('lastName') as HTMLInputElement).disabled,
      ).toBeTruthy();
    });
  });

  it('should disable the entire form', () => {
    const App = () => {
      const [disabled, setDisabled] = useState(false);
      const { register, control } = useForm({
        disabled,
      });

      return (
        <form>
          <input
            type={'checkbox'}
            {...register('checkbox')}
            data-testid={'checkbox'}
          />
          <input type={'radio'} {...register('radio')} data-testid={'radio'} />
          <input type={'range'} {...register('range')} data-testid={'range'} />
          <select {...register('select')} data-testid={'select'} />
          <textarea {...register('textarea')} data-testid={'textarea'} />

          <Controller
            control={control}
            render={({ field }) => {
              return (
                <input disabled={field.disabled} data-testid={'controller'} />
              );
            }}
            name="test"
          />

          <button
            type="button"
            onClick={() => {
              setDisabled(!disabled);
            }}
          >
            Submit
          </button>
        </form>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    expect(screen.getByTestId('checkbox')).toHaveAttribute('disabled');
    expect(screen.getByTestId('radio')).toHaveAttribute('disabled');
    expect(screen.getByTestId('range')).toHaveAttribute('disabled');
    expect(screen.getByTestId('select')).toHaveAttribute('disabled');
    expect(screen.getByTestId('textarea')).toHaveAttribute('disabled');
    expect(screen.getByTestId('controller')).toHaveAttribute('disabled');

    fireEvent.click(screen.getByRole('button'));
    expect(screen.getByTestId('checkbox')).not.toBeDisabled();
    expect(screen.getByTestId('radio')).not.toBeDisabled();
    expect(screen.getByTestId('range')).not.toBeDisabled();
    expect(screen.getByTestId('select')).not.toBeDisabled();
    expect(screen.getByTestId('textarea')).not.toBeDisabled();
    expect(screen.getByTestId('controller')).not.toBeDisabled();
  });

  it('should disable form inputs separately from its form', async () => {
    function App() {
      const { register } = useForm({
        disabled: false,
        defaultValues: {
          lastName: '',
          firstName: '',
        },
      });

      return (
        <form>
          <input
            {...register('firstName', { disabled: true })}
            placeholder="firstName"
          />
          <input
            {...register('lastName', { disabled: false })}
            placeholder="lastName"
          />
        </form>
      );
    }

    render(<App />);

    await waitFor(() => {
      expect(
        (screen.getByPlaceholderText('firstName') as HTMLInputElement).disabled,
      ).toBeTruthy();
      expect(
        (screen.getByPlaceholderText('lastName') as HTMLInputElement).disabled,
      ).toBeFalsy();
    });
  });

  it('should be able to disable the entire form', async () => {
    const App = () => {
      const [disabled, setDisabled] = useState(false);
      const { register, handleSubmit } = useForm({
        disabled,
      });

      return (
        <form
          onSubmit={handleSubmit(async () => {
            setDisabled(true);
            await sleep(100);
            setDisabled(false);
          })}
        >
          <input
            type={'checkbox'}
            {...register('checkbox')}
            data-testid={'checkbox'}
          />
          <input type={'radio'} {...register('radio')} data-testid={'radio'} />
          <input type={'range'} {...register('range')} data-testid={'range'} />
          <select {...register('select')} data-testid={'select'} />
          <textarea {...register('textarea')} data-testid={'textarea'} />
          <button>Submit</button>
        </form>
      );
    };

    render(<App />);

    expect(
      (screen.getByTestId('textarea') as HTMLTextAreaElement).disabled,
    ).toBeFalsy();
    expect(
      (screen.getByTestId('range') as HTMLInputElement).disabled,
    ).toBeFalsy();
    expect(
      (screen.getByTestId('select') as HTMLInputElement).disabled,
    ).toBeFalsy();
    expect(
      (screen.getByTestId('textarea') as HTMLInputElement).disabled,
    ).toBeFalsy();

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => {
      expect(
        (screen.getByTestId('textarea') as HTMLTextAreaElement).disabled,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('range') as HTMLInputElement).disabled,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('select') as HTMLInputElement).disabled,
      ).toBeTruthy();
      expect(
        (screen.getByTestId('textarea') as HTMLInputElement).disabled,
      ).toBeTruthy();
    });

    await waitFor(() => {
      expect(
        (screen.getByTestId('textarea') as HTMLTextAreaElement).disabled,
      ).toBeFalsy();
      expect(
        (screen.getByTestId('range') as HTMLInputElement).disabled,
      ).toBeFalsy();
      expect(
        (screen.getByTestId('select') as HTMLInputElement).disabled,
      ).toBeFalsy();
      expect(
        (screen.getByTestId('textarea') as HTMLInputElement).disabled,
      ).toBeFalsy();
    });
  });

  it('should allow to submit a form with disabled form fields', async () => {
    function App() {
      const { register, getFieldState, formState, handleSubmit } = useForm();

      return (
        <form onSubmit={handleSubmit(() => {})}>
          <input
            {...register('firstName', { disabled: true, required: true })}
            placeholder="firstName"
          />
          <p>
            {getFieldState('firstName', formState).error
              ? 'has error'
              : 'no error'}
          </p>
          <input type="submit" value="Submit" />
        </form>
      );
    }

    render(<App />);

    await act(() => {
      fireEvent.click(screen.getByRole('button'));
    });

    await waitFor(() => {
      expect(
        (screen.getByPlaceholderText('firstName') as HTMLInputElement).disabled,
      ).toBeTruthy();
      expect(
        screen.getByText('no error') as HTMLInputElement,
      ).toBeInTheDocument();
    });
  });
});


================================================
File: /src/__tests__/useFormContext.test.tsx
================================================
import React, { useState } from 'react';
import { flushSync } from 'react-dom';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';

import { Controller } from '../controller';
import { useController } from '../useController';
import { useFieldArray } from '../useFieldArray';
import { useForm } from '../useForm';
import { FormProvider, useFormContext } from '../useFormContext';
import { useFormState } from '../useFormState';
import { useWatch } from '../useWatch';
import deepEqual from '../utils/deepEqual';
import noop from '../utils/noop';
describe('FormProvider', () => {
  it('should have access to all methods with useFormContext', () => {
    const mockRegister = jest.fn();
    const Test = () => {
      const { register } = useFormContext();

      React.useEffect(() => {
        register('test');
      }, [register]);

      return null;
    };

    const App = () => {
      const methods = useForm();

      return (
        <FormProvider {...methods} register={mockRegister}>
          <form>
            <Test />
          </form>
        </FormProvider>
      );
    };

    render(<App />);

    expect(mockRegister).toHaveBeenCalled();
  });

  it('should work correctly with Controller, useWatch, useFormState.', async () => {
    const TestComponent = () => {
      const { field } = useController({
        name: 'test',
        defaultValue: '',
      });
      return <input {...field} />;
    };

    const TestWatch = () => {
      const value = useWatch({
        name: 'test',
      });

      return <p>Value: {value === undefined ? 'undefined value' : value}</p>;
    };

    const TestFormState = () => {
      const { isDirty } = useFormState();

      return <div>Dirty: {isDirty ? 'yes' : 'no'}</div>;
    };

    const Component = () => {
      const methods = useForm();
      return (
        <FormProvider {...methods}>
          <TestComponent />
          <TestWatch />
          <TestFormState />
        </FormProvider>
      );
    };

    render(<Component />);

    const input = screen.getByRole('textbox');

    expect(input).toBeVisible();
    expect(await screen.findByText('Value: undefined value')).toBeVisible();
    expect(screen.getByText('Dirty: no')).toBeVisible();

    fireEvent.change(input, { target: { value: 'test' } });
    expect(screen.getByText('Value: test')).toBeVisible();
    expect(screen.getByText('Dirty: yes')).toBeVisible();
  });

  it('should not throw type error', () => {
    type FormValues = {
      firstName: string;
    };

    type Context = {
      someValue: boolean;
    };

    function App() {
      const methods = useForm<FormValues, Context>();
      const { handleSubmit, register } = methods;

      return (
        <div>
          <FormProvider {...methods}>
            <form onSubmit={handleSubmit(noop)}>
              <input {...register('firstName')} placeholder="First Name" />
              <input type="submit" />
            </form>
          </FormProvider>
        </div>
      );
    }

    render(<App />);
  });

  it('should be able to access defaultValues within formState', () => {
    type FormValues = {
      firstName: string;
      lastName: string;
    };

    const defaultValues = {
      firstName: 'a',
      lastName: 'b',
    };

    const Test1 = () => {
      const methods = useFormState();

      return (
        <p>
          {deepEqual(methods.defaultValues, defaultValues)
            ? 'context-yes'
            : 'context-no'}
        </p>
      );
    };

    const Test = () => {
      const methods = useFormContext();

      return (
        <p>
          {deepEqual(methods.formState.defaultValues, defaultValues)
            ? 'yes'
            : 'no'}
        </p>
      );
    };

    const Component = () => {
      const methods = useForm<FormValues>({
        defaultValues,
      });

      return (
        <FormProvider {...methods}>
          <Test />
          <Test1 />
          <button
            onClick={() => {
              methods.reset({
                firstName: 'c',
                lastName: 'd',
              });
            }}
          >
            reset
          </button>
          <p>{JSON.stringify(defaultValues)}</p>
        </FormProvider>
      );
    };

    render(<Component />);

    expect(screen.getByText('yes')).toBeVisible();
    expect(screen.getByText('context-yes')).toBeVisible();

    screen.getByText(JSON.stringify(defaultValues));

    fireEvent.click(screen.getByRole('button'));

    waitFor(() => {
      expect(screen.getByText('yes')).not.toBeValid();
      expect(screen.getByText('context-yes')).not.toBeVisible();

      screen.getByText(
        JSON.stringify({
          firstName: 'c',
          lastName: 'd',
        }),
      );
    });
  });

  it('should report errors correctly', async () => {
    const Child = () => {
      const {
        formState: { errors },
        register,
        handleSubmit,
      } = useFormContext<{
        test: string;
      }>();

      return (
        <form onSubmit={handleSubmit(noop)}>
          <input {...register('test', { required: 'This is required' })} />
          <p>{errors.test?.message}</p>
          <button>submit</button>
        </form>
      );
    };

    const App = () => {
      const methods = useForm();

      return (
        <FormProvider {...methods}>
          <Child />
        </FormProvider>
      );
    };

    render(<App />);

    fireEvent.click(screen.getByRole('button'));

    await waitFor(() => screen.getByText('This is required'));
  });

  it('should report errors correctly with useFieldArray Controller', async () => {
    let arrayErrors: (string | undefined)[] = [];
    const Form = () => {
      const {
        control,
        formState: { errors },
      } = useFormContext<{
        testArray: { name: string }[];
      }>();

      const { append, fields } = useFieldArray({
        control,
        name: 'testArray',
      });

      arrayErrors = fields.map(
        (_, index) => errors?.testArray?.[index]?.name?.message,
      );
      const onSubmit = jest.fn((e) => e.preventDefault());
      const [selected, setSelected] = useState<number | undefined>();
      return (
        <form onSubmit={onSubmit}>
          <p data-testid="error-value">{JSON.stringify(errors)}</p>
          <p data-testid="error-filter-value">
            {arrayErrors.filter(Boolean).length}
          </p>
          <button onClick={() => append({ name: 'test' })}>Increment</button>
          <select
            data-testid="select"
            onChange={(e) => {
              flushSync(() => setSelected(+e.target.value));
            }}
          >
            {fields.map((field, index) => (
              <option key={field.id} value={index}></option>
            ))}
          </select>
          {selected !== undefined && (
            <Controller
              control={control}
              name={`testArray.${selected}.name`}
              shouldUnregister={false}
              rules={{ required: { value: true, message: 'required' } }}
              render={({ field }) => (
                <input data-testid="error-input" onChange={field.onChange} />
              )}
            />
          )}
        </form>
      );
    };
    const App = () => {
      const methods = useForm({
        defaultValues: { testArray: [] },
        mode: 'all',
      });

      return (
        <FormProvider {...methods}>
          <Form />
        </FormProvider>
      );
    };
    render(<App />);
    const errorValue = screen.getByTestId('error-value');
    const errorFilterValue = screen.getByTestId('error-filter-value');
    const select = screen.getByTestId('select');
    // const errorInput = screen.getByTestId('error-input');
    const button = screen.getByText('Increment');

    // Click button add Value
    fireEvent.click(button);
    fireEvent.click(button);
    // Change second value to ''
    fireEvent.change(select, { target: { value: 1 } });
    const errorInput = screen.getByTestId('error-input');
    fireEvent.change(errorInput, { target: { value: 'test' } });
    fireEvent.change(errorInput, { target: { value: '' } });
    await waitFor(() => {
      expect(errorValue).toHaveTextContent(
        '{"testArray":[null,{"name":{"type":"required","message":"required","ref":{"name":"testArray.1.name"}}}]}',
      );
      expect(errorFilterValue).toHaveTextContent('1');
    });
  });
});


================================================
File: /src/utils/swap.ts
================================================
export default <T>(data: T[], indexA: number, indexB: number): void => {
  [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};


================================================
File: /src/utils/isUndefined.ts
================================================
export default (val: unknown): val is undefined => val === undefined;


================================================
File: /src/utils/sleep.ts
================================================
export default (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));


================================================
File: /src/utils/isRadioOrCheckbox.ts
================================================
import { FieldElement } from '../types';

import isCheckBoxInput from './isCheckBoxInput';
import isRadioInput from './isRadioInput';

export default (ref: FieldElement): ref is HTMLInputElement =>
  isRadioInput(ref) || isCheckBoxInput(ref);


================================================
File: /src/utils/isCheckBoxInput.ts
================================================
import { FieldElement } from '../types';

export default (element: FieldElement): element is HTMLInputElement =>
  element.type === 'checkbox';


================================================
File: /src/utils/isWeb.ts
================================================
export default typeof window !== 'undefined' &&
  typeof window.HTMLElement !== 'undefined' &&
  typeof document !== 'undefined';


================================================
File: /src/utils/isString.ts
================================================
export default (value: unknown): value is string => typeof value === 'string';


================================================
File: /src/utils/isPrimitive.ts
================================================
import { Primitive } from '../types';

import isNullOrUndefined from './isNullOrUndefined';
import { isObjectType } from './isObject';

export default (value: unknown): value is Primitive =>
  isNullOrUndefined(value) || !isObjectType(value);


================================================
File: /src/utils/convertToArrayPayload.ts
================================================
export default <T>(value: T) => (Array.isArray(value) ? value : [value]);


================================================
File: /src/utils/fillEmptyArray.ts
================================================
export default <T>(value: T | T[]): undefined[] | undefined =>
  Array.isArray(value) ? value.map(() => undefined) : undefined;


================================================
File: /src/utils/isFunction.ts
================================================
export default (value: unknown): value is Function =>
  typeof value === 'function';


================================================
File: /src/utils/move.ts
================================================
import isUndefined from './isUndefined';

export default <T>(
  data: (T | undefined)[],
  from: number,
  to: number,
): (T | undefined)[] => {
  if (!Array.isArray(data)) {
    return [];
  }

  if (isUndefined(data[to])) {
    data[to] = undefined;
  }
  data.splice(to, 0, data.splice(from, 1)[0]);

  return data;
};


================================================
File: /src/utils/isMessage.ts
================================================
import { Message } from '../types';
import isString from '../utils/isString';

export default (value: unknown): value is Message => isString(value);


================================================
File: /src/utils/update.ts
================================================
export default <T>(fieldValues: T[], index: number, value: T) => {
  fieldValues[index] = value;
  return fieldValues;
};


================================================
File: /src/utils/set.ts
================================================
import { FieldPath, FieldValues } from '../types';

import isKey from './isKey';
import isObject from './isObject';
import stringToPath from './stringToPath';

export default (
  object: FieldValues,
  path: FieldPath<FieldValues>,
  value?: unknown,
) => {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;

  while (++index < length) {
    const key = tempPath[index];
    let newValue = value;

    if (index !== lastIndex) {
      const objValue = object[key];
      newValue =
        isObject(objValue) || Array.isArray(objValue)
          ? objValue
          : !isNaN(+tempPath[index + 1])
            ? []
            : {};
    }

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return;
    }

    object[key] = newValue;
    object = object[key];
  }
  return object;
};


================================================
File: /src/utils/stringToPath.ts
================================================
import compact from './compact';

export default (input: string): string[] =>
  compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));


================================================
File: /src/utils/flatten.ts
================================================
import { FieldValues } from '../types';

import { isObjectType } from './isObject';

export const flatten = (obj: FieldValues) => {
  const output: FieldValues = {};

  for (const key of Object.keys(obj)) {
    if (isObjectType(obj[key]) && obj[key] !== null) {
      const nested = flatten(obj[key]);

      for (const nestedKey of Object.keys(nested)) {
        output[`${key}.${nestedKey}`] = nested[nestedKey];
      }
    } else {
      output[key] = obj[key];
    }
  }

  return output;
};


================================================
File: /src/utils/isNullOrUndefined.ts
================================================
export default (value: unknown): value is null | undefined => value == null;


================================================
File: /src/utils/deepMerge.ts
================================================
import isObject from './isObject';
import isPrimitive from './isPrimitive';

export default function deepMerge<
  T extends Record<keyof T, any>,
  U extends Record<keyof U, any>,
>(target: T, source: U): T & U {
  if (isPrimitive(target) || isPrimitive(source)) {
    return source;
  }

  for (const key in source) {
    const targetValue = target[key];
    const sourceValue = source[key];

    try {
      target[key] =
        (isObject(targetValue) && isObject(sourceValue)) ||
        (Array.isArray(targetValue) && Array.isArray(sourceValue))
          ? deepMerge(targetValue, sourceValue)
          : sourceValue;
    } catch {}
  }

  return target;
}


================================================
File: /src/utils/isDateObject.ts
================================================
export default (value: unknown): value is Date => value instanceof Date;


================================================
File: /src/utils/isMultipleSelect.ts
================================================
import { FieldElement } from '../types';

export default (element: FieldElement): element is HTMLSelectElement =>
  element.type === `select-multiple`;


================================================
File: /src/utils/isFileInput.ts
================================================
import { FieldElement } from '../types';

export default (element: FieldElement): element is HTMLInputElement =>
  element.type === 'file';


================================================
File: /src/utils/objectHasFunction.ts
================================================
import isFunction from './isFunction';

export default <T>(data: T): boolean => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};


================================================
File: /src/utils/compact.ts
================================================
export default <TValue>(value: TValue[]) =>
  Array.isArray(value) ? value.filter(Boolean) : [];


================================================
File: /src/utils/isRegex.ts
================================================
export default (value: unknown): value is RegExp => value instanceof RegExp;


================================================
File: /src/utils/remove.ts
================================================
import compact from './compact';
import convertToArrayPayload from './convertToArrayPayload';
import isUndefined from './isUndefined';

function removeAtIndexes<T>(data: T[], indexes: number[]): T[] {
  let i = 0;
  const temp = [...data];

  for (const index of indexes) {
    temp.splice(index - i, 1);
    i++;
  }

  return compact(temp).length ? temp : [];
}

export default <T>(data: T[], index?: number | number[]): T[] =>
  isUndefined(index)
    ? []
    : removeAtIndexes(
        data,
        (convertToArrayPayload(index) as number[]).sort((a, b) => a - b),
      );


================================================
File: /src/utils/isObject.ts
================================================
import isDateObject from './isDateObject';
import isNullOrUndefined from './isNullOrUndefined';

export const isObjectType = (value: unknown): value is object =>
  typeof value === 'object';

export default <T extends object>(value: unknown): value is T =>
  !isNullOrUndefined(value) &&
  !Array.isArray(value) &&
  isObjectType(value) &&
  !isDateObject(value);


================================================
File: /src/utils/isBoolean.ts
================================================
export default (value: unknown): value is boolean => typeof value === 'boolean';


================================================
File: /src/utils/index.ts
================================================
import get from './get';
import set from './set';

export { get, set };


================================================
File: /src/utils/live.ts
================================================
import { Ref } from '../types';

import isHTMLElement from './isHTMLElement';

export default (ref: Ref) => isHTMLElement(ref) && ref.isConnected;


================================================
File: /src/utils/append.ts
================================================
import convertToArrayPayload from './convertToArrayPayload';

export default <T>(data: T[], value: T | T[]): T[] => [
  ...data,
  ...convertToArrayPayload(value),
];


================================================
File: /src/utils/isKey.ts
================================================
export default (value: string) => /^\w*$/.test(value);


================================================
File: /src/utils/insert.ts
================================================
import convertToArrayPayload from './convertToArrayPayload';

export default function insert<T>(data: T[], index: number): (T | undefined)[];
export default function insert<T>(
  data: T[],
  index: number,
  value: T | T[],
): T[];
export default function insert<T>(
  data: T[],
  index: number,
  value?: T | T[],
): (T | undefined)[] {
  return [
    ...data.slice(0, index),
    ...convertToArrayPayload(value),
    ...data.slice(index),
  ];
}


================================================
File: /src/utils/isHTMLElement.ts
================================================
import isWeb from './isWeb';

export default (value: unknown): value is HTMLElement => {
  if (!isWeb) {
    return false;
  }

  const owner = value ? ((value as HTMLElement).ownerDocument as Document) : 0;
  return (
    value instanceof
    (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement)
  );
};


================================================
File: /src/utils/cloneObject.ts
================================================
import isObject from './isObject';
import isPlainObject from './isPlainObject';
import isWeb from './isWeb';

export default function cloneObject<T>(data: T): T {
  let copy: any;
  const isArray = Array.isArray(data);
  const isFileListInstance =
    typeof FileList !== 'undefined' ? data instanceof FileList : false;

  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (
    !(isWeb && (data instanceof Blob || isFileListInstance)) &&
    (isArray || isObject(data))
  ) {
    copy = isArray ? [] : {};

    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }

  return copy;
}


================================================
File: /src/utils/noop.ts
================================================
export default function noop() {}


================================================
File: /src/utils/createSubject.ts
================================================
import { Noop } from '../types';

export type Observer<T> = {
  next: (value: T) => void;
};

export type Subscription = {
  unsubscribe: Noop;
};

export type Subject<T> = {
  readonly observers: Observer<T>[];
  subscribe: (value: Observer<T>) => Subscription;
  unsubscribe: Noop;
} & Observer<T>;

export default <T>(): Subject<T> => {
  let _observers: Observer<T>[] = [];

  const next = (value: T) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };

  const subscribe = (observer: Observer<T>): Subscription => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o) => o !== observer);
      },
    };
  };

  const unsubscribe = () => {
    _observers = [];
  };

  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe,
  };
};


================================================
File: /src/utils/isPlainObject.ts
================================================
import isObject from './isObject';

export default (tempObject: object) => {
  const prototypeCopy =
    tempObject.constructor && tempObject.constructor.prototype;

  return (
    isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf')
  );
};


================================================
File: /src/utils/isRadioInput.ts
================================================
import { FieldElement } from '../types';

export default (element: FieldElement): element is HTMLInputElement =>
  element.type === 'radio';


================================================
File: /src/utils/prepend.ts
================================================
import convertToArrayPayload from './convertToArrayPayload';

export default <T>(data: T[], value: T | T[]): T[] => [
  ...convertToArrayPayload(value),
  ...convertToArrayPayload(data),
];


================================================
File: /src/utils/deepEqual.ts
================================================
import isObject from '../utils/isObject';

import isDateObject from './isDateObject';
import isPrimitive from './isPrimitive';

export default function deepEqual(object1: any, object2: any) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }

  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }

  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (const key of keys1) {
    const val1 = object1[key];

    if (!keys2.includes(key)) {
      return false;
    }

    if (key !== 'ref') {
      const val2 = object2[key];

      if (
        (isDateObject(val1) && isDateObject(val2)) ||
        (isObject(val1) && isObject(val2)) ||
        (Array.isArray(val1) && Array.isArray(val2))
          ? !deepEqual(val1, val2)
          : val1 !== val2
      ) {
        return false;
      }
    }
  }

  return true;
}


================================================
File: /src/utils/unset.ts
================================================
import isEmptyObject from './isEmptyObject';
import isKey from './isKey';
import isObject from './isObject';
import isUndefined from './isUndefined';
import stringToPath from './stringToPath';

function baseGet(object: any, updatePath: (string | number)[]) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;

  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }

  return object;
}

function isEmptyArray(obj: unknown[]) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}

export default function unset(object: any, path: string | (string | number)[]) {
  const paths = Array.isArray(path)
    ? path
    : isKey(path)
      ? [path]
      : stringToPath(path);

  const childObject = paths.length === 1 ? object : baseGet(object, paths);

  const index = paths.length - 1;
  const key = paths[index];

  if (childObject) {
    delete childObject[key];
  }

  if (
    index !== 0 &&
    ((isObject(childObject) && isEmptyObject(childObject)) ||
      (Array.isArray(childObject) && isEmptyArray(childObject)))
  ) {
    unset(object, paths.slice(0, -1));
  }

  return object;
}


================================================
File: /src/utils/get.ts
================================================
import compact from './compact';
import isNullOrUndefined from './isNullOrUndefined';
import isObject from './isObject';
import isUndefined from './isUndefined';

export default <T>(
  object: T,
  path?: string | null,
  defaultValue?: unknown,
): any => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }

  const result = compact(path.split(/[,[\].]+?/)).reduce(
    (result, key) =>
      isNullOrUndefined(result) ? result : result[key as keyof {}],
    object,
  );

  return isUndefined(result) || result === object
    ? isUndefined(object[path as keyof T])
      ? defaultValue
      : object[path as keyof T]
    : result;
};


================================================
File: /src/utils/isEmptyObject.ts
================================================
import { EmptyObject } from '../types';

import isObject from './isObject';

export default (value: unknown): value is EmptyObject =>
  isObject(value) && !Object.keys(value).length;


================================================
File: /src/types/path/common.ts
================================================
import { IsAny, IsNever } from '../utils';

/**
 * Type alias to `string` which describes a lodash-like path through an object.
 * E.g. `'foo.bar.0.baz'`
 */
export type PathString = string;

/**
 * Type which can be traversed through with a {@link PathString}.
 * I.e. objects, arrays, and tuples
 */
export type Traversable = object;

/**
 * Type to query whether an array type T is a tuple type.
 * @typeParam T - type which may be an array or tuple
 * @example
 * ```
 * IsTuple<[number]> = true
 * IsTuple<number[]> = false
 * ```
 */
export type IsTuple<T extends ReadonlyArray<any>> = number extends T['length']
  ? false
  : true;

/**
 * Type which can be used to index an array or tuple type.
 */
export type ArrayKey = number;

/**
 * Type which can be used to index an object.
 */
export type Key = string;

/**
 * Type to assert that a type is a {@link Key}.
 * @typeParam T - type which may be a {@link Key}
 */
export type AsKey<T> = Extract<T, Key>;

/**
 * Type to convert a type to a {@link Key}.
 * @typeParam T - type which may be converted to a {@link Key}
 */
export type ToKey<T> = T extends ArrayKey ? `${T}` : AsKey<T>;

/**
 * Type which describes a path through an object
 * as a list of individual {@link Key}s.
 */
export type PathTuple = Key[];

/**
 * Type to assert that a type is a {@link PathTuple}.
 * @typeParam T - type which may be a {@link PathTuple}
 */
export type AsPathTuple<T> = Extract<T, PathTuple>;

/**
 * Type to intersect a union type.
 * See https://fettblog.eu/typescript-union-to-intersection/
 * @typeParam U - union
 * @example
 * ```
 * UnionToIntersection<{ foo: string } | { bar: number }>
 *   = { foo: string; bar: number }
 * ```
 */
export type UnionToIntersection<U> = (
  U extends any ? (_: U) => any : never
) extends (_: infer I) => any
  ? I
  : never;

/**
 * Type which appends a {@link Key} to the {@link PathTuple} only if it is not
 * blank, i.e. not the empty string.
 * @typeParam PT - path
 * @typeParam K  - key
 * @example
 * ```
 * AppendNonBlankKey<['foo'], 'bar'> = ['foo', 'bar']
 * AppendNonBlankKey<['foo'], ''> = ['foo']
 * ```
 */
type AppendNonBlankKey<PT extends PathTuple, K extends Key> = K extends ''
  ? PT
  : [...PT, K];

/**
 * Type to implement {@link SplitPathString} tail recursively.
 * @typeParam PS - remaining {@link PathString} which should be split into its
 *                 individual {@link Key}s
 * @typeParam PT - accumulator of the {@link Key}s which have been split from
 *                 the original {@link PathString} already
 */
type SplitPathStringImpl<
  PS extends PathString,
  PT extends PathTuple,
> = PS extends `${infer K}.${infer R}`
  ? SplitPathStringImpl<R, AppendNonBlankKey<PT, K>>
  : AppendNonBlankKey<PT, PS>;

/**
 * Type to split a {@link PathString} into a {@link PathTuple}.
 * The individual {@link Key}s may be empty strings.
 * @typeParam PS  - {@link PathString} which should be split into its
 *                  individual {@link Key}s
 * @example
 * ```
 * SplitPathString<'foo'> = ['foo']
 * SplitPathString<'foo.bar.0.baz'> = ['foo', 'bar', '0', 'baz']
 * SplitPathString<'.'> = []
 * ```
 */
export type SplitPathString<PS extends PathString> = SplitPathStringImpl<
  PS,
  []
>;

/**
 * Type to implement {@link JoinPathTuple} tail-recursively.
 * @typeParam PT - remaining {@link Key}s which needs to be joined
 * @typeParam PS - accumulator of the already joined {@link Key}s
 */
type JoinPathTupleImpl<
  PT extends PathTuple,
  PS extends PathString,
> = PT extends [infer K, ...infer R]
  ? JoinPathTupleImpl<AsPathTuple<R>, `${PS}.${AsKey<K>}`>
  : PS;

/**
 * Type to join a {@link PathTuple} to a {@link PathString}.
 * @typeParam PT - {@link PathTuple} which should be joined.
 * @example
 * ```
 * JoinPathTuple<['foo']> = 'foo'
 * JoinPathTuple<['foo', 'bar', '0', 'baz']> = 'foo.bar.0.baz'
 * JoinPathTuple<[]> = never
 * ```
 */
export type JoinPathTuple<PT extends PathTuple> = PT extends [
  infer K,
  ...infer R,
]
  ? JoinPathTupleImpl<AsPathTuple<R>, AsKey<K>>
  : never;

/**
 * Type which converts all keys of an object to {@link Key}s.
 * @typeParam T - object type
 * @example
 * ```
 * MapKeys<{0: string}> = {'0': string}
 * ```
 */
type MapKeys<T> = { [K in keyof T as ToKey<K>]: T[K] };

/**
 * Type to access a type by a key.
 *  - Returns undefined if it can't be indexed by that key.
 *  - Returns null if the type is null.
 *  - Returns undefined if the type is not traversable.
 * @typeParam T - type which is indexed by the key
 * @typeParam K - key into the type
 * ```
 * TryAccess<{foo: string}, 'foo'> = string
 * TryAccess<{foo: string}, 'bar'> = undefined
 * TryAccess<null, 'foo'> = null
 * TryAccess<string, 'foo'> = undefined
 * ```
 */
type TryAccess<T, K> = K extends keyof T
  ? T[K]
  : T extends null
    ? null
    : undefined;

/**
 * Type to access an array type by a key.
 * Returns undefined if the key is non-numeric.
 * @typeParam T - type which is indexed by the key
 * @typeParam K - key into the type
 * ```
 * TryAccessArray<string[], '0'> = string
 * TryAccessArray<string[], 'foo'> = undefined
 * ```
 */
type TryAccessArray<
  T extends ReadonlyArray<any>,
  K extends Key,
> = K extends `${ArrayKey}` ? T[number] : TryAccess<T, K>;

/**
 * Type to evaluate the type which the given key points to.
 * @typeParam T - type which is indexed by the key
 * @typeParam K - key into the type
 * @example
 * ```
 * EvaluateKey<{foo: string}, 'foo'> = string
 * EvaluateKey<[number, string], '1'> = string
 * EvaluateKey<string[], '1'> = string
 * ```
 */
export type EvaluateKey<T, K extends Key> =
  T extends ReadonlyArray<any>
    ? IsTuple<T> extends true
      ? TryAccess<T, K>
      : TryAccessArray<T, K>
    : TryAccess<MapKeys<T>, K>;

/**
 * Type to evaluate the type which the given path points to.
 * @typeParam T  - deeply nested type which is indexed by the path
 * @typeParam PT - path into the deeply nested type
 * @example
 * ```
 * EvaluatePath<{foo: {bar: string}}, ['foo', 'bar']> = string
 * EvaluatePath<[number, string], ['1']> = string
 * EvaluatePath<number, []> = number
 * EvaluatePath<number, ['foo']> = undefined
 * ```
 */
export type EvaluatePath<T, PT extends PathTuple> = PT extends [
  infer K,
  ...infer R,
]
  ? EvaluatePath<EvaluateKey<T, AsKey<K>>, AsPathTuple<R>>
  : T;

/**
 * Type which given a tuple type returns its own keys, i.e. only its indices.
 * @typeParam T - tuple type
 * @example
 * ```
 * TupleKeys<[number, string]> = '0' | '1'
 * ```
 */
export type TupleKeys<T extends ReadonlyArray<any>> = Exclude<
  keyof T,
  keyof any[]
>;

/**
 * Type which extracts all numeric keys from an object.
 * @typeParam T - type
 * @example
 * ```
 * NumericObjectKeys<{0: string, '1': string, foo: string}> = '0' | '1'
 * ```
 */
type NumericObjectKeys<T extends Traversable> = ToKey<
  Extract<keyof T, ArrayKey | `${ArrayKey}`>
>;

/**
 * Type which extracts all numeric keys from an object, tuple, or array.
 * If a union is passed, it evaluates to the overlapping numeric keys.
 * @typeParam T - type
 * @example
 * ```
 * NumericKeys<{0: string, '1': string, foo: string}> = '0' | '1'
 * NumericKeys<number[]> = `${number}`
 * NumericKeys<[string, number]> = '0' | '1'
 * NumericKeys<{0: string, '1': string} | [number] | number[]> = '0'
 * ```
 */
export type NumericKeys<T extends Traversable> = UnionToIntersection<
  T extends ReadonlyArray<any>
    ? IsTuple<T> extends true
      ? [TupleKeys<T>]
      : [ToKey<ArrayKey>]
    : [NumericObjectKeys<T>]
>[never];

/**
 * Type which extracts all keys from an object.
 * If a union is passed, it evaluates to the overlapping keys.
 * @typeParam T - object type
 * @example
 * ```
 * ObjectKeys<{foo: string, bar: string}> = 'foo' | 'bar'
 * ObjectKeys<{foo: string, bar: number} | { foo: string }> = 'foo'
 * ```
 */
export type ObjectKeys<T extends Traversable> = Exclude<
  ToKey<keyof T>,
  `${string}.${string}` | ''
>;

/**
 * Type to check whether a type's property matches the constraint type
 * and return its key. Converts the key to a {@link Key}.
 * @typeParam T - type whose property should be checked
 * @typeParam K - key of the property
 * @typeParam U - constraint type
 * @example
 * ```
 * CheckKeyConstraint<{foo: string}, 'foo', string> = 'foo'
 * CheckKeyConstraint<{foo: string}, 'foo', number> = never
 * CheckKeyConstraint<string[], number, string> = `${number}`
 * ```
 */
export type CheckKeyConstraint<T, K extends Key, U> = K extends any
  ? EvaluateKey<T, K> extends U
    ? K
    : never
  : never;

/**
 * Type which evaluates to true when the type is an array or tuple or is a union
 * which contains an array or tuple.
 * @typeParam T - type
 * @example
 * ```
 * ContainsIndexable<{foo: string}> = false
 * ContainsIndexable<{foo: string} | number[]> = true
 * ```
 */
export type ContainsIndexable<T> =
  IsNever<Extract<T, ReadonlyArray<any>>> extends true ? false : true;

/**
 * Type to implement {@link Keys} for non-nullable values.
 * @typeParam T - non-nullable type whose property should be checked
 */
type KeysImpl<T> = [T] extends [Traversable]
  ? ContainsIndexable<T> extends true
    ? NumericKeys<T>
    : ObjectKeys<T>
  : never;

/**
 * Type to find all properties of a type that match the constraint type
 * and return their keys.
 * If a union is passed, it evaluates to the overlapping keys.
 * @typeParam T - type whose property should be checked
 * @typeParam U - constraint type
 * @example
 * ```
 * Keys<{foo: string, bar: string}, string> = 'foo' | 'bar'
 * Keys<{foo?: string, bar?: string}> = 'foo' | 'bar'
 * Keys<{foo: string, bar: number}, string> = 'foo'
 * Keys<[string, number], string> = '0'
 * Keys<string[], string> = `${number}`
 * Keys<{0: string, '1': string} | [number] | number[]> = '0'
 * ```
 */
export type Keys<T, U = unknown> =
  IsAny<T> extends true
    ? Key
    : IsNever<T> extends true
      ? Key
      : IsNever<NonNullable<T>> extends true
        ? never
        : CheckKeyConstraint<T, KeysImpl<NonNullable<T>>, U>;

/**
 * Type to check whether a {@link Key} is present in a type.
 * If a union of {@link Key}s is passed, all {@link Key}s have to be present
 * in the type.
 * @typeParam T - type which is introspected
 * @typeParam K - key
 * @example
 * ```
 * HasKey<{foo: string}, 'foo'> = true
 * HasKey<{foo: string}, 'bar'> = false
 * HasKey<{foo: string}, 'foo' | 'bar'> = false
 * ```
 */
export type HasKey<T, K extends Key> = IsNever<Exclude<K, Keys<T>>>;

/**
 * Type to implement {@link ValidPathPrefix} tail recursively.
 * @typeParam T   - type which the path should be checked against
 * @typeParam PT  - path which should exist within the given type
 * @typeParam VPT - accumulates the prefix of {@link Key}s which have been
 *                  confirmed to exist already
 */
type ValidPathPrefixImpl<
  T,
  PT extends PathTuple,
  VPT extends PathTuple,
> = PT extends [infer K, ...infer R]
  ? HasKey<T, AsKey<K>> extends true
    ? ValidPathPrefixImpl<
        EvaluateKey<T, AsKey<K>>,
        AsPathTuple<R>,
        AsPathTuple<[...VPT, K]>
      >
    : VPT
  : VPT;

/**
 * Type to find the longest path prefix which is still valid,
 * i.e. exists within the given type.
 * @typeParam T  - type which the path should be checked against
 * @typeParam PT - path which should exist within the given type
 * @example
 * ```
 * ValidPathPrefix<{foo: {bar: string}}, ['foo', 'bar']> = ['foo', 'bar']
 * ValidPathPrefix<{foo: {bar: string}}, ['foo', 'ba']> = ['foo']
 * ```
 */
export type ValidPathPrefix<T, PT extends PathTuple> = ValidPathPrefixImpl<
  T,
  PT,
  []
>;

/**
 * Type to check whether a path through a type exists.
 * @typeParam T  - type which the path should be checked against
 * @typeParam PT - path which should exist within the given type
 * @example
 * ```
 * HasPath<{foo: {bar: string}}, ['foo', 'bar']> = true
 * HasPath<{foo: {bar: string}}, ['foo', 'ba']> = false
 * ```
 */
export type HasPath<T, PT extends PathTuple> =
  ValidPathPrefix<T, PT> extends PT ? true : false;


================================================
File: /src/types/path/index.ts
================================================
/** Re-export public API */

export { PathString } from './common';
export {
  ArrayPath,
  FieldArrayPath,
  FieldArrayPathValue,
  FieldPath,
  FieldPathByValue,
  FieldPathValue,
  FieldPathValues,
  Path,
  PathValue,
} from './eager';


================================================
File: /src/types/path/eager.ts
================================================
import { FieldValues } from '../fields';
import { BrowserNativeObject, IsAny, IsEqual, Primitive } from '../utils';

import { ArrayKey, IsTuple, TupleKeys } from './common';

/**
 * Helper function to break apart T1 and check if any are equal to T2
 *
 * See {@link IsEqual}
 */
type AnyIsEqual<T1, T2> = T1 extends T2
  ? IsEqual<T1, T2> extends true
    ? true
    : never
  : never;

/**
 * Helper type for recursively constructing paths through a type.
 * This actually constructs the strings and recurses into nested
 * object types.
 *
 * See {@link Path}
 */
type PathImpl<K extends string | number, V, TraversedTypes> = V extends
  | Primitive
  | BrowserNativeObject
  ? `${K}`
  : // Check so that we don't recurse into the same type
    // by ensuring that the types are mutually assignable
    // mutually required to avoid false positives of subtypes
    true extends AnyIsEqual<TraversedTypes, V>
    ? `${K}`
    : `${K}` | `${K}.${PathInternal<V, TraversedTypes | V>}`;

/**
 * Helper type for recursively constructing paths through a type.
 * This obscures the internal type param TraversedTypes from exported contract.
 *
 * See {@link Path}
 */
type PathInternal<T, TraversedTypes = T> =
  T extends ReadonlyArray<infer V>
    ? IsTuple<T> extends true
      ? {
          [K in TupleKeys<T>]-?: PathImpl<K & string, T[K], TraversedTypes>;
        }[TupleKeys<T>]
      : PathImpl<ArrayKey, V, TraversedTypes>
    : {
        [K in keyof T]-?: PathImpl<K & string, T[K], TraversedTypes>;
      }[keyof T];

/**
 * Type which eagerly collects all paths through a type
 * @typeParam T - type which should be introspected
 * @example
 * ```
 * Path<{foo: {bar: string}}> = 'foo' | 'foo.bar'
 * ```
 */
// We want to explode the union type and process each individually
// so assignable types don't leak onto the stack from the base.
export type Path<T> = T extends any ? PathInternal<T> : never;

/**
 * See {@link Path}
 */
export type FieldPath<TFieldValues extends FieldValues> = Path<TFieldValues>;

/**
 * Helper type for recursively constructing paths through a type.
 * This actually constructs the strings and recurses into nested
 * object types.
 *
 * See {@link ArrayPath}
 */
type ArrayPathImpl<K extends string | number, V, TraversedTypes> = V extends
  | Primitive
  | BrowserNativeObject
  ? IsAny<V> extends true
    ? string
    : never
  : V extends ReadonlyArray<infer U>
    ? U extends Primitive | BrowserNativeObject
      ? IsAny<V> extends true
        ? string
        : never
      : // Check so that we don't recurse into the same type
        // by ensuring that the types are mutually assignable
        // mutually required to avoid false positives of subtypes
        true extends AnyIsEqual<TraversedTypes, V>
        ? never
        : `${K}` | `${K}.${ArrayPathInternal<V, TraversedTypes | V>}`
    : true extends AnyIsEqual<TraversedTypes, V>
      ? never
      : `${K}.${ArrayPathInternal<V, TraversedTypes | V>}`;

/**
 * Helper type for recursively constructing paths through a type.
 * This obscures the internal type param TraversedTypes from exported contract.
 *
 * See {@link ArrayPath}
 */
type ArrayPathInternal<T, TraversedTypes = T> =
  T extends ReadonlyArray<infer V>
    ? IsTuple<T> extends true
      ? {
          [K in TupleKeys<T>]-?: ArrayPathImpl<
            K & string,
            T[K],
            TraversedTypes
          >;
        }[TupleKeys<T>]
      : ArrayPathImpl<ArrayKey, V, TraversedTypes>
    : {
        [K in keyof T]-?: ArrayPathImpl<K & string, T[K], TraversedTypes>;
      }[keyof T];

/**
 * Type which eagerly collects all paths through a type which point to an array
 * type.
 * @typeParam T - type which should be introspected.
 * @example
 * ```
 * Path<{foo: {bar: string[], baz: number[]}}> = 'foo.bar' | 'foo.baz'
 * ```
 */
// We want to explode the union type and process each individually
// so assignable types don't leak onto the stack from the base.
export type ArrayPath<T> = T extends any ? ArrayPathInternal<T> : never;

/**
 * See {@link ArrayPath}
 */
export type FieldArrayPath<TFieldValues extends FieldValues> =
  ArrayPath<TFieldValues>;

/**
 * Type to evaluate the type which the given path points to.
 * @typeParam T - deeply nested type which is indexed by the path
 * @typeParam P - path into the deeply nested type
 * @example
 * ```
 * PathValue<{foo: {bar: string}}, 'foo.bar'> = string
 * PathValue<[number, string], '1'> = string
 * ```
 */
export type PathValue<T, P extends Path<T> | ArrayPath<T>> = T extends any
  ? P extends `${infer K}.${infer R}`
    ? K extends keyof T
      ? R extends Path<T[K]>
        ? PathValue<T[K], R>
        : never
      : K extends `${ArrayKey}`
        ? T extends ReadonlyArray<infer V>
          ? PathValue<V, R & Path<V>>
          : never
        : never
    : P extends keyof T
      ? T[P]
      : P extends `${ArrayKey}`
        ? T extends ReadonlyArray<infer V>
          ? V
          : never
        : never
  : never;

/**
 * See {@link PathValue}
 */
export type FieldPathValue<
  TFieldValues extends FieldValues,
  TFieldPath extends FieldPath<TFieldValues>,
> = PathValue<TFieldValues, TFieldPath>;

/**
 * See {@link PathValue}
 */
export type FieldArrayPathValue<
  TFieldValues extends FieldValues,
  TFieldArrayPath extends FieldArrayPath<TFieldValues>,
> = PathValue<TFieldValues, TFieldArrayPath>;

/**
 * Type to evaluate the type which the given paths point to.
 * @typeParam TFieldValues - field values which are indexed by the paths
 * @typeParam TPath        - paths into the deeply nested field values
 * @example
 * ```
 * FieldPathValues<{foo: {bar: string}}, ['foo', 'foo.bar']>
 *   = [{bar: string}, string]
 * ```
 */
export type FieldPathValues<
  TFieldValues extends FieldValues,
  TPath extends FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[],
> = {} & {
  [K in keyof TPath]: FieldPathValue<
    TFieldValues,
    TPath[K] & FieldPath<TFieldValues>
  >;
};

/**
 * Type which eagerly collects all paths through a fieldType that matches a give type
 * @typeParam TFieldValues - field values which are indexed by the paths
 * @typeParam TValue       - the value you want to match into each type
 * @example
 * ```typescript
 * FieldPathByValue<{foo: {bar: number}, baz: number, bar: string}, number>
 *   = 'foo.bar' | 'baz'
 * ```
 */
export type FieldPathByValue<TFieldValues extends FieldValues, TValue> = {
  [Key in FieldPath<TFieldValues>]: FieldPathValue<
    TFieldValues,
    Key
  > extends TValue
    ? Key
    : never;
}[FieldPath<TFieldValues>];


================================================
File: /src/types/validator.ts
================================================
import { INPUT_VALIDATION_RULES } from '../constants';

import { Message } from './errors';
import { FieldValues } from './fields';
import { FieldPath, FieldPathValue } from './path';

export type ValidationValue = boolean | number | string | RegExp;

export type ValidationRule<
  TValidationValue extends ValidationValue = ValidationValue,
> = TValidationValue | ValidationValueMessage<TValidationValue>;

export type ValidationValueMessage<
  TValidationValue extends ValidationValue = ValidationValue,
> = {
  value: TValidationValue;
  message: Message;
};

export type ValidateResult = Message | Message[] | boolean | undefined;

export type Validate<TFieldValue, TFormValues> = (
  value: TFieldValue,
  formValues: TFormValues,
) => ValidateResult | Promise<ValidateResult>;

export type RegisterOptions<
  TFieldValues extends FieldValues = FieldValues,
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = Partial<{
  required: Message | ValidationRule<boolean>;
  min: ValidationRule<number | string>;
  max: ValidationRule<number | string>;
  maxLength: ValidationRule<number>;
  minLength: ValidationRule<number>;
  validate:
    | Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues>
    | Record<
        string,
        Validate<FieldPathValue<TFieldValues, TFieldName>, TFieldValues>
      >;
  value: FieldPathValue<TFieldValues, TFieldName>;
  setValueAs: (value: any) => any;
  shouldUnregister?: boolean;
  onChange?: (event: any) => void;
  onBlur?: (event: any) => void;
  disabled: boolean;
  deps: FieldPath<TFieldValues> | FieldPath<TFieldValues>[];
}> &
  (
    | {
        pattern?: ValidationRule<RegExp>;
        valueAsNumber?: false;
        valueAsDate?: false;
      }
    | {
        pattern?: undefined;
        valueAsNumber?: false;
        valueAsDate?: true;
      }
    | {
        pattern?: undefined;
        valueAsNumber?: true;
        valueAsDate?: false;
      }
  );

export type InputValidationRules = typeof INPUT_VALIDATION_RULES;

export type MaxType =
  | InputValidationRules['max']
  | InputValidationRules['maxLength'];

export type MinType =
  | InputValidationRules['min']
  | InputValidationRules['minLength'];


================================================
File: /src/types/controller.ts
================================================
import React from 'react';

import { RegisterOptions } from './validator';
import {
  Control,
  FieldError,
  FieldPath,
  FieldPathValue,
  FieldValues,
  Noop,
  RefCallBack,
  UseFormStateReturn,
} from './';

export type ControllerFieldState = {
  invalid: boolean;
  isTouched: boolean;
  isDirty: boolean;
  isValidating: boolean;
  error?: FieldError;
};

export type ControllerRenderProps<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  onChange: (...event: any[]) => void;
  onBlur: Noop;
  value: FieldPathValue<TFieldValues, TName>;
  disabled?: boolean;
  name: TName;
  ref: RefCallBack;
};

export type UseControllerProps<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
  rules?: Omit<
    RegisterOptions<TFieldValues, TName>,
    'valueAsNumber' | 'valueAsDate' | 'setValueAs' | 'disabled'
  >;
  shouldUnregister?: boolean;
  defaultValue?: FieldPathValue<TFieldValues, TName>;
  control?: Control<TFieldValues>;
  disabled?: boolean;
};

export type UseControllerReturn<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  field: ControllerRenderProps<TFieldValues, TName>;
  formState: UseFormStateReturn<TFieldValues>;
  fieldState: ControllerFieldState;
};

/**
 * Render function to provide the control for the field.
 *
 * @returns all the event handlers, and relevant field and form state.
 *
 * @example
 * ```tsx
 * const { field, fieldState, formState } = useController();
 *
 * <Controller
 *   render={({ field, formState, fieldState }) => ({
 *     <input
 *       onChange={field.onChange}
 *       onBlur={field.onBlur}
 *       name={field.name}
 *       ref={field.ref} // optional for focus management
 *     />
 *   })}
 * />
 * ```
 */
export type ControllerProps<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  render: ({
    field,
    fieldState,
    formState,
  }: {
    field: ControllerRenderProps<TFieldValues, TName>;
    fieldState: ControllerFieldState;
    formState: UseFormStateReturn<TFieldValues>;
  }) => React.ReactElement;
} & UseControllerProps<TFieldValues, TName>;


================================================
File: /src/types/resolvers.ts
================================================
import { FieldErrors } from './errors';
import { Field, FieldName, FieldValues, InternalFieldName } from './fields';
import { CriteriaMode } from './form';

export type ResolverSuccess<TFieldValues extends FieldValues = FieldValues> = {
  values: TFieldValues;
  errors: {};
};

export type ResolverError<TFieldValues extends FieldValues = FieldValues> = {
  values: {};
  errors: FieldErrors<TFieldValues>;
};

export type ResolverResult<TFieldValues extends FieldValues = FieldValues> =
  | ResolverSuccess<TFieldValues>
  | ResolverError<TFieldValues>;

export interface ResolverOptions<TFieldValues extends FieldValues> {
  criteriaMode?: CriteriaMode;
  fields: Record<InternalFieldName, Field['_f']>;
  names?: FieldName<TFieldValues>[];
  shouldUseNativeValidation: boolean | undefined;
}

export type Resolver<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
> = (
  values: TFieldValues,
  context: TContext | undefined,
  options: ResolverOptions<TFieldValues>,
) => Promise<ResolverResult<TFieldValues>> | ResolverResult<TFieldValues>;


================================================
File: /src/types/utils.ts
================================================
import { NestedValue } from './form';

/*
Projects that React Hook Form installed don't include the DOM library need these interfaces to compile.
React Native applications is no DOM available. The JavaScript runtime is ES6/ES2015 only.
These definitions allow such projects to compile with only --lib ES6.

Warning: all of these interfaces are empty.
If you want type definitions for various properties, you need to add `--lib DOM` (via command line or tsconfig.json).
*/

export type Noop = () => void;

interface File extends Blob {
  readonly lastModified: number;
  readonly name: string;
}

interface FileList {
  readonly length: number;
  item(index: number): File | null;
  [index: number]: File;
}

export type Primitive =
  | null
  | undefined
  | string
  | number
  | boolean
  | symbol
  | bigint;

export type BrowserNativeObject = Date | FileList | File;

export type EmptyObject = { [K in string | number]: never };

export type NonUndefined<T> = T extends undefined ? never : T;

export type LiteralUnion<T extends U, U extends Primitive> =
  | T
  | (U & { _?: never });

export type ExtractObjects<T> = T extends infer U
  ? U extends object
    ? U
    : never
  : never;

export type DeepPartial<T> = T extends BrowserNativeObject | NestedValue
  ? T
  : {
      [K in keyof T]?: ExtractObjects<T[K]> extends never
        ? T[K]
        : DeepPartial<T[K]>;
    };

export type DeepPartialSkipArrayKey<T> = T extends
  | BrowserNativeObject
  | NestedValue
  ? T
  : T extends ReadonlyArray<any>
    ? { [K in keyof T]: DeepPartialSkipArrayKey<T[K]> }
    : { [K in keyof T]?: DeepPartialSkipArrayKey<T[K]> };

/**
 * Checks whether the type is any
 * See {@link https://stackoverflow.com/a/49928360/3406963}
 * @typeParam T - type which may be any
 * ```
 * IsAny<any> = true
 * IsAny<string> = false
 * ```
 */
export type IsAny<T> = 0 extends 1 & T ? true : false;

/**
 * Checks whether the type is never
 * @typeParam T - type which may be never
 * ```
 * IsAny<never> = true
 * IsAny<string> = false
 * ```
 */
export type IsNever<T> = [T] extends [never] ? true : false;

/**
 * Checks whether T1 can be exactly (mutually) assigned to T2
 * @typeParam T1 - type to check
 * @typeParam T2 - type to check against
 * ```
 * IsEqual<string, string> = true
 * IsEqual<'foo', 'foo'> = true
 * IsEqual<string, number> = false
 * IsEqual<string, number> = false
 * IsEqual<string, 'foo'> = false
 * IsEqual<'foo', string> = false
 * IsEqual<'foo' | 'bar', 'foo'> = boolean // 'foo' is assignable, but 'bar' is not (true | false) -> boolean
 * ```
 */
export type IsEqual<T1, T2> = T1 extends T2
  ? (<G>() => G extends T1 ? 1 : 2) extends <G>() => G extends T2 ? 1 : 2
    ? true
    : false
  : false;

export type DeepMap<T, TValue> =
  IsAny<T> extends true
    ? any
    : T extends BrowserNativeObject | NestedValue
      ? TValue
      : T extends object
        ? { [K in keyof T]: DeepMap<NonUndefined<T[K]>, TValue> }
        : TValue;

export type IsFlatObject<T extends object> =
  Extract<
    Exclude<T[keyof T], NestedValue | Date | FileList>,
    any[] | object
  > extends never
    ? true
    : false;

export type Merge<A, B> = {
  [K in keyof A | keyof B]?: K extends keyof A & keyof B
    ? [A[K], B[K]] extends [object, object]
      ? Merge<A[K], B[K]>
      : A[K] | B[K]
    : K extends keyof A
      ? A[K]
      : K extends keyof B
        ? B[K]
        : never;
};


================================================
File: /src/types/form.ts
================================================
import React from 'react';

import { VALIDATION_MODE } from '../constants';
import { Subject, Subscription } from '../utils/createSubject';

import { ErrorOption, FieldError, FieldErrors } from './errors';
import { EventType } from './events';
import { FieldArray } from './fieldArray';
import {
  Field,
  FieldName,
  FieldRefs,
  FieldValue,
  FieldValues,
  InternalFieldName,
} from './fields';
import {
  FieldArrayPath,
  FieldPath,
  FieldPathValue,
  FieldPathValues,
} from './path';
import { Resolver } from './resolvers';
import { DeepMap, DeepPartial, Noop } from './utils';
import { RegisterOptions } from './validator';

declare const $NestedValue: unique symbol;

/**
 * @deprecated to be removed in the next major version
 */
export type NestedValue<TValue extends object = object> = {
  [$NestedValue]: never;
} & TValue;

/**
 * @deprecated to be removed in the next major version
 */
export type UnpackNestedValue<T> =
  T extends NestedValue<infer U>
    ? U
    : T extends Date | FileList | File | Blob
      ? T
      : T extends object
        ? { [K in keyof T]: UnpackNestedValue<T[K]> }
        : T;

export type DefaultValues<TFieldValues> =
  TFieldValues extends AsyncDefaultValues<TFieldValues>
    ? DeepPartial<Awaited<TFieldValues>>
    : DeepPartial<TFieldValues>;

export type InternalNameSet = Set<InternalFieldName>;

export type ValidationMode = typeof VALIDATION_MODE;

export type Mode = keyof ValidationMode;

export type ValidationModeFlags = {
  isOnSubmit: boolean;
  isOnBlur: boolean;
  isOnChange: boolean;
  isOnAll: boolean;
  isOnTouch: boolean;
};

export type CriteriaMode = 'firstError' | 'all';

export type SubmitHandler<TFieldValues extends FieldValues> = (
  data: TFieldValues,
  event?: React.BaseSyntheticEvent,
) => unknown | Promise<unknown>;

export type FormSubmitHandler<TFieldValues extends FieldValues> = (payload: {
  data: TFieldValues;
  event?: React.BaseSyntheticEvent;
  formData: FormData;
  formDataJson: string;
  method?: 'post' | 'put' | 'delete';
}) => unknown | Promise<unknown>;

export type SubmitErrorHandler<TFieldValues extends FieldValues> = (
  errors: FieldErrors<TFieldValues>,
  event?: React.BaseSyntheticEvent,
) => unknown | Promise<unknown>;

export type SetValueConfig = Partial<{
  shouldValidate: boolean;
  shouldDirty: boolean;
  shouldTouch: boolean;
}>;

export type TriggerConfig = Partial<{
  shouldFocus: boolean;
}>;

export type ChangeHandler = (event: {
  target: any;
  type?: any;
}) => Promise<void | boolean>;

export type DelayCallback = (wait: number) => void;

type AsyncDefaultValues<TFieldValues> = (
  payload?: unknown,
) => Promise<TFieldValues>;

export type UseFormProps<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
> = Partial<{
  mode: Mode;
  disabled: boolean;
  reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
  defaultValues: DefaultValues<TFieldValues> | AsyncDefaultValues<TFieldValues>;
  values: TFieldValues;
  errors: FieldErrors<TFieldValues>;
  resetOptions: Parameters<UseFormReset<TFieldValues>>[1];
  resolver: Resolver<TFieldValues, TContext>;
  context: TContext;
  shouldFocusError: boolean;
  shouldUnregister: boolean;
  shouldUseNativeValidation: boolean;
  progressive: boolean;
  criteriaMode: CriteriaMode;
  delayError: number;
}>;

export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<
  DeepPartial<TFieldValues>,
  boolean
>;

export type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {
  isDirty: boolean;
  isValidating: boolean;
  dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;
  touchedFields: FieldNamesMarkedBoolean<TFieldValues>;
  validatingFields: FieldNamesMarkedBoolean<TFieldValues>;
  errors: boolean;
  isValid: boolean;
};

export type ReadFormState = { [K in keyof FormStateProxy]: boolean | 'all' };

export type FormState<TFieldValues extends FieldValues> = {
  isDirty: boolean;
  isLoading: boolean;
  isSubmitted: boolean;
  isSubmitSuccessful: boolean;
  isSubmitting: boolean;
  isValidating: boolean;
  isValid: boolean;
  disabled: boolean;
  submitCount: number;
  defaultValues?: undefined | Readonly<DeepPartial<TFieldValues>>;
  dirtyFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
  touchedFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
  validatingFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
  errors: FieldErrors<TFieldValues>;
};

export type KeepStateOptions = Partial<{
  keepDirtyValues: boolean;
  keepErrors: boolean;
  keepDirty: boolean;
  keepValues: boolean;
  keepDefaultValues: boolean;
  keepIsSubmitted: boolean;
  keepIsSubmitSuccessful: boolean;
  keepTouched: boolean;
  keepIsValidating: boolean;
  keepIsValid: boolean;
  keepSubmitCount: boolean;
}>;

export type SetFieldValue<TFieldValues extends FieldValues> =
  FieldValue<TFieldValues>;

export type RefCallBack = (instance: any) => void;

export type UseFormRegisterReturn<
  TFieldName extends InternalFieldName = InternalFieldName,
> = {
  onChange: ChangeHandler;
  onBlur: ChangeHandler;
  ref: RefCallBack;
  name: TFieldName;
  min?: string | number;
  max?: string | number;
  maxLength?: number;
  minLength?: number;
  pattern?: string;
  required?: boolean;
  disabled?: boolean;
};

/**
 * Register field into hook form with or without the actual DOM ref. You can invoke register anywhere in the component including at `useEffect`.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/register) • [Demo](https://codesandbox.io/s/react-hook-form-register-ts-ip2j3) • [Video](https://www.youtube.com/watch?v=JFIpCoajYkA)
 *
 * @param name - the path name to the form field value, name is required and unique
 * @param options - register options include validation, disabled, unregister, value as and dependent validation
 *
 * @returns onChange, onBlur, name, ref, and native contribute attribute if browser validation is enabled.
 *
 * @example
 * ```tsx
 * // Register HTML native input
 * <input {...register("input")} />
 * <select {...register("select")} />
 *
 * // Register options
 * <textarea {...register("textarea", { required: "This is required.", maxLength: 20 })} />
 * <input type="number" {...register("name2", { valueAsNumber: true })} />
 * <input {...register("name3", { deps: ["name2"] })} />
 *
 * // Register custom field at useEffect
 * useEffect(() => {
 *   register("name4");
 *   register("name5", { value: "hiddenValue" });
 * }, [register])
 *
 * // Register without ref
 * const { onChange, onBlur, name } = register("name6")
 * <input onChange={onChange} onBlur={onBlur} name={name} />
 * ```
 */
export type UseFormRegister<TFieldValues extends FieldValues> = <
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  name: TFieldName,
  options?: RegisterOptions<TFieldValues, TFieldName>,
) => UseFormRegisterReturn<TFieldName>;

export type SetFocusOptions = Partial<{
  shouldSelect: boolean;
}>;

/**
 * Set focus on a registered field. You can start to invoke this method after all fields are mounted to the DOM.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/setfocus) • [Demo](https://codesandbox.io/s/setfocus-rolus)
 *
 * @param name - the path name to the form field value.
 * @param options - input focus behavior options
 *
 * @example
 * ```tsx
 * useEffect(() => {
 *   setFocus("name");
 * }, [setFocus])
 * // shouldSelect allows to select input's content on focus
 * <button onClick={() => setFocus("name", { shouldSelect: true })}>Focus</button>
 * ```
 */
export type UseFormSetFocus<TFieldValues extends FieldValues> = <
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  name: TFieldName,
  options?: SetFocusOptions,
) => void;

export type UseFormGetValues<TFieldValues extends FieldValues> = {
  /**
   * Get the entire form values when no argument is supplied to this function.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/getvalues) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
   *
   * @returns form values
   *
   * @example
   * ```tsx
   * <button onClick={() => getValues()}>getValues</button>
   *
   * <input {...register("name", {
   *   validate: (value, formValues) => formValues.otherField === value;
   * })} />
   * ```
   */
  (): TFieldValues;
  /**
   * Get a single field value.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/getvalues) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
   *
   * @param name - the path name to the form field value.
   *
   * @returns the single field value
   *
   * @example
   * ```tsx
   * <button onClick={() => getValues("name")}>getValues</button>
   *
   * <input {...register("name", {
   *   validate: () => getValues('otherField') === "test";
   * })} />
   * ```
   */
  <TFieldName extends FieldPath<TFieldValues>>(
    name: TFieldName,
  ): FieldPathValue<TFieldValues, TFieldName>;
  /**
   * Get an array of field values.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/getvalues) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
   *
   * @param names - an array of field names
   *
   * @returns An array of field values
   *
   * @example
   * ```tsx
   * <button onClick={() => getValues(["name", "name1"])}>getValues</button>
   *
   * <input {...register("name", {
   *   validate: () => getValues(["fieldA", "fieldB"]).includes("test");
   * })} />
   * ```
   */
  <TFieldNames extends FieldPath<TFieldValues>[]>(
    names: readonly [...TFieldNames],
  ): [...FieldPathValues<TFieldValues, TFieldNames>];
};

/**
 * This method will return individual field states. It will be useful when you are trying to retrieve the nested value field state in a typesafe approach.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/getfieldstate) • [Demo](https://codesandbox.io/s/getfieldstate-jvekk)
 *
 * @param name - the path name to the form field value.
 *
 * @returns invalid, isDirty, isTouched and error object
 *
 * @example
 * ```tsx
 * // those formState has to be subscribed
 * const { formState: { dirtyFields, errors, touchedFields } } = formState();
 * getFieldState('name')
 * // Get field state when form state is not subscribed yet
 * getFieldState('name', formState)
 *
 * // It's ok to combine with useFormState
 * const formState = useFormState();
 * getFieldState('name')
 * getFieldState('name', formState)
 * ```
 */
export type UseFormGetFieldState<TFieldValues extends FieldValues> = <
  TFieldName extends FieldPath<TFieldValues>,
>(
  name: TFieldName,
  formState?: FormState<TFieldValues>,
) => {
  invalid: boolean;
  isDirty: boolean;
  isTouched: boolean;
  isValidating: boolean;
  error?: FieldError;
};

export type UseFormWatch<TFieldValues extends FieldValues> = {
  /**
   * Watch and subscribe to the entire form update/change based on onChange and re-render at the useForm.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/watch) • [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) • [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
   *
   * @returns return the entire form values
   *
   * @example
   * ```tsx
   * const formValues = watch();
   * ```
   */
  (): TFieldValues;
  /**
   * Watch and subscribe to an array of fields used outside of render.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/watch) • [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) • [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
   *
   * @param names - an array of field names
   * @param defaultValue - defaultValues for the entire form
   *
   * @returns return an array of field values
   *
   * @example
   * ```tsx
   * const [name, name1] = watch(["name", "name1"]);
   * ```
   */
  <TFieldNames extends readonly FieldPath<TFieldValues>[]>(
    names: readonly [...TFieldNames],
    defaultValue?: DeepPartial<TFieldValues>,
  ): FieldPathValues<TFieldValues, TFieldNames>;
  /**
   * Watch and subscribe to a single field used outside of render.
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/watch) • [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) • [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
   *
   * @param name - the path name to the form field value.
   * @param defaultValue - defaultValues for the entire form
   *
   * @returns return the single field value
   *
   * @example
   * ```tsx
   * const name = watch("name");
   * ```
   */
  <TFieldName extends FieldPath<TFieldValues>>(
    name: TFieldName,
    defaultValue?: FieldPathValue<TFieldValues, TFieldName>,
  ): FieldPathValue<TFieldValues, TFieldName>;
  /**
   * Subscribe to field update/change without trigger re-render
   *
   * @remarks
   * [API](https://react-hook-form.com/docs/useform/watch) • [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d) • [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
   *
   * @param callback - call back function to subscribe all fields change and return unsubscribe function
   * @param defaultValues - defaultValues for the entire form
   *
   * @returns unsubscribe function
   *
   * @example
   * ```tsx
   * useEffect(() => {
   *   const { unsubscribe } = watch((value) => {
   *     console.log(value);
   *   });
   *   return () => unsubscribe();
   * }, [watch])
   * ```
   */
  (
    callback: WatchObserver<TFieldValues>,
    defaultValues?: DeepPartial<TFieldValues>,
  ): Subscription;
};

/**
 * Trigger field or form validation
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/trigger) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-triggervalidation-forked-xs7hl) • [Video](https://www.youtube.com/watch?v=-bcyJCDjksE)
 *
 * @param name - provide empty argument will trigger the entire form validation, an array of field names will validate an array of fields, and a single field name will only trigger that field's validation.
 * @param options - should focus on the error field
 *
 * @returns validation result
 *
 * @example
 * ```tsx
 * useEffect(() => {
 *   trigger();
 * }, [trigger])
 *
 * <button onClick={async () => {
 *   const result = await trigger(); // result will be a boolean value
 * }}>
 *  trigger
 *  </button>
 * ```
 */
export type UseFormTrigger<TFieldValues extends FieldValues> = (
  name?:
    | FieldPath<TFieldValues>
    | FieldPath<TFieldValues>[]
    | readonly FieldPath<TFieldValues>[],
  options?: TriggerConfig,
) => Promise<boolean>;

/**
 * Clear the entire form errors.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/clearerrors) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-clearerrors-w3ymx)
 *
 * @param name - the path name to the form field value.
 *
 * @example
 * Clear all errors
 * ```tsx
 * clearErrors(); // clear the entire form error
 * clearErrors(["name", "name1"]) // clear an array of fields' error
 * clearErrors("name2"); // clear a single field error
 * ```
 */
export type UseFormClearErrors<TFieldValues extends FieldValues> = (
  name?:
    | FieldPath<TFieldValues>
    | FieldPath<TFieldValues>[]
    | readonly FieldPath<TFieldValues>[]
    | `root.${string}`
    | 'root',
) => void;

/**
 * Set a single field value, or a group of fields value.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/setvalue) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-setvalue-8z9hx) • [Video](https://www.youtube.com/watch?v=qpv51sCH3fI)
 *
 * @param name - the path name to the form field value.
 * @param value - field value
 * @param options - should validate or update form state
 *
 * @example
 * ```tsx
 * // Update a single field
 * setValue('name', 'value', {
 *   shouldValidate: true, // trigger validation
 *   shouldTouch: true, // update touched fields form state
 *   shouldDirty: true, // update dirty and dirty fields form state
 * });
 *
 * // Update a group fields
 * setValue('root', {
 *   a: 'test', // setValue('root.a', 'data')
 *   b: 'test1', // setValue('root.b', 'data')
 * });
 *
 * // Update a nested object field
 * setValue('select', { label: 'test', value: 'Test' });
 * ```
 */
export type UseFormSetValue<TFieldValues extends FieldValues> = <
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  name: TFieldName,
  value: FieldPathValue<TFieldValues, TFieldName>,
  options?: SetValueConfig,
) => void;

/**
 * Set an error for the field. When set an error which is not associated to a field then manual `clearErrors` invoke is required.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/seterror) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-seterror-nfxxu) • [Video](https://www.youtube.com/watch?v=raMqvE0YyIY)
 *
 * @param name - the path name to the form field value.
 * @param error - an error object which contains type and optional message
 * @param options - whether or not to focus on the field
 *
 * @example
 * ```tsx
 * // when the error is not associated with any fields, `clearError` will need to invoke to clear the error
 * const onSubmit = () => setError("serverError", { type: "server", message: "Error occurred"})
 *
 * <button onClick={() => setError("name", { type: "min" })} />
 *
 * // focus on the input after setting the error
 * <button onClick={() => setError("name", { type: "max" }, { shouldFocus: true })} />
 * ```
 */
export type UseFormSetError<TFieldValues extends FieldValues> = (
  name: FieldPath<TFieldValues> | `root.${string}` | 'root',
  error: ErrorOption,
  options?: {
    shouldFocus: boolean;
  },
) => void;

/**
 * Unregister a field reference and remove its value.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/unregister) • [Demo](https://codesandbox.io/s/react-hook-form-unregister-4k2ey) • [Video](https://www.youtube.com/watch?v=TM99g_NW5Gk&feature=emb_imp_woyt)
 *
 * @param name - the path name to the form field value.
 * @param options - keep form state options
 *
 * @example
 * ```tsx
 * register("name", { required: true })
 *
 * <button onClick={() => unregister("name")} />
 * // there are various keep options to retain formState
 * <button onClick={() => unregister("name", { keepErrors: true })} />
 * ```
 */
export type UseFormUnregister<TFieldValues extends FieldValues> = (
  name?:
    | FieldPath<TFieldValues>
    | FieldPath<TFieldValues>[]
    | readonly FieldPath<TFieldValues>[],
  options?: Omit<
    KeepStateOptions,
    | 'keepIsSubmitted'
    | 'keepSubmitCount'
    | 'keepValues'
    | 'keepDefaultValues'
    | 'keepErrors'
  > & { keepValue?: boolean; keepDefaultValue?: boolean; keepError?: boolean },
) => void;

/**
 * Validate the entire form. Handle submit and error callback.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/handlesubmit) • [Demo](https://codesandbox.io/s/react-hook-form-handlesubmit-ts-v7-lcrtu) • [Video](https://www.youtube.com/watch?v=KzcPKB9SOEk)
 *
 * @param onValid - callback function invoked after form pass validation
 * @param onInvalid - callback function invoked when form failed validation
 *
 * @returns callback - return callback function
 *
 * @example
 * ```tsx
 * const onSubmit = (data) => console.log(data);
 * const onError = (error) => console.log(error);
 *
 * <form onSubmit={handleSubmit(onSubmit, onError)} />
 * ```
 */
export type UseFormHandleSubmit<
  TFieldValues extends FieldValues,
  TTransformedValues extends FieldValues | undefined = undefined,
> = (
  onValid: TTransformedValues extends undefined
    ? SubmitHandler<TFieldValues>
    : TTransformedValues extends FieldValues
      ? SubmitHandler<TTransformedValues>
      : never,
  onInvalid?: SubmitErrorHandler<TFieldValues>,
) => (e?: React.BaseSyntheticEvent) => Promise<void>;

/**
 * Reset a field state and reference.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/resetfield) • [Demo](https://codesandbox.io/s/priceless-firefly-d0kuv) • [Video](https://www.youtube.com/watch?v=IdLFcNaEFEo)
 *
 * @param name - the path name to the form field value.
 * @param options - keep form state options
 *
 * @example
 * ```tsx
 * <input {...register("firstName", { required: true })} />
 * <button type="button" onClick={() => resetField("firstName"))}>Reset</button>
 * ```
 */
export type UseFormResetField<TFieldValues extends FieldValues> = <
  TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(
  name: TFieldName,
  options?: Partial<{
    keepDirty: boolean;
    keepTouched: boolean;
    keepError: boolean;
    defaultValue: FieldPathValue<TFieldValues, TFieldName>;
  }>,
) => void;

type ResetAction<TFieldValues> = (formValues: TFieldValues) => TFieldValues;

/**
 * Reset at the entire form state.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform/reset) • [Demo](https://codesandbox.io/s/react-hook-form-reset-v7-ts-pu901) • [Video](https://www.youtube.com/watch?v=qmCLBjyPwVk)
 *
 * @param values - the entire form values to be reset
 * @param keepStateOptions - keep form state options
 *
 * @example
 * ```tsx
 * useEffect(() => {
 *   // reset the entire form after component mount or form defaultValues is ready
 *   reset({
 *     fieldA: "test"
 *     fieldB: "test"
 *   });
 * }, [reset])
 *
 * // reset by combine with existing form values
 * reset({
 *   ...getValues(),
 *  fieldB: "test"
 *});
 *
 * // reset and keep form state
 * reset({
 *   ...getValues(),
 *}, {
 *   keepErrors: true,
 *   keepDirty: true
 *});
 * ```
 */
export type UseFormReset<TFieldValues extends FieldValues> = (
  values?:
    | DefaultValues<TFieldValues>
    | TFieldValues
    | ResetAction<TFieldValues>,
  keepStateOptions?: KeepStateOptions,
) => void;

export type WatchInternal<TFieldValues> = (
  fieldNames?: InternalFieldName | InternalFieldName[],
  defaultValue?: DeepPartial<TFieldValues>,
  isMounted?: boolean,
  isGlobal?: boolean,
) =>
  | FieldPathValue<FieldValues, InternalFieldName>
  | FieldPathValues<FieldValues, InternalFieldName[]>;

export type GetIsDirty = <TName extends InternalFieldName, TData>(
  name?: TName,
  data?: TData,
) => boolean;

export type FormStateSubjectRef<TFieldValues extends FieldValues> = Subject<
  Partial<FormState<TFieldValues>> & { name?: InternalFieldName }
>;

export type Subjects<TFieldValues extends FieldValues = FieldValues> = {
  values: Subject<{
    name?: InternalFieldName;
    type?: EventType;
    values: FieldValues;
  }>;
  array: Subject<{
    name?: InternalFieldName;
    values?: FieldValues;
  }>;
  state: FormStateSubjectRef<TFieldValues>;
};

export type Names = {
  mount: InternalNameSet;
  unMount: InternalNameSet;
  array: InternalNameSet;
  watch: InternalNameSet;
  focus?: InternalFieldName;
  watchAll?: boolean;
};

export type BatchFieldArrayUpdate = <
  T extends Function,
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
>(
  name: InternalFieldName,
  updatedFieldArrayValues?: Partial<
    FieldArray<TFieldValues, TFieldArrayName>
  >[],
  method?: T,
  args?: Partial<{
    argA: unknown;
    argB: unknown;
  }>,
  shouldSetValue?: boolean,
  shouldUpdateFieldsAndErrors?: boolean,
) => void;

export type Control<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
> = {
  _subjects: Subjects<TFieldValues>;
  _removeUnmounted: Noop;
  _names: Names;
  _state: {
    mount: boolean;
    action: boolean;
    watch: boolean;
  };
  _reset: UseFormReset<TFieldValues>;
  _options: UseFormProps<TFieldValues, TContext>;
  _getDirty: GetIsDirty;
  _resetDefaultValues: Noop;
  _formState: FormState<TFieldValues>;
  _updateValid: (shouldUpdateValid?: boolean) => void;
  _updateFormState: (formState: Partial<FormState<TFieldValues>>) => void;
  _fields: FieldRefs;
  _formValues: FieldValues;
  _proxyFormState: ReadFormState;
  _defaultValues: Partial<DefaultValues<TFieldValues>>;
  _getWatch: WatchInternal<TFieldValues>;
  _updateFieldArray: BatchFieldArrayUpdate;
  _getFieldArray: <TFieldArrayValues>(
    name: InternalFieldName,
  ) => Partial<TFieldArrayValues>[];
  _setErrors: (errors: FieldErrors<TFieldValues>) => void;
  _updateDisabledField: (
    props: {
      disabled?: boolean;
      name: FieldName<any>;
      value?: unknown;
    } & (
      | {
          field?: Field;
          fields?: undefined;
        }
      | {
          field?: undefined;
          fields?: FieldRefs;
        }
    ),
  ) => void;
  _executeSchema: (
    names: InternalFieldName[],
  ) => Promise<{ errors: FieldErrors }>;
  register: UseFormRegister<TFieldValues>;
  handleSubmit: UseFormHandleSubmit<TFieldValues>;
  _disableForm: (disabled?: boolean) => void;
  unregister: UseFormUnregister<TFieldValues>;
  getFieldState: UseFormGetFieldState<TFieldValues>;
  setError: UseFormSetError<TFieldValues>;
};

export type WatchObserver<TFieldValues extends FieldValues> = (
  value: DeepPartial<TFieldValues>,
  info: {
    name?: FieldPath<TFieldValues>;
    type?: EventType;
    values?: unknown;
  },
) => void;

export type UseFormReturn<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
  TTransformedValues extends FieldValues | undefined = undefined,
> = {
  watch: UseFormWatch<TFieldValues>;
  getValues: UseFormGetValues<TFieldValues>;
  getFieldState: UseFormGetFieldState<TFieldValues>;
  setError: UseFormSetError<TFieldValues>;
  clearErrors: UseFormClearErrors<TFieldValues>;
  setValue: UseFormSetValue<TFieldValues>;
  trigger: UseFormTrigger<TFieldValues>;
  formState: FormState<TFieldValues>;
  resetField: UseFormResetField<TFieldValues>;
  reset: UseFormReset<TFieldValues>;
  handleSubmit: UseFormHandleSubmit<TFieldValues, TTransformedValues>;
  unregister: UseFormUnregister<TFieldValues>;
  control: Control<TFieldValues, TContext>;
  register: UseFormRegister<TFieldValues>;
  setFocus: UseFormSetFocus<TFieldValues>;
};

export type UseFormStateProps<TFieldValues extends FieldValues> = Partial<{
  control?: Control<TFieldValues>;
  disabled?: boolean;
  name?:
    | FieldPath<TFieldValues>
    | FieldPath<TFieldValues>[]
    | readonly FieldPath<TFieldValues>[];
  exact?: boolean;
}>;

export type UseFormStateReturn<TFieldValues extends FieldValues> =
  FormState<TFieldValues>;

export type UseWatchProps<TFieldValues extends FieldValues = FieldValues> = {
  defaultValue?: unknown;
  disabled?: boolean;
  name?:
    | FieldPath<TFieldValues>
    | FieldPath<TFieldValues>[]
    | readonly FieldPath<TFieldValues>[];
  control?: Control<TFieldValues>;
  exact?: boolean;
};

export type FormProviderProps<
  TFieldValues extends FieldValues = FieldValues,
  TContext = any,
  TTransformedValues extends FieldValues | undefined = undefined,
> = {
  children: React.ReactNode | React.ReactNode[];
} & UseFormReturn<TFieldValues, TContext, TTransformedValues>;

export type FormProps<
  TFieldValues extends FieldValues,
  TTransformedValues extends FieldValues | undefined = undefined,
> = Omit<React.FormHTMLAttributes<HTMLFormElement>, 'onError' | 'onSubmit'> &
  Partial<{
    control: Control<TFieldValues>;
    headers: Record<string, string>;
    validateStatus: (status: number) => boolean;
    onError: ({
      response,
      error,
    }:
      | {
          response: Response;
          error?: undefined;
        }
      | {
          response?: undefined;
          error: unknown;
        }) => void;
    onSuccess: ({ response }: { response: Response }) => void;
    onSubmit: TTransformedValues extends FieldValues
      ? FormSubmitHandler<TTransformedValues>
      : FormSubmitHandler<TFieldValues>;
    method: 'post' | 'put' | 'delete';
    children: React.ReactNode | React.ReactNode[];
    render: (props: {
      submit: (e?: React.FormEvent) => void;
    }) => React.ReactNode | React.ReactNode[];
    encType:
      | 'application/x-www-form-urlencoded'
      | 'multipart/form-data'
      | 'text/plain'
      | 'application/json';
  }>;


================================================
File: /src/types/fields.ts
================================================
import { IsFlatObject, Noop } from './utils';
import { RegisterOptions } from './validator';

export type InternalFieldName = string;

export type FieldName<TFieldValues extends FieldValues> =
  IsFlatObject<TFieldValues> extends true
    ? Extract<keyof TFieldValues, string>
    : string;

export type CustomElement<TFieldValues extends FieldValues> =
  Partial<HTMLElement> & {
    name: FieldName<TFieldValues>;
    type?: string;
    value?: any;
    disabled?: boolean;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: Noop;
  };

export type FieldValue<TFieldValues extends FieldValues> =
  TFieldValues[InternalFieldName];

export type FieldValues = Record<string, any>;

export type NativeFieldValue =
  | string
  | number
  | boolean
  | null
  | undefined
  | unknown[];

export type FieldElement<TFieldValues extends FieldValues = FieldValues> =
  | HTMLInputElement
  | HTMLSelectElement
  | HTMLTextAreaElement
  | CustomElement<TFieldValues>;

export type Ref = FieldElement;

export type Field = {
  _f: {
    ref: Ref;
    name: InternalFieldName;
    refs?: HTMLInputElement[];
    mount?: boolean;
  } & RegisterOptions;
};

export type FieldRefs = Partial<{
  [key: InternalFieldName]: Field | FieldRefs;
}>;


================================================
File: /src/types/index.ts
================================================
export * from './controller';
export * from './errors';
export * from './events';
export * from './fieldArray';
export * from './fields';
export * from './form';
export * from './path';
export * from './resolvers';
export * from './utils';
export * from './validator';


================================================
File: /src/types/errors.ts
================================================
import { FieldValues, InternalFieldName, Ref } from './fields';
import { BrowserNativeObject, IsAny, LiteralUnion, Merge } from './utils';
import { RegisterOptions, ValidateResult } from './validator';

export type Message = string;

export type MultipleFieldErrors = {
  [K in keyof RegisterOptions]?: ValidateResult;
} & {
  [key: string]: ValidateResult;
};

export type FieldError = {
  type: LiteralUnion<keyof RegisterOptions, string>;
  root?: FieldError;
  ref?: Ref;
  types?: MultipleFieldErrors;
  message?: Message;
};

export type ErrorOption = {
  message?: Message;
  type?: LiteralUnion<keyof RegisterOptions, string>;
  types?: MultipleFieldErrors;
};

export type DeepRequired<T> = T extends BrowserNativeObject | Blob
  ? T
  : {
      [K in keyof T]-?: NonNullable<DeepRequired<T[K]>>;
    };

export type FieldErrorsImpl<T extends FieldValues = FieldValues> = {
  [K in keyof T]?: T[K] extends BrowserNativeObject | Blob
    ? FieldError
    : K extends 'root' | `root.${string}`
      ? GlobalError
      : T[K] extends object
        ? Merge<FieldError, FieldErrorsImpl<T[K]>>
        : FieldError;
};

export type GlobalError = Partial<{
  type: string | number;
  message: Message;
}>;

export type FieldErrors<T extends FieldValues = FieldValues> = Partial<
  FieldValues extends IsAny<FieldValues>
    ? any
    : FieldErrorsImpl<DeepRequired<T>>
> & {
  root?: Record<string, GlobalError> & GlobalError;
};

export type InternalFieldErrors = Partial<
  Record<InternalFieldName, FieldError>
>;


================================================
File: /src/types/events.ts
================================================
export type EventType =
  | 'focus'
  | 'blur'
  | 'change'
  | 'changeText'
  | 'valueChange'
  | 'contentSizeChange'
  | 'endEditing'
  | 'keyPress'
  | 'submitEditing'
  | 'layout'
  | 'selectionChange'
  | 'longPress'
  | 'press'
  | 'pressIn'
  | 'pressOut'
  | 'momentumScrollBegin'
  | 'momentumScrollEnd'
  | 'scroll'
  | 'scrollBeginDrag'
  | 'scrollEndDrag'
  | 'load'
  | 'error'
  | 'progress'
  | 'custom';


================================================
File: /src/types/fieldArray.ts
================================================
import { FieldValues } from './fields';
import { Control } from './form';
import { FieldArrayPath, FieldArrayPathValue } from './path';
import { RegisterOptions, Validate } from './validator';

export type UseFieldArrayProps<
  TFieldValues extends FieldValues = FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
  TKeyName extends string = 'id',
> = {
  name: TFieldArrayName;
  keyName?: TKeyName;
  control?: Control<TFieldValues>;
  rules?: {
    validate?:
      | Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues>
      | Record<
          string,
          Validate<FieldArray<TFieldValues, TFieldArrayName>[], TFieldValues>
        >;
  } & Pick<
    RegisterOptions<TFieldValues>,
    'maxLength' | 'minLength' | 'required'
  >;
  shouldUnregister?: boolean;
};

/**
 * `useFieldArray` returned `fields` with unique id
 */
export type FieldArrayWithId<
  TFieldValues extends FieldValues = FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
  TKeyName extends string = 'id',
> = FieldArray<TFieldValues, TFieldArrayName> & Record<TKeyName, string>;

export type FieldArray<
  TFieldValues extends FieldValues = FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> =
  FieldArrayPathValue<TFieldValues, TFieldArrayName> extends
    | ReadonlyArray<infer U>
    | null
    | undefined
    ? U
    : never;

/**
 * `useFieldArray` focus option, ability to toggle focus on and off with `shouldFocus` and setting focus by either field index or name.
 */
export type FieldArrayMethodProps = {
  shouldFocus?: boolean;
  focusIndex?: number;
  focusName?: string;
};

/**
 * Swap field array by supplying from and to index
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param indexA - from index
 * @param indexB - to index
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => swap(0, 1)}>swap</button>
 * ```
 */
export type UseFieldArraySwap = (indexA: number, indexB: number) => void;

/**
 * Move field array by supplying from and to index
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param indexA - from index
 * @param indexB - to index
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => move(0, 1)}>swap</button>
 * ```
 */
export type UseFieldArrayMove = (indexA: number, indexB: number) => void;

/**
 * Prepend field/fields to the start of the fields and optionally focus. The input value will be registered during this action.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param value - prepend items or items
 * @param options - focus options
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => prepend({ name: "data" })}>Prepend</button>
 * <button type="button" onClick={() => prepend({ name: "data" }, { shouldFocus: false })}>Prepend</button>
 * <button
 *   type="button"
 *   onClick={() => prepend([{ name: "data" }, { name: "data" }])}
 * >
 *   Prepend
 * </button>
 * ```
 */
export type UseFieldArrayPrepend<
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> = (
  value:
    | FieldArray<TFieldValues, TFieldArrayName>
    | FieldArray<TFieldValues, TFieldArrayName>[],
  options?: FieldArrayMethodProps,
) => void;

/**
 * Append field/fields to the end of your fields and focus. The input value will be registered during this action.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param value - append items or items.
 * @param options - focus options
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => append({ name: "data" })}>Append</button>
 * <button type="button" onClick={() => append({ name: "data" }, { shouldFocus: false })}>Append</button>
 * <button
 *   type="button"
 *   onClick={() => append([{ name: "data" }, { name: "data" }])}
 * >
 *   Append
 * </button>
 * ```
 */
export type UseFieldArrayAppend<
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> = (
  value:
    | FieldArray<TFieldValues, TFieldArrayName>
    | FieldArray<TFieldValues, TFieldArrayName>[],
  options?: FieldArrayMethodProps,
) => void;

/**
 * Remove field/fields at particular position.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param index - index to remove at, or remove all when no index provided.
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => remove(0)}>Remove</button>
 * <button
 *   type="button"
 *   onClick={() => remove()}
 * >
 *   Remove all
 * </button>
 * ```
 */
export type UseFieldArrayRemove = (index?: number | number[]) => void;

/**
 * Insert field/fields at particular position and focus.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param index - insert position
 * @param value - insert field or fields
 * @param options - focus options
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => insert(1, { name: "data" })}>Insert</button>
 * <button type="button" onClick={() => insert(1, { name: "data" }, { shouldFocus: false })}>Insert</button>
 * <button
 *   type="button"
 *   onClick={() => insert(1, [{ name: "data" }, { name: "data" }])}
 * >
 *   Insert
 * </button>
 * ```
 */
export type UseFieldArrayInsert<
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> = (
  index: number,
  value:
    | FieldArray<TFieldValues, TFieldArrayName>
    | FieldArray<TFieldValues, TFieldArrayName>[],
  options?: FieldArrayMethodProps,
) => void;

/**
 * Update field/fields at particular position.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param index - insert position
 * @param value - insert field or fields
 *
 * @example
 * ```tsx
 * <button type="button" onClick={() => update(1, { name: "data" })}>Update</button>
 * <button
 *   type="button"
 *   onClick={() => update(1, [{ name: "data" }, { name: "data" }])}
 * >
 *   Update
 * </button>
 * ```
 */
export type UseFieldArrayUpdate<
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName>) => void;

/**
 * Replace the entire field array values.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/calc-i231d)
 *
 * @param value - the entire field values.
 *
 * @example
 * ```tsx
 * <button
 *   type="button"
 *   onClick={() => replace([{ name: "data" }, { name: "data" }])}
 * >
 *   Replace
 * </button>
 * ```
 */
export type UseFieldArrayReplace<
  TFieldValues extends FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
> = (
  value:
    | FieldArray<TFieldValues, TFieldArrayName>
    | FieldArray<TFieldValues, TFieldArrayName>[],
) => void;

export type UseFieldArrayReturn<
  TFieldValues extends FieldValues = FieldValues,
  TFieldArrayName extends
    FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,
  TKeyName extends string = 'id',
> = {
  swap: UseFieldArraySwap;
  move: UseFieldArrayMove;
  prepend: UseFieldArrayPrepend<TFieldValues, TFieldArrayName>;
  append: UseFieldArrayAppend<TFieldValues, TFieldArrayName>;
  remove: UseFieldArrayRemove;
  insert: UseFieldArrayInsert<TFieldValues, TFieldArrayName>;
  update: UseFieldArrayUpdate<TFieldValues, TFieldArrayName>;
  replace: UseFieldArrayReplace<TFieldValues, TFieldArrayName>;
  fields: FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>[];
};


